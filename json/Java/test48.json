{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "Which of the following is NOT a feature of Spring Framework?",
      "options": {
        "A": "Dependency Injection",
        "B": "Aspect-Oriented Programming",
        "C": "Inversion of Control",
        "D": "Native Mobile Development Support"
      },
      "correct_answer": "D"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "public class StaticDemo {\n    static {\n        System.out.println(\"Static block executed\");\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"Main method executed\");\n    }\n}",
      "options": {
        "A": "Main method executed",
        "B": "Static block executed",
        "C": "Static block executed\nMain method executed",
        "D": "No output"
      },
      "correct_answer": "C"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What is the primary difference between @PathVariable and @RequestParam in Spring?",
      "options": {
        "A": "@PathVariable extracts values from the query string while @RequestParam extracts values from the URI path",
        "B": "@PathVariable extracts values from the URI path while @RequestParam extracts values from the query string",
        "C": "@PathVariable is used for POST requests while @RequestParam is used for GET requests",
        "D": "@PathVariable is used for authentication while @RequestParam is used for authorization"
      },
      "correct_answer": "B"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "import java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class MapComparison {\n    public static void main(String[] args) {\n        Map<String, Integer> hashMap = new HashMap<>();\n        Map<String, Integer> treeMap = new TreeMap<>();\n        Map<String, Integer> linkedHashMap = new LinkedHashMap<>();\n        \n        hashMap.put(\"C\", 3);\n        hashMap.put(\"A\", 1);\n        hashMap.put(\"B\", 2);\n        \n        treeMap.put(\"C\", 3);\n        treeMap.put(\"A\", 1);\n        treeMap.put(\"B\", 2);\n        \n        linkedHashMap.put(\"C\", 3);\n        linkedHashMap.put(\"A\", 1);\n        linkedHashMap.put(\"B\", 2);\n        \n        System.out.println(treeMap.keySet());\n    }\n}",
      "options": {
        "A": "[C, A, B]",
        "B": "[A, B, C]",
        "C": "Random order",
        "D": "Compilation error"
      },
      "correct_answer": "B"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What is the primary purpose of Spring Boot Starters?",
      "options": {
        "A": "To start the application faster",
        "B": "To provide pre-configured dependencies for specific functionality",
        "C": "To automatically compile Java code",
        "D": "To configure server settings"
      },
      "correct_answer": "B"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "public class ThreadDemo {\n    public static void main(String[] args) {\n        Thread t = new Thread(() -> {\n            System.out.println(\"Thread running\");\n        });\n        \n        t.setDaemon(true);\n        t.start();\n        System.out.println(\"Is daemon: \" + t.isDaemon());\n    }\n}",
      "options": {
        "A": "Thread running\nIs daemon: true",
        "B": "Is daemon: true\nThread running",
        "C": "Is daemon: true",
        "D": "Either option A or B (order not guaranteed)"
      },
      "correct_answer": "D"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What is the difference between throw and throws keywords in Java?",
      "options": {
        "A": "throw is used to declare exceptions, throws is used to explicitly throw an exception",
        "B": "throw is used within a method to explicitly throw an exception, throws is used in method declaration to specify exceptions that might be thrown",
        "C": "throw can only be used with checked exceptions, throws can be used with both checked and unchecked exceptions",
        "D": "throw is used for runtime exceptions, throws is used for checked exceptions"
      },
      "correct_answer": "B"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "public class ThreadStateDemo {\n    public static void main(String[] args) {\n        Thread t = new Thread();\n        System.out.println(t.getState());\n        \n        t.start();\n        System.out.println(t.getState());\n    }\n}",
      "options": {
        "A": "NEW\nRUNNABLE",
        "B": "RUNNABLE\nRUNNING",
        "C": "NEW\nTERMINATED",
        "D": "NEW\nWAITING"
      },
      "correct_answer": "A"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "import java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\npublic class SetDemo {\n    public static void main(String[] args) {\n        Set<String> linkedHashSet = new LinkedHashSet<>();\n        linkedHashSet.add(\"C\");\n        linkedHashSet.add(\"A\");\n        linkedHashSet.add(\"B\");\n        linkedHashSet.add(\"A\"); // Duplicate\n        \n        System.out.println(linkedHashSet);\n    }\n}",
      "options": {
        "A": "[A, B, C]",
        "B": "[C, A, B]",
        "C": "[C, A, B, A]",
        "D": "[C, A, A, B]"
      },
      "correct_answer": "B"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "Which annotation is used to mark a class as a service component in Spring?",
      "options": {
        "A": "@Controller",
        "B": "@Repository",
        "C": "@Service",
        "D": "@Component"
      },
      "correct_answer": "C"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "class Parent {\n    void show() {\n        System.out.println(\"Parent's show\");\n    }\n}\n\nclass Child extends Parent {\n    void show() {\n        System.out.println(\"Child's show\");\n    }\n}\n\npublic class OverridingDemo {\n    public static void main(String[] args) {\n        Parent p = new Child();\n        p.show();\n    }\n}",
      "options": {
        "A": "Parent's show",
        "B": "Child's show",
        "C": "Compilation error",
        "D": "Runtime error"
      },
      "correct_answer": "B"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "In Spring Boot, which configuration file is automatically loaded when the application starts?",
      "options": {
        "A": "config.properties",
        "B": "application.properties",
        "C": "spring.properties",
        "D": "bootstrap.properties"
      },
      "correct_answer": "B"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "public class ThreadCreationDemo {\n    public static void main(String[] args) {\n        // Method 1: Extending Thread class\n        class MyThread extends Thread {\n            public void run() {\n                System.out.println(\"Thread from Thread class\");\n            }\n        }\n        \n        // Method 2: Implementing Runnable interface\n        Runnable myRunnable = new Runnable() {\n            public void run() {\n                System.out.println(\"Thread from Runnable interface\");\n            }\n        };\n        \n        new MyThread().start();\n        new Thread(myRunnable).start();\n    }\n}",
      "options": {
        "A": "Thread from Thread class\nThread from Runnable interface",
        "B": "Thread from Runnable interface\nThread from Thread class",
        "C": "Thread from Thread class (Runnable thread doesn't start)",
        "D": "Either option A or B (order not guaranteed)"
      },
      "correct_answer": "D"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What is the primary difference between HashMap and TreeMap in Java?",
      "options": {
        "A": "TreeMap allows null keys while HashMap doesn't",
        "B": "HashMap is synchronized while TreeMap is not",
        "C": "TreeMap maintains insertion order while HashMap doesn't",
        "D": "TreeMap maintains keys in sorted order while HashMap doesn't"
      },
      "correct_answer": "D"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "class Calculation {\n    void sum(int a, int b) {\n        System.out.println(\"Sum of integers: \" + (a + b));\n    }\n    \n    void sum(double a, double b) {\n        System.out.println(\"Sum of doubles: \" + (a + b));\n    }\n    \n    void sum(String a, String b) {\n        System.out.println(\"Concatenation of strings: \" + a + b);\n    }\n}\n\npublic class OverloadingDemo {\n    public static void main(String[] args) {\n        Calculation calc = new Calculation();\n        calc.sum(5, 10);           // Line 1\n        calc.sum(5.2, 10.3);       // Line 2\n        calc.sum(\"Hello\", \"World\"); // Line 3\n    }\n}",
      "options": {
        "A": "Sum of integers: 15\nSum of doubles: 15.5\nConcatenation of strings: HelloWorld",
        "B": "Sum of integers: 15\nSum of doubles: 15.5\nConcatenation of strings: Hello World",
        "C": "Compilation error, method overloading not allowed with different return types",
        "D": "Sum of integers: 15\nCompilation error at Line 2 and Line 3"
      },
      "correct_answer": "A"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What is the primary purpose of the @SpringBootApplication annotation?",
      "options": {
        "A": "It only provides RESTful web service capabilities",
        "B": "It only configures Spring Security",
        "C": "It combines @Configuration, @EnableAutoConfiguration, and @ComponentScan",
        "D": "It is used for database connection configuration"
      },
      "correct_answer": "C"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What will be the output of the following code demonstrating method hiding?",
      "code_example": "class Parent {\n    static void display() {\n        System.out.println(\"Static method in Parent\");\n    }\n}\n\nclass Child extends Parent {\n    static void display() {\n        System.out.println(\"Static method in Child\");\n    }\n}\n\npublic class MethodHidingDemo {\n    public static void main(String[] args) {\n        Parent p = new Child();\n        p.display();\n        \n        Child c = new Child();\n        c.display();\n    }\n}",
      "options": {
        "A": "Static method in Child\nStatic method in Child",
        "B": "Static method in Parent\nStatic method in Child",
        "C": "Static method in Child\nStatic method in Parent",
        "D": "Static method in Parent\nStatic method in Parent"
      },
      "correct_answer": "B"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "import java.util.concurrent.ConcurrentHashMap;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ConcurrentMapDemo {\n    public static void main(String[] args) {\n        Map<String, Integer> concurrentMap = new ConcurrentHashMap<>();\n        concurrentMap.put(\"A\", 1);\n        concurrentMap.put(\"B\", 2);\n        concurrentMap.put(\"C\", 3);\n        \n        // Try to put a null key\n        try {\n            concurrentMap.put(null, 4);\n            System.out.println(\"Null key added\");\n        } catch (Exception e) {\n            System.out.println(\"Cannot add null key: \" + e.getClass().getSimpleName());\n        }\n        \n        // Try to put a null value\n        try {\n            concurrentMap.put(\"D\", null);\n            System.out.println(\"Null value added\");\n        } catch (Exception e) {\n            System.out.println(\"Cannot add null value: \" + e.getClass().getSimpleName());\n        }\n    }\n}",
      "options": {
        "A": "Null key added\nNull value added",
        "B": "Cannot add null key: NullPointerException\nCannot add null value: NullPointerException",
        "C": "Cannot add null key: IllegalArgumentException\nCannot add null value: IllegalArgumentException",
        "D": "Null key added\nCannot add null value: NullPointerException"
      },
      "correct_answer": "B"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "In Spring Boot, what is the correct way to activate a specific profile using application.properties?",
      "options": {
        "A": "active.profile=dev",
        "B": "spring.profile.active=dev",
        "C": "spring.profiles.active=dev",
        "D": "spring.activeProfiles=dev"
      },
      "correct_answer": "C"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "class Animal {\n    Object makeSound() {\n        System.out.println(\"Generic animal sound\");\n        return new Object();\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    String makeSound() {\n        System.out.println(\"Woof\");\n        return \"Dog sound\";\n    }\n}\n\npublic class CovariantReturnDemo {\n    public static void main(String[] args) {\n        Animal animal = new Dog();\n        System.out.println(animal.makeSound().getClass().getSimpleName());\n    }\n}",
      "options": {
        "A": "Generic animal sound\nObject",
        "B": "Woof\nString",
        "C": "Woof\nObject",
        "D": "Compilation error: return type is incompatible"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "public class ThreadLocalDemo {\n    private static ThreadLocal<Integer> threadLocal = new ThreadLocal<Integer>() {\n        @Override\n        protected Integer initialValue() {\n            return 0;\n        }\n    };\n    \n    public static void main(String[] args) throws InterruptedException {\n        Thread thread1 = new Thread(() -> {\n            threadLocal.set(1);\n            System.out.println(\"Thread 1: \" + threadLocal.get());\n        });\n        \n        Thread thread2 = new Thread(() -> {\n            threadLocal.set(2);\n            System.out.println(\"Thread 2: \" + threadLocal.get());\n        });\n        \n        thread1.start();\n        thread2.start();\n        \n        thread1.join();\n        thread2.join();\n        \n        System.out.println(\"Main thread: \" + threadLocal.get());\n    }\n}",
      "options": {
        "A": "Thread 1: 1\nThread 2: 2\nMain thread: 2",
        "B": "Thread 1: 1\nThread 2: 2\nMain thread: 1",
        "C": "Thread 1: 1\nThread 2: 1\nMain thread: 1",
        "D": "Thread 1: 1\nThread 2: 2\nMain thread: 0"
      },
      "correct_answer": "D"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What makes String immutable in Java?",
      "options": {
        "A": "The String class uses a final array of characters internally and doesn't provide any methods to modify it",
        "B": "String literals are stored in the String pool",
        "C": "The String class is marked as final and has private fields",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What is the correct implementation of the equals and hashCode contract in Java?",
      "code_example": "class Person {\n    private String name;\n    private int age;\n    \n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        Person person = (Person) obj;\n        return age == person.age && \n               (name == null ? person.name == null : name.equals(person.name));\n    }\n    \n    @Override\n    public int hashCode() {\n        int result = name != null ? name.hashCode() : 0;\n        result = 31 * result + age;\n        return result;\n    }\n}\n\npublic class EqualsHashCodeDemo {\n    public static void main(String[] args) {\n        Person p1 = new Person(\"John\", 30);\n        Person p2 = new Person(\"John\", 30);\n        Person p3 = new Person(\"Jane\", 25);\n        \n        System.out.println(\"p1.equals(p2): \" + p1.equals(p2));\n        System.out.println(\"p1.equals(p3): \" + p1.equals(p3));\n        System.out.println(\"p1.hashCode() == p2.hashCode(): \" + (p1.hashCode() == p2.hashCode()));\n    }\n}",
      "options": {
        "A": "p1.equals(p2): true\np1.equals(p3): false\np1.hashCode() == p2.hashCode(): false",
        "B": "p1.equals(p2): true\np1.equals(p3): false\np1.hashCode() == p2.hashCode(): true",
        "C": "p1.equals(p2): false\np1.equals(p3): false\np1.hashCode() == p2.hashCode(): false",
        "D": "p1.equals(p2): true\np1.equals(p3): true\np1.hashCode() == p2.hashCode(): true"
      },
      "correct_answer": "B"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "In Spring MVC, what is the order of execution in the request processing chain?",
      "options": {
        "A": "Controller -> View -> Interceptor -> DispatcherServlet",
        "B": "DispatcherServlet -> Interceptor -> Controller -> View",
        "C": "Interceptor -> DispatcherServlet -> Controller -> View",
        "D": "DispatcherServlet -> Controller -> Interceptor -> View"
      },
      "correct_answer": "B"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What will be the output of the following code that demonstrates bean scope?",
      "code_example": "import org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Scope;\n\nclass ScopeBean {\n    private static int instanceCount = 0;\n    \n    public ScopeBean() {\n        instanceCount++;\n    }\n    \n    public int getInstanceCount() {\n        return instanceCount;\n    }\n}\n\n@Configuration\nclass AppConfig {\n    @Bean\n    @Scope(\"singleton\")\n    public ScopeBean singletonBean() {\n        return new ScopeBean();\n    }\n    \n    @Bean\n    @Scope(\"prototype\")\n    public ScopeBean prototypeBean() {\n        return new ScopeBean();\n    }\n}\n\npublic class BeanScopeDemo {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = \n            new AnnotationConfigApplicationContext(AppConfig.class);\n        \n        // Get singleton bean twice\n        ScopeBean singleton1 = context.getBean(\"singletonBean\", ScopeBean.class);\n        ScopeBean singleton2 = context.getBean(\"singletonBean\", ScopeBean.class);\n        \n        // Get prototype bean twice\n        ScopeBean prototype1 = context.getBean(\"prototypeBean\", ScopeBean.class);\n        ScopeBean prototype2 = context.getBean(\"prototypeBean\", ScopeBean.class);\n        \n        System.out.println(\"Total instance count: \" + prototype2.getInstanceCount());\n        System.out.println(\"singleton1 == singleton2: \" + (singleton1 == singleton2));\n        System.out.println(\"prototype1 == prototype2: \" + (prototype1 == prototype2));\n        \n        context.close();\n    }\n}",
      "options": {
        "A": "Total instance count: 3\nsingleton1 == singleton2: true\nprototype1 == prototype2: false",
        "B": "Total instance count: 4\nsingleton1 == singleton2: false\nprototype1 == prototype2: false",
        "C": "Total instance count: 3\nsingleton1 == singleton2: true\nprototype1 == prototype2: true",
        "D": "Total instance count: 4\nsingleton1 == singleton2: true\nprototype1 == prototype2: false"
      },
      "correct_answer": "A"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "When using @Qualifier with @Autowired in Spring, what is its primary purpose?",
      "options": {
        "A": "To specify which implementation to use when multiple beans of the same type exist",
        "B": "To qualify a bean as mandatory for the application to start",
        "C": "To prioritize lazy loading of beans",
        "D": "To specify the transaction propagation level"
      },
      "correct_answer": "A"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\ninterface MessageService {\n    String getMessage();\n}\n\nclass DefaultMessageService implements MessageService {\n    @Override\n    public String getMessage() {\n        return \"Default message\";\n    }\n}\n\nclass CustomMessageService implements MessageService {\n    @Override\n    public String getMessage() {\n        return \"Custom message\";\n    }\n}\n\n@Configuration\nclass DefaultConfig {\n    @Bean\n    @ConditionalOnMissingBean\n    public MessageService messageService() {\n        return new DefaultMessageService();\n    }\n}\n\n@Configuration\nclass CustomConfig {\n    @Bean\n    public MessageService messageService() {\n        return new CustomMessageService();\n    }\n}\n\npublic class AutoConfigurationDemo {\n    public static void main(String[] args) {\n        // Assuming Spring context loads both configurations\n        // and CustomConfig is processed first\n        MessageService service = null; // This would be injected in a real application\n        \n        // In a real application with both configurations:\n        // What will service.getMessage() return?\n    }\n}",
      "options": {
        "A": "Default message",
        "B": "Custom message",
        "C": "Both messages will be returned in undefined order",
        "D": "Application will fail to start due to bean definition conflict"
      },
      "correct_answer": "B"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What is the correct approach for content negotiation in Spring Boot REST APIs?",
      "options": {
        "A": "Using the @RequestMapping produces attribute to specify supported media types",
        "B": "Implementing separate controllers for each content type",
        "C": "Using URL patterns like /api/resource.json or /api/resource.xml",
        "D": "All of the above are valid approaches"
      },
      "correct_answer": "D"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What will be the output of the following Spring Boot test?",
      "code_example": "import org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.mock.mockito.MockBean;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.when;\n\ninterface WeatherService {\n    String getWeather(String city);\n}\n\nclass WeatherController {\n    private final WeatherService weatherService;\n    \n    public WeatherController(WeatherService weatherService) {\n        this.weatherService = weatherService;\n    }\n    \n    public String getWeatherInfo(String city) {\n        return \"Weather for \" + city + \": \" + weatherService.getWeather(city);\n    }\n}\n\n@SpringBootTest\nclass WeatherControllerTest {\n    \n    @MockBean\n    private WeatherService weatherService;\n    \n    @Autowired\n    private WeatherController weatherController;\n    \n    @Test\n    void testGetWeatherInfo() {\n        // Arrange\n        when(weatherService.getWeather(\"London\")).thenReturn(\"Rainy\");\n        \n        // Act\n        String result = weatherController.getWeatherInfo(\"London\");\n        \n        // Assert\n        assertEquals(\"Weather for Paris: Rainy\", result);\n    }\n}",
      "options": {
        "A": "Test passes successfully",
        "B": "Test fails with assertion error",
        "C": "Compilation error due to incorrect test annotation",
        "D": "Runtime error because MockBean cannot be used with interfaces"
      },
      "correct_answer": "B"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "In JWT authentication with Spring Security, which of the following is NOT a standard claim in a JWT token?",
      "options": {
        "A": "iss (issuer)",
        "B": "sub (subject)",
        "C": "auth (authorities)",
        "D": "exp (expiration time)"
      },
      "correct_answer": "C"
    },
{
      "id": 31,
      "difficulty": "medium",
      "question": "How can you exclude a specific auto-configuration class in Spring Boot?",
      "options": {
        "A": "By using @DisableAutoConfiguration annotation",
        "B": "By using the exclude attribute in @EnableAutoConfiguration",
        "C": "By removing the related dependency from the classpath",
        "D": "By setting spring.autoconfigure.exclude property to false"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "3",
        "B": "2",
        "C": "ConcurrentModificationException",
        "D": "IndexOutOfBoundsException"
      },
      "correct_answer": "A",
      "code_example": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic class SynchronizedCollectionTest {\n    public static void main(String[] args) {\n        CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        \n        for (Integer item : list) {\n            if (item == 2) {\n                list.remove(item);\n            }\n        }\n        \n        System.out.println(list.size());\n    }\n}"
    },
    {
      "id": 33,
      "difficulty": "hard",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "true, false, true",
        "B": "true, false, false",
        "C": "false, false, true",
        "D": "false, true, false"
      },
      "correct_answer": "B",
      "code_example": "import java.util.HashMap;\n\nclass Employee {\n    private int id;\n    private String name;\n    \n    public Employee(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n    \n    @Override\n    public int hashCode() {\n        return id;\n    }\n    \n    // No equals method override\n}\n\nclass CorrectEmployee {\n    private int id;\n    private String name;\n    \n    public CorrectEmployee(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n    \n    @Override\n    public int hashCode() {\n        return id;\n    }\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        CorrectEmployee other = (CorrectEmployee) obj;\n        return id == other.id;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        HashMap<Employee, String> map1 = new HashMap<>();\n        Employee e1 = new Employee(1, \"John\");\n        Employee e2 = new Employee(1, \"John\");\n        map1.put(e1, \"Developer\");\n        \n        HashMap<CorrectEmployee, String> map2 = new HashMap<>();\n        CorrectEmployee ce1 = new CorrectEmployee(1, \"John\");\n        CorrectEmployee ce2 = new CorrectEmployee(1, \"John\");\n        map2.put(ce1, \"Developer\");\n        \n        System.out.print(e1.hashCode() == e2.hashCode());\n        System.out.print(\", \" + map1.containsKey(e2));\n        System.out.print(\", \" + map2.containsKey(ce2));\n    }\n}"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "Which statement about the contract between hashCode() and equals() methods in Java is incorrect?",
      "options": {
        "A": "If two objects are equal according to equals(), they must have the same hashCode() value",
        "B": "If two objects have the same hashCode() value, they must be equal according to equals()",
        "C": "hashCode() must consistently return the same integer for the same object during a single execution of an application",
        "D": "For efficiency, hashCode() should attempt to generate a uniform distribution of integers for objects that are not equal"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "Animal says hello\\nDog says hello\\nDog says woof",
        "B": "Animal says hello\\nAnimal says hello\\nDog says woof",
        "C": "Dog says hello\\nDog says hello\\nDog says woof",
        "D": "Animal says hello\\nDog says hello\\nAnimal says woof"
      },
      "correct_answer": "A",
      "code_example": "class Animal {\n    public static void sayHello() {\n        System.out.println(\"Animal says hello\");\n    }\n    \n    public void makeSound() {\n        System.out.println(\"Animal makes sound\");\n    }\n}\n\nclass Dog extends Animal {\n    public static void sayHello() {\n        System.out.println(\"Dog says hello\");\n    }\n    \n    @Override\n    public void makeSound() {\n        System.out.println(\"Dog says woof\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal animal = new Dog(); // Animal reference, Dog object\n        Animal.sayHello(); // Static method call via class\n        animal.sayHello(); // Static method call via reference\n        animal.makeSound(); // Instance method call\n    }\n}"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "What is the result of executing the following code?",
      "options": {
        "A": "Original Person: Name=John, Age=30, Address=123 Main St\\nCloned Person: Name=John, Age=30, Address=123 Main St\\nAfter modification - Original Person: Name=John, Age=30, Address=456 Oak Ave\\nAfter modification - Cloned Person: Name=John, Age=30, Address=456 Oak Ave",
        "B": "Original Person: Name=John, Age=30, Address=123 Main St\\nCloned Person: Name=John, Age=30, Address=123 Main St\\nAfter modification - Original Person: Name=John, Age=30, Address=123 Main St\\nAfter modification - Cloned Person: Name=John, Age=30, Address=456 Oak Ave",
        "C": "Original Person: Name=John, Age=30, Address=123 Main St\\nCloned Person: Name=John, Age=30, Address=123 Main St\\nAfter modification - Original Person: Name=John, Age=30, Address=456 Oak Ave\\nAfter modification - Cloned Person: Name=John, Age=30, Address=123 Main St",
        "D": "Original Person: Name=John, Age=30, Address=123 Main St\\nCloned Person: Name=John, Age=30, Address=123 Main St\\nAfter modification - Original Person: Name=John, Age=35, Address=456 Oak Ave\\nAfter modification - Cloned Person: Name=John, Age=30, Address=123 Main St"
      },
      "correct_answer": "A",
      "code_example": "class Address {\n    private String street;\n    \n    public Address(String street) {\n        this.street = street;\n    }\n    \n    public void setStreet(String street) {\n        this.street = street;\n    }\n    \n    public String getStreet() {\n        return street;\n    }\n    \n    @Override\n    public String toString() {\n        return street;\n    }\n}\n\nclass Person implements Cloneable {\n    private String name;\n    private int age;\n    private Address address;\n    \n    public Person(String name, int age, Address address) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n    }\n    \n    public void setAge(int age) {\n        this.age = age;\n    }\n    \n    public Address getAddress() {\n        return address;\n    }\n    \n    @Override\n    public Person clone() throws CloneNotSupportedException {\n        return (Person) super.clone();\n    }\n    \n    @Override\n    public String toString() {\n        return \"Name=\" + name + \", Age=\" + age + \", Address=\" + address;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            Address address = new Address(\"123 Main St\");\n            Person original = new Person(\"John\", 30, address);\n            Person cloned = original.clone();\n            \n            System.out.println(\"Original Person: \" + original);\n            System.out.println(\"Cloned Person: \" + cloned);\n            \n            // Modify the shared address object\n            address.setStreet(\"456 Oak Ave\");\n            \n            System.out.println(\"After modification - Original Person: \" + original);\n            System.out.println(\"After modification - Cloned Person: \" + cloned);\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates covariant return types?",
      "options": {
        "A": "Creating Vehicle\\nCreating Car\\nVehicle created\\nCreating Vehicle\\nCreating Car\\nCar created\\nClass of vehicle factory result: class Vehicle\\nClass of car factory result: class Car",
        "B": "Creating Vehicle\\nVehicle created\\nCreating Vehicle\\nCreating Car\\nCar created\\nClass of vehicle factory result: class Vehicle\\nClass of car factory result: class Car",
        "C": "Creating Vehicle\\nCreating Car\\nVehicle created\\nCreating Car\\nCar created\\nClass of vehicle factory result: class Vehicle\\nClass of car factory result: class Car",
        "D": "Creating Vehicle\\nVehicle created\\nCreating Vehicle\\nCreating Car\\nCar created\\nClass of vehicle factory result: class Vehicle\\nClass of car factory result: class Vehicle"
      },
      "correct_answer": "C",
      "code_example": "class Vehicle {\n    public Vehicle() {\n        System.out.println(\"Creating Vehicle\");\n    }\n}\n\nclass Car extends Vehicle {\n    public Car() {\n        System.out.println(\"Creating Car\");\n    }\n}\n\nclass VehicleFactory {\n    public Vehicle createVehicle() {\n        Vehicle v = new Vehicle();\n        System.out.println(\"Vehicle created\");\n        return v;\n    }\n}\n\nclass CarFactory extends VehicleFactory {\n    @Override\n    public Car createVehicle() { // Covariant return type\n        Car c = new Car();\n        System.out.println(\"Car created\");\n        return c;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        VehicleFactory vf = new VehicleFactory();\n        Vehicle vehicle = vf.createVehicle();\n        \n        VehicleFactory cf = new CarFactory();\n        Vehicle car = cf.createVehicle();\n        \n        System.out.println(\"Class of vehicle factory result: \" + vehicle.getClass());\n        System.out.println(\"Class of car factory result: \" + car.getClass());\n    }\n}"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "Which statement regarding Spring Bean Post Processors is correct?",
      "options": {
        "A": "BeanPostProcessor methods are called for each bean instance created by the Spring IoC container",
        "B": "InitializingBean interface provides a callback method that is called after all bean properties have been set but before any BeanPostProcessor methods are invoked",
        "C": "A bean implementing DisposableBean will have its destroy() method called after all postProcessBeforeDestruction methods from registered DestructionAwareBeanPostProcessors",
        "D": "BeanPostProcessor allows modification of bean instances before the initialization callback methods (like @PostConstruct) are called"
      },
      "correct_answer": "A",
      "code_example": null
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "What will be the output of the following code demonstrating dynamic method dispatch?",
      "options": {
        "A": "Parent process\\nChild process\\nChild process",
        "B": "Parent process\\nParent process\\nChild process",
        "C": "Child process\\nChild process\\nChild process",
        "D": "Parent process\\nChild process\\nParent process"
      },
      "correct_answer": "A",
      "code_example": "class Parent {\n    void process() {\n        System.out.println(\"Parent process\");\n    }\n    \n    void execute() {\n        process(); // This call will be dynamically dispatched\n    }\n}\n\nclass Child extends Parent {\n    @Override\n    void process() {\n        System.out.println(\"Child process\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Parent p = new Parent();\n        p.process(); // Direct call to Parent's process\n        \n        Parent c = new Child(); // Parent reference but Child object\n        c.execute(); // Will call execute() in Parent, but process() is dynamically dispatched\n        \n        Child child = new Child();\n        child.process(); // Direct call to Child's process\n    }\n}"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "Which of the following statements about Spring Profiles and Environment Configuration is incorrect?",
      "options": {
        "A": "The @Profile annotation can be used on @Component, @Service, @Repository, and @Controller classes",
        "B": "Multiple profiles can be activated simultaneously using the 'spring.profiles.active' property",
        "C": "The default profile is always active regardless of which other profiles are explicitly activated",
        "D": "Profile-specific properties files follow the naming convention 'application-{profile}.properties'"
      },
      "correct_answer": "C",
      "code_example": null
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "Which statement about securing REST APIs with Spring Security is correct?",
      "options": {
        "A": "Method-level security using @PreAuthorize cannot access method arguments in its expressions",
        "B": "OAuth2 resource server configuration requires a JwtDecoder bean but cannot be customized with a JwtAuthenticationConverter",
        "C": "CORS must be configured separately from Spring Security and cannot be integrated with the SecurityFilterChain",
        "D": "The WebSecurityConfigurerAdapter is deprecated in favor of component-based security configuration with SecurityFilterChain beans"
      },
      "correct_answer": "D",
      "code_example": null
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "What will be the output of the following code using the Fork/Join Framework?",
      "options": {
        "A": "Result: 55",
        "B": "Result: 45",
        "C": "Result: 50",
        "D": "Result: 60"
      },
      "correct_answer": "A",
      "code_example": "import java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.RecursiveTask;\n\nclass SumTask extends RecursiveTask<Integer> {\n    private static final int THRESHOLD = 3;\n    private final int[] array;\n    private final int start;\n    private final int end;\n    \n    public SumTask(int[] array, int start, int end) {\n        this.array = array;\n        this.start = start;\n        this.end = end;\n    }\n    \n    @Override\n    protected Integer compute() {\n        int length = end - start;\n        if (length <= THRESHOLD) {\n            // Sequential processing for small enough chunks\n            int sum = 0;\n            for (int i = start; i < end; i++) {\n                sum += array[i];\n            }\n            return sum;\n        } else {\n            // Split the task\n            int mid = start + length / 2;\n            SumTask leftTask = new SumTask(array, start, mid);\n            SumTask rightTask = new SumTask(array, mid, end);\n            \n            // Fork the left task\n            leftTask.fork();\n            \n            // Compute the right task directly\n            int rightResult = rightTask.compute();\n            \n            // Join the left task with the result\n            int leftResult = leftTask.join();\n            \n            // Combine the results\n            return leftResult + rightResult;\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        ForkJoinPool pool = new ForkJoinPool();\n        SumTask task = new SumTask(numbers, 0, numbers.length);\n        int result = pool.invoke(task);\n        System.out.println(\"Result: \" + result);\n    }\n}"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What is the result of executing the following code that demonstrates HashMap's resizing mechanism?",
      "options": {
        "A": "Capacity: 16, Load Factor: 0.75\\nSize before threshold: 11\\nSize after threshold: 12\\nCapacity after resize: 32",
        "B": "Capacity: 16, Load Factor: 0.75\\nSize before threshold: 11\\nSize after threshold: 12\\nCapacity after resize: 16",
        "C": "Capacity: 16, Load Factor: 0.75\\nSize before threshold: 12\\nSize after threshold: 13\\nCapacity after resize: 32",
        "D": "Capacity: 16, Load Factor: 0.75\\nSize before threshold: 11\\nSize after threshold: 13\\nCapacity after resize: 32"
      },
      "correct_answer": "A",
      "code_example": "import java.lang.reflect.Field;\nimport java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Create a HashMap with default initial capacity (16) and load factor (0.75)\n        HashMap<String, Integer> map = new HashMap<>();\n        \n        // Get the capacity and load factor using reflection\n        int capacity = getCapacity(map);\n        float loadFactor = getLoadFactor(map);\n        System.out.println(\"Capacity: \" + capacity + \", Load Factor: \" + loadFactor);\n        \n        // Calculate threshold (capacity * load factor)\n        int threshold = (int)(capacity * loadFactor);\n        \n        // Add elements just before reaching the threshold\n        for (int i = 0; i < threshold - 1; i++) {\n            map.put(\"Key\" + i, i);\n        }\n        \n        System.out.println(\"Size before threshold: \" + map.size());\n        int capacityBeforeResize = getCapacity(map);\n        \n        // Add an element that should trigger resizing\n        map.put(\"TriggerResize1\", 100);\n        map.put(\"TriggerResize2\", 101);\n        \n        System.out.println(\"Size after threshold: \" + map.size());\n        int capacityAfterResize = getCapacity(map);\n        \n        System.out.println(\"Capacity after resize: \" + capacityAfterResize);\n    }\n    \n    private static int getCapacity(HashMap<?, ?> map) throws Exception {\n        Field tableField = HashMap.class.getDeclaredField(\"table\");\n        tableField.setAccessible(true);\n        Object[] table = (Object[]) tableField.get(map);\n        return table == null ? 0 : table.length;\n    }\n    \n    private static float getLoadFactor(HashMap<?, ?> map) throws Exception {\n        Field loadFactorField = HashMap.class.getDeclaredField(\"loadFactor\");\n        loadFactorField.setAccessible(true);\n        return (float) loadFactorField.get(map);\n    }\n}"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "Which of the following statements about JVM internals is incorrect?",
      "options": {
        "A": "The Method Area stores class structures including method code, constant runtime pool, field and method data",
        "B": "The Bootstrap ClassLoader, Extension ClassLoader, and Application ClassLoader follow a delegation model for class loading",
        "C": "Objects in the Old Generation are collected by the Serial or Parallel Garbage Collector, but cannot be collected by the G1 Garbage Collector",
        "D": "The JVM stack stores frames, with each frame containing local variables, operand stack, and reference to the runtime constant pool"
      },
      "correct_answer": "C",
      "code_example": null
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What will be the output of the following code using ThreadLocal variables?",
      "options": {
        "A": "Main thread value: Initial Value\\nThread-1 value: Thread-1 Value\\nMain thread value after Thread-1 modification: Initial Value",
        "B": "Main thread value: Initial Value\\nThread-1 value: Initial Value\\nMain thread value after Thread-1 modification: Thread-1 Value",
        "C": "Main thread value: null\\nThread-1 value: Thread-1 Value\\nMain thread value after Thread-1 modification: null",
        "D": "Main thread value: Initial Value\\nThread-1 value: null\\nMain thread value after Thread-1 modification: Initial Value"
      },
      "correct_answer": "A",
      "code_example": "public class Main {\n    // Create a ThreadLocal variable\n    private static ThreadLocal<String> threadLocalValue = new ThreadLocal<>();\n    \n    public static void main(String[] args) throws InterruptedException {\n        // Set initial value in main thread\n        threadLocalValue.set(\"Initial Value\");\n        System.out.println(\"Main thread value: \" + threadLocalValue.get());\n        \n        // Create a new thread that sets its own copy of the ThreadLocal variable\n        Thread thread1 = new Thread(() -> {\n            // Each thread has its own copy of the ThreadLocal variable\n            // Initially it will be null for this thread\n            threadLocalValue.set(\"Thread-1 Value\");\n            System.out.println(\"Thread-1 value: \" + threadLocalValue.get());\n        });\n        \n        thread1.start();\n        thread1.join(); // Wait for thread1 to complete\n        \n        // The value in the main thread remains unchanged\n        System.out.println(\"Main thread value after Thread-1 modification: \" + threadLocalValue.get());\n    }\n}"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "What will be the output of the following code demonstrating thread interruption?",
      "options": {
        "A": "Worker thread starting\\nCounting: 1\\nCounting: 2\\nCounting: 3\\nCounting: 4\\nCounting: 5\\nThread was interrupted, cleaning up\\nWorker thread exited gracefully",
        "B": "Worker thread starting\\nCounting: 1\\nCounting: 2\\nCounting: 3\\nThread was interrupted, cleaning up\\nWorker thread exited gracefully",
        "C": "Worker thread starting\\nCounting: 1\\nCounting: 2\\nCounting: 3\\nCounting: 4\\nCounting: 5\\nWorker thread exited gracefully",
        "D": "Worker thread starting\\nCounting: 1\\nCounting: 2\\nCounting: 3\\nInterruptedException occurred\\nWorker thread exited gracefully"
      },
      "correct_answer": "B",
      "code_example": "public class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Thread workerThread = new Thread(() -> {\n            System.out.println(\"Worker thread starting\");\n            \n            try {\n                // Count from 1 to 10, sleeping between each count\n                for (int i = 1; i <= 10; i++) {\n                    System.out.println(\"Counting: \" + i);\n                    Thread.sleep(1000); // Sleep for 1 second\n                    \n                    // Check for interruption\n                    if (Thread.currentThread().isInterrupted()) {\n                        System.out.println(\"Thread was interrupted, cleaning up\");\n                        break; // Exit the loop if interrupted\n                    }\n                }\n            } catch (InterruptedException e) {\n                // This is called if interrupt() is called while thread is sleeping\n                System.out.println(\"InterruptedException occurred\");\n                return; // Exit the thread\n            }\n            \n            System.out.println(\"Worker thread exited gracefully\");\n        });\n        \n        workerThread.start();\n        \n        // Let the worker thread run for a bit\n        Thread.sleep(3500); // Sleep for 3.5 seconds\n        \n        // Interrupt the worker thread\n        workerThread.interrupt();\n        \n        // Wait for worker thread to finish\n        workerThread.join();\n    }\n}"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What is the output of the following code that demonstrates a deadlock scenario?",
      "options": {
        "A": "Thread-1: Acquired resource1\\nThread-2: Acquired resource2\\nDeadlock detected with diagnosis: Thread 'Thread-1' is waiting for 'resource2' while holding 'resource1'\\nThread 'Thread-2' is waiting for 'resource1' while holding 'resource2'",
        "B": "Thread-1: Acquired resource1\\nThread-2: Acquired resource2\\nThread-1: Acquired resource2\\nThread-2: Acquired resource1\\nBoth threads completed successfully",
        "C": "Thread-1: Acquired resource1\\nThread-2: Acquired resource2\\n[Indefinite waiting with no further output due to deadlock]",
        "D": "Thread-1: Acquired resource1\\nThread-1: Acquired resource2\\nThread-2: Acquired resource1\\nThread-2: Acquired resource2\\nBoth threads completed successfully"
      },
      "correct_answer": "C",
      "code_example": "public class Main {\n    private static final Object resource1 = new Object();\n    private static final Object resource2 = new Object();\n    \n    public static void main(String[] args) {\n        // Thread-1 attempts to lock resource1 then resource2\n        Thread thread1 = new Thread(() -> {\n            synchronized (resource1) {\n                System.out.println(\"Thread-1: Acquired resource1\");\n                \n                try {\n                    Thread.sleep(100); // Delay to make deadlock more likely\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                \n                synchronized (resource2) {\n                    System.out.println(\"Thread-1: Acquired resource2\");\n                }\n            }\n        });\n        \n        // Thread-2 attempts to lock resource2 then resource1\n        Thread thread2 = new Thread(() -> {\n            synchronized (resource2) {\n                System.out.println(\"Thread-2: Acquired resource2\");\n                \n                try {\n                    Thread.sleep(100); // Delay to make deadlock more likely\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                \n                synchronized (resource1) {\n                    System.out.println(\"Thread-2: Acquired resource1\");\n                }\n            }\n        });\n        \n        thread1.start();\n        thread2.start();\n    }\n}"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "Which statement about interfaces and abstract classes in Java is correct?",
      "options": {
        "A": "Since Java 8, interfaces can have default and static methods, but unlike abstract classes, they cannot have private methods",
        "B": "Abstract classes can have constructor methods while interfaces cannot, but with Java 9, interfaces can have private methods",
        "C": "A class can extend multiple abstract classes but implement only one interface",
        "D": "Abstract classes are better for defining a contract for unrelated classes, while interfaces are better for providing a common implementation for related classes"
      },
      "correct_answer": "B",
      "code_example": null
    }
  ]
}
