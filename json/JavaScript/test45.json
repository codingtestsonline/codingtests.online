{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const greeting = `Hello, ${'world'.toUpperCase()}!`;\nconsole.log(greeting);",
      "options": {
        "A": "Hello, world!",
        "B": "Hello, WORLD!",
        "C": "`Hello, ${'world'.toUpperCase()}!`",
        "D": "HELLO, WORLD!"
      },
      "correct_answer": "B"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "Which of the following correctly selects an element with the ID 'user-profile' from the DOM?",
      "options": {
        "A": "document.querySelector('#user-profile')",
        "B": "document.getElementById('#user-profile')",
        "C": "document.getElementById('user-profile')",
        "D": "document.queryElement('user-profile')"
      },
      "correct_answer": "C"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function sum(...numbers) {\n  return numbers.reduce((total, num) => total + num, 0);\n}\n\nconsole.log(sum(1, 2, 3, 4));",
      "options": {
        "A": "[1, 2, 3, 4]",
        "B": "Error: numbers.reduce is not a function",
        "C": "10",
        "D": "0"
      },
      "correct_answer": "C"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const person = { name: 'Alex', age: 28 };\nconst { name, job = 'Developer' } = person;\nconsole.log(job);",
      "options": {
        "A": "undefined",
        "B": "null",
        "C": "Developer",
        "D": "Error: job is not defined"
      },
      "correct_answer": "C"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const values = [3, 7, 2, 9];\nconst max = Math.max(...values);\nconsole.log(max);",
      "options": {
        "A": "9",
        "B": "[3, 7, 2, 9]",
        "C": "Error: values is not iterable",
        "D": "NaN"
      },
      "correct_answer": "A"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What is the key difference between 'const', 'let', and 'var' declarations in JavaScript?",
      "options": {
        "A": "'const' variables can be reassigned, 'let' variables cannot be reassigned, and 'var' is block-scoped",
        "B": "'const' variables cannot be reassigned, 'let' variables can be reassigned, and 'var' is function-scoped",
        "C": "'const' and 'let' are both function-scoped, while 'var' is block-scoped",
        "D": "There is no difference between them; they are all block-scoped"
      },
      "correct_answer": "B"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function showArgs() {\n  return arguments.length;\n}\n\nconsole.log(showArgs('hello', 'world', 2023));",
      "options": {
        "A": "undefined",
        "B": "['hello', 'world', 2023]",
        "C": "3",
        "D": "Error: arguments is not defined"
      },
      "correct_answer": "C"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const regularFunc = function(x) { return x * 2; };\nconst arrowFunc = x => x * 2;\n\nconsole.log(regularFunc(5) === arrowFunc(5));",
      "options": {
        "A": "false",
        "B": "true",
        "C": "Error: arrow functions cannot return values",
        "D": "10"
      },
      "correct_answer": "B"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "Which of the following correctly reads the contents of a file synchronously using Node.js?",
      "options": {
        "A": "fs.readFile('data.txt', callback)",
        "B": "fs.readFileSync('data.txt', 'utf8')",
        "C": "fs.read('data.txt')",
        "D": "fs.loadFile('data.txt', 'utf8')"
      },
      "correct_answer": "B"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const a = null;\nconst b = undefined;\nconst c = '';\n\nconsole.log(Boolean(a || b || c));",
      "options": {
        "A": "true",
        "B": "false",
        "C": "null",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const obj = { a: 1, b: 2, c: 3 };\nconst values = Object.values(obj);\nconsole.log(values);",
      "options": {
        "A": "{ 1, 2, 3 }",
        "B": "['a', 'b', 'c']",
        "C": "[1, 2, 3]",
        "D": "{ a: 1, b: 2, c: 3 }"
      },
      "correct_answer": "C"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What is the primary difference between require() and import() in JavaScript?",
      "options": {
        "A": "require() is synchronous while import() is asynchronous",
        "B": "require() works only in browsers, import() works only in Node.js",
        "C": "require() allows partial imports while import() doesn't",
        "D": "There is no difference; they are interchangeable"
      },
      "correct_answer": "A"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "async function getData() {\n  return 'Data received';\n}\n\nconst result = getData();\nconsole.log(result instanceof Promise);",
      "options": {
        "A": "Data received",
        "B": "false",
        "C": "true",
        "D": "undefined"
      },
      "correct_answer": "C"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const arr1 = [1, 2, 3];\nconst arr2 = arr1;\narr2.push(4);\nconsole.log(arr1);",
      "options": {
        "A": "[1, 2, 3]",
        "B": "[1, 2, 3, 4]",
        "C": "[4, 1, 2, 3]",
        "D": "Error: arr1 is const and cannot be modified"
      },
      "correct_answer": "B"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const element = document.getElementById('example');\nelement.textContent = '<b>Hello</b>';\n// Assuming element exists in the DOM",
      "options": {
        "A": "The element displays 'Hello' in bold text",
        "B": "The element displays '<b>Hello</b>' as plain text",
        "C": "Error: textContent cannot modify elements",
        "D": "The element remains unchanged"
      },
      "correct_answer": "B"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "Which primitive type in JavaScript represents a special value for an intentionally absent value?",
      "options": {
        "A": "undefined",
        "B": "null",
        "C": "NaN",
        "D": "void"
      },
      "correct_answer": "B"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function outer() {\n  let count = 0;\n  return function() {\n    return ++count;\n  };\n}\n\nconst increment = outer();\nconsole.log(increment());\nconsole.log(increment());",
      "options": {
        "A": "0, 0",
        "B": "1, 1",
        "C": "1, 2",
        "D": "Error: count is not defined"
      },
      "correct_answer": "C"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "Which HTTP status code represents a successful request with no content returned?",
      "options": {
        "A": "200 OK",
        "B": "204 No Content",
        "C": "404 Not Found",
        "D": "304 Not Modified"
      },
      "correct_answer": "B"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What will be the output of the following code in a Node.js environment?",
      "code_example": "const EventEmitter = require('events');\nconst myEmitter = new EventEmitter();\n\nmyEmitter.on('event', (a, b) => {\n  console.log(a, b);\n});\n\nmyEmitter.emit('event', 'Hello', 'World');",
      "options": {
        "A": "Error: events module not found",
        "B": "'event' 'Hello'",
        "C": "Hello World",
        "D": "Nothing is printed"
      },
      "correct_answer": "C"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "Which of the following correctly validates that a request body contains a non-empty 'email' field using express-validator?",
      "code_example": "const { body, validationResult } = require('express-validator');\n\napp.post('/user', [\n  // Validation middleware here\n], (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  // Process valid request\n});",
      "options": {
        "A": "body('email').isValid()",
        "B": "body('email').notEmpty()",
        "C": "body('email').exists()",
        "D": "body('email').required()"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function compose(f, g) {\n  return function(x) {\n    return f(g(x));\n  };\n}\n\nconst add2 = x => x + 2;\nconst multiply3 = x => x * 3;\nconst composed = compose(add2, multiply3);\n\nconsole.log(composed(5));",
      "options": {
        "A": "17",
        "B": "21",
        "C": "15",
        "D": "11"
      },
      "correct_answer": "A"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "In Express.js, what is the primary purpose of the 'next' parameter in middleware functions?",
      "options": {
        "A": "To send a response to the client",
        "B": "To pass control to the next matching route",
        "C": "To access the next request in the queue",
        "D": "To terminate the request-response cycle"
      },
      "correct_answer": "B"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "Function.prototype.customBind = function(context) {\n  const fn = this;\n  return function() {\n    return fn.apply(context);\n  };\n};\n\nconst obj = { value: 42 };\nfunction getValue() {\n  return this.value;\n}\n\nconst boundGetValue = getValue.customBind(obj);\nconsole.log(boundGetValue());",
      "options": {
        "A": "undefined",
        "B": "null",
        "C": "42",
        "D": "Error: this.value is not defined"
      },
      "correct_answer": "C"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "Which of the following correctly sets up a MongoDB schema with validation that requires a 'name' field with a minimum length of 3 characters?",
      "code_example": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\n\nconst userSchema = new Schema({\n  // Schema definition here\n});",
      "options": {
        "A": "name: { type: String, required: true, min: 3 }",
        "B": "name: { type: String, required: true, minlength: 3 }",
        "C": "name: { type: String, required: true, validate: { min: 3 } }",
        "D": "name: { type: String, required: true, length: { min: 3 } }"
      },
      "correct_answer": "B"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const user = {\n  name: 'John',\n  greet: function() {\n    return `Hello, ${this.name}`;\n  }\n};\n\nconst greetFn = user.greet;\nconsole.log(greetFn());",
      "options": {
        "A": "Hello, John",
        "B": "Hello, undefined",
        "C": "Error: this.name is not defined",
        "D": "Hello, "
      },
      "correct_answer": "B"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "Which Express.js middleware correctly handles parsing JSON request bodies?",
      "options": {
        "A": "app.use(express.json())",
        "B": "app.use(express.parseJSON())",
        "C": "app.use(bodyParser.json())",
        "D": "app.use(express.bodyParser())"
      },
      "correct_answer": "A"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const promise1 = Promise.resolve('First');\nconst promise2 = Promise.resolve('Second');\n\nPromise.race([promise1, promise2])\n  .then(result => console.log(result));",
      "options": {
        "A": "['First', 'Second']",
        "B": "Second",
        "C": "First",
        "D": "Error: promises must be rejected or fulfilled asynchronously"
      },
      "correct_answer": "C"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "Which of the following correctly sets up an error handling middleware in Express.js?",
      "code_example": "const express = require('express');\nconst app = express();\n\napp.get('/users', (req, res) => {\n  throw new Error('Database connection failed');\n});\n\n// Error handler middleware here",
      "options": {
        "A": "app.use((err) => { res.status(500).send(err.message); })",
        "B": "app.error((err, req, res, next) => { res.status(500).send(err.message); })",
        "C": "app.use((err, req, res, next) => { res.status(500).send(err.message); })",
        "D": "app.catch((err, req, res) => { res.status(500).send(err.message); })"
      },
      "correct_answer": "C"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "Which HTTP method is most appropriate for updating a specific resource when the entire resource is being replaced?",
      "options": {
        "A": "PATCH",
        "B": "POST",
        "C": "PUT",
        "D": "UPDATE"
      },
      "correct_answer": "C"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const arr = [1, 2, 3, 4, 5];\nconst [first, ...rest] = arr;\nconsole.log(rest.reduce((sum, num) => sum + num, 0));",
      "options": {
        "A": "15",
        "B": "10",
        "C": "14",
        "D": "Error: rest is not iterable"
      },
      "correct_answer": "C"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What is the most efficient way to update a specific field in a MongoDB document using Mongoose?",
      "code_example": "// Assume User is a valid Mongoose model\nconst userId = '60d5ec9df682fbd12a0b4d8a';\n\n// Update operation here",
      "options": {
        "A": "User.find(userId).then(user => { user.status = 'active'; return user.save(); })",
        "B": "User.findByIdAndUpdate(userId, { status: 'active' })",
        "C": "User.update({ _id: userId }, { status: 'active' })",
        "D": "User.findById(userId).update({ status: 'active' })"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const fs = require('fs');\nconst readStream = fs.createReadStream('example.txt', { highWaterMark: 1024 });\n\nlet chunkCount = 0;\nreadStream.on('data', chunk => {\n  chunkCount++;\n});\n\nreadStream.on('end', () => {\n  console.log(`Read ${chunkCount} chunks`);\n});\n\n// Assuming example.txt is 3KB in size",
      "options": {
        "A": "Read 1 chunks",
        "B": "Read 3 chunks",
        "C": "Read 3072 chunks",
        "D": "Error: file size not specified"
      },
      "correct_answer": "B"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "Which of the following statements about memory allocation in JavaScript is correct?",
      "options": {
        "A": "JavaScript uses manual memory management, requiring explicit allocation and deallocation of memory",
        "B": "V8's garbage collector uses mark-and-sweep for young objects and reference counting for old objects",
        "C": "The JavaScript heap is split into different regions including young generation (nursery) and old generation (tenured) space",
        "D": "JavaScript memory allocation is deterministic, allowing developers to predict exactly when objects will be garbage collected"
      },
      "correct_answer": "C"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "What will be the output of the following code regarding memory allocation?",
      "code_example": "function createLargeArray() {\n  const arr = new Array(1000).fill(0);\n  return function() {\n    console.log('Array length:', arr.length);\n    return arr;\n  };\n}\n\nconst getArray = createLargeArray();\nconst result = getArray();\nconsole.log(typeof result);",
      "options": {
        "A": "Array length: 1000\\nstring",
        "B": "Array length: 1000\\nfunction",
        "C": "Array length: 1000\\nobject",
        "D": "Array length: 1000\\nundefined"
      },
      "correct_answer": "C"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "Which is the most effective way to prevent Cross-Site Request Forgery (CSRF) in a Node.js application?",
      "options": {
        "A": "Implementing a Content Security Policy (CSP)",
        "B": "Using JSON Web Tokens (JWT) for all API requests",
        "C": "Implementing same-origin policies in the browser",
        "D": "Using synchronized token patterns with anti-CSRF tokens that are validated on each state-changing request"
      },
      "correct_answer": "D"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "What will be the output of the following Node.js clustering code?",
      "code_example": "const cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = 2; // Simplified for testing\n\nif (cluster.isMaster) {\n  console.log(`Master process ${process.pid} is running`);\n  \n  // Fork workers\n  for (let i = 0; i < numCPUs; i++) {\n    const worker = cluster.fork();\n    \n    worker.on('message', (msg) => {\n      if (msg.cmd && msg.cmd === 'WORKER_STARTED') {\n        console.log(`Worker ${msg.pid} started`);\n      }\n    });\n  }\n  \n  cluster.on('exit', (worker) => {\n    console.log(`Worker ${worker.process.pid} died`);\n  });\n} else {\n  // Workers can share any TCP connection\n  process.send({ cmd: 'WORKER_STARTED', pid: process.pid });\n  \n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end(`Worker ${process.pid} handled request\\n`);\n  }).listen(8000);\n}",
      "options": {
        "A": "It logs the master process ID once, starts two worker processes, and each worker handles HTTP requests independently",
        "B": "It creates a single HTTP server that handles all requests through the master process",
        "C": "It throws an error because cluster.fork() cannot be used inside a for loop",
        "D": "It creates two worker processes but they cannot communicate back to the master process"
      },
      "correct_answer": "A"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "What is the correct way to implement a bidirectional, real-time communication between a client and server using socket.io?",
      "code_example": "// Server-side (Node.js)\nconst http = require('http');\nconst server = http.createServer();\nconst io = require('socket.io')(server);\n\nio.on('connection', (socket) => {\n  console.log('Client connected');\n  \n  socket.on('client_event', (data) => {\n    console.log('Received from client:', data);\n    // Process data and respond\n    socket.emit('server_response', { status: 'success', message: 'Data processed' });\n  });\n  \n  socket.on('disconnect', () => {\n    console.log('Client disconnected');\n  });\n});\n\nserver.listen(3000);\n\n// Client-side (Browser)\nconst socket = io.connect('http://localhost:3000');\n\nsocket.on('connect', () => {\n  console.log('Connected to server');\n  \n  // Send data to server\n  socket.emit('client_event', { action: 'request_data' });\n});\n\nsocket.on('server_response', (data) => {\n  console.log('Server responded:', data);\n});\n\nsocket.on('disconnect', () => {\n  console.log('Disconnected from server');\n});",
      "options": {
        "A": "The code is incorrect because socket.io requires explicit room handling for any bidirectional communication",
        "B": "The code is correct but missing error handling and reconnection logic for production use",
        "C": "The code is incorrect because the client cannot directly connect to the server without a namespace",
        "D": "The code is incorrect because the server must first request a connection from the client"
      },
      "correct_answer": "B"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "Which statement about worker threads in Node.js is correct?",
      "options": {
        "A": "Worker threads share memory by default, allowing for easy data transfer between threads",
        "B": "Worker threads can only communicate with the main thread but not with other worker threads",
        "C": "Worker threads use message passing for communication and can transfer ArrayBuffer instances without copying data",
        "D": "Worker threads automatically distribute CPU-intensive tasks across all available CPU cores without explicit code"
      },
      "correct_answer": "C"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "What is the output of this worker thread implementation?",
      "code_example": "// main.js\nconst { Worker } = require('worker_threads');\n\nconst sharedBuffer = new SharedArrayBuffer(4);\nconst sharedArray = new Int32Array(sharedBuffer);\nsharedArray[0] = 5;\n\nconst worker = new Worker(`\n  const { parentPort, workerData } = require('worker_threads');\n  const sharedArray = new Int32Array(workerData.buffer);\n  \n  // Atomically add 7 to the shared value\n  Atomics.add(sharedArray, 0, 7);\n  \n  parentPort.postMessage('Calculation complete');\n`, { eval: true, workerData: { buffer: sharedBuffer } });\n\nworker.on('message', (message) => {\n  console.log(message);\n  console.log('Final value:', sharedArray[0]);\n});",
      "options": {
        "A": "Calculation complete\\nFinal value: 5",
        "B": "Calculation complete\\nFinal value: 7",
        "C": "Calculation complete\\nFinal value: 12",
        "D": "Error: SharedArrayBuffer is not defined"
      },
      "correct_answer": "C"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "Which of the following is the most dangerous type of XSS vulnerability in a JavaScript application?",
      "options": {
        "A": "Reflected XSS, because it can bypass CSP protections",
        "B": "DOM-based XSS, because it occurs entirely on the client side and bypasses server-side XSS protections",
        "C": "Stored XSS, because malicious code is permanently stored on the target server and delivered to all visitors",
        "D": "Self-XSS, because it targets users with higher privileges"
      },
      "correct_answer": "C"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What is the correct way to set up a production-ready logging system with Winston in Node.js?",
      "code_example": "const winston = require('winston');\nconst { combine, timestamp, json, colorize, printf } = winston.format;\n\n// Define custom format\nconst customFormat = printf(({ level, message, timestamp }) => {\n  return `${timestamp} [${level}]: ${message}`;\n});\n\n// Create logger\nconst logger = winston.createLogger({\n  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',\n  format: combine(\n    timestamp(),\n    process.env.NODE_ENV === 'production' ? json() : combine(colorize(), customFormat)\n  ),\n  transports: [\n    new winston.transports.File({ filename: 'error.log', level: 'error' }),\n    new winston.transports.File({ filename: 'combined.log' }),\n    process.env.NODE_ENV !== 'production' ? new winston.transports.Console() : null\n  ].filter(Boolean),\n  exceptionHandlers: [\n    new winston.transports.File({ filename: 'exceptions.log' })\n  ]\n});\n\nmodule.exports = logger;",
      "options": {
        "A": "The code has a critical flaw because it doesn't handle promise rejections with rejectionHandlers",
        "B": "The code incorrectly uses environment variables to determine log levels, which is an anti-pattern",
        "C": "The code is correct for a production-ready logging setup with appropriate file transports and formatting",
        "D": "The code is missing required log rotation settings, which will cause the log files to grow indefinitely"
      },
      "correct_answer": "D"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "Which statement about V8's hidden classes and inline caching is correct?",
      "options": {
        "A": "Hidden classes are created at runtime for objects with identical property keys, allowing V8 to optimize property access",
        "B": "Inline caching requires developers to explicitly mark methods for optimization using the @optimize decorator",
        "C": "Hidden classes are used exclusively for prototype methods and cannot optimize object instance properties",
        "D": "V8 only creates hidden classes for objects instantiated with the 'new' keyword and class syntax"
      },
      "correct_answer": "A"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What is the expected output of this code that demonstrates V8's hidden class optimization?",
      "code_example": "function createPoint(x, y) {\n  // Create objects with consistent property order\n  const point1 = { x: x, y: y };\n  const point2 = { x: x+1, y: y+1 };\n  \n  // Create object with different property order\n  const point3 = {};\n  point3.y = y+2;\n  point3.x = x+2;\n  \n  console.time('access-point1');\n  for (let i = 0; i < 1000000; i++) {\n    point1.x;\n  }\n  console.timeEnd('access-point1');\n  \n  console.time('access-point3');\n  for (let i = 0; i < 1000000; i++) {\n    point3.x;\n  }\n  console.timeEnd('access-point3');\n  \n  return `Point1: ${point1.x},${point1.y} | Point3: ${point3.x},${point3.y}`;\n}\n\nconsole.log(createPoint(10, 20));",
      "options": {
        "A": "Point1: 10,20 | Point3: 12,22 (with access-point1 being faster due to hidden class optimization)",
        "B": "Point1: 10,20 | Point3: 12,22 (with both timers showing the same performance)",
        "C": "Point1: 10,20 | Point3: 12,22 (with access-point3 being faster due to lazy initialization)",
        "D": "The code throws an optimization error because point3 violates hidden class constraints"
      },
      "correct_answer": "A"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "Which of the following statements correctly describes the difference between WebSockets, REST, and GraphQL?",
      "options": {
        "A": "REST is stateful, WebSockets are stateless, and GraphQL requires a persistent connection",
        "B": "WebSockets maintain a persistent bidirectional connection, REST is stateless and request-response based, while GraphQL allows clients to request exactly the data they need in a single request",
        "C": "GraphQL can only be used with WebSockets, not with RESTful services",
        "D": "REST supports real-time data by default, while WebSockets and GraphQL both require polling mechanisms"
      },
      "correct_answer": "B"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What is the correct approach for encrypting sensitive data in a Node.js application?",
      "code_example": "const crypto = require('crypto');\n\nfunction encryptData(data, secretKey) {\n  // Generate a random initialization vector\n  const iv = crypto.randomBytes(16);\n  \n  // Create cipher with AES-256-CBC algorithm\n  const cipher = crypto.createCipheriv(\n    'aes-256-cbc',\n    Buffer.from(secretKey, 'hex'),\n    iv\n  );\n  \n  // Encrypt the data\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  \n  // Return IV and encrypted data\n  return iv.toString('hex') + ':' + encrypted;\n}\n\nfunction decryptData(encryptedData, secretKey) {\n  // Split IV and encrypted data\n  const parts = encryptedData.split(':');\n  const iv = Buffer.from(parts[0], 'hex');\n  const encrypted = parts[1];\n  \n  // Create decipher\n  const decipher = crypto.createDecipheriv(\n    'aes-256-cbc',\n    Buffer.from(secretKey, 'hex'),\n    iv\n  );\n  \n  // Decrypt the data\n  let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  \n  return decrypted;\n}\n\n// Generate a secure key (in a real app, this would be stored securely)\nconst key = crypto.randomBytes(32).toString('hex');\nconst sensitive = 'password123';\n\nconst encrypted = encryptData(sensitive, key);\nconsole.log('Encrypted:', encrypted);\n\nconst decrypted = decryptData(encrypted, key);\nconsole.log('Decrypted:', decrypted);",
      "options": {
        "A": "The code is insecure because it uses CBC mode which is vulnerable to padding oracle attacks",
        "B": "The code is insecure because it doesn't use authenticated encryption (should use GCM mode with auth tag)",
        "C": "The code is secure for encrypting sensitive data but has a flaw in storing the key in memory",
        "D": "The code is insecure because it encodes the IV with the ciphertext, allowing potential attackers to derive the key"
      },
      "correct_answer": "B"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "What is the correct implementation of a transform stream in Node.js?",
      "code_example": "const { Transform } = require('stream');\nconst fs = require('fs');\n\nclass UppercaseTransform extends Transform {\n  constructor(options) {\n    super(options);\n  }\n  \n  _transform(chunk, encoding, callback) {\n    // Transform data to uppercase\n    const upperChunk = chunk.toString().toUpperCase();\n    this.push(upperChunk);\n    callback();\n  }\n  \n  _flush(callback) {\n    // Any cleanup or final processing\n    this.push('\\n-- END OF TRANSFORMATION --');\n    callback();\n  }\n}\n\nconst readStream = fs.createReadStream('input.txt');\nconst writeStream = fs.createWriteStream('output.txt');\nconst uppercaseTransform = new UppercaseTransform();\n\nreadStream\n  .pipe(uppercaseTransform)\n  .pipe(writeStream)\n  .on('finish', () => {\n    console.log('Transform completed');\n  });",
      "options": {
        "A": "The code is incorrect because Transform streams cannot use the _flush method",
        "B": "The code is incorrect because the _transform method must return a value instead of using callback()",
        "C": "The code is correct implementation of a transform stream that converts text to uppercase",
        "D": "The code is incorrect because it doesn't handle backpressure properly"
      },
      "correct_answer": "C"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "Which statement about horizontal vs. vertical scaling in Node.js applications is correct?",
      "options": {
        "A": "Vertical scaling is generally preferred over horizontal scaling for Node.js applications due to the event loop's ability to scale with additional cores",
        "B": "Horizontal scaling refers to adding more CPU cores to a single machine, while vertical scaling refers to adding more machines to a cluster",
        "C": "Horizontal scaling involves distributing load across multiple servers and is well-suited for stateless Node.js applications, while vertical scaling involves adding resources to a single server",
        "D": "Node.js applications cannot effectively utilize horizontal scaling due to the single-threaded nature of JavaScript"
      },
      "correct_answer": "C"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "What will be the output of this code that demonstrates a memory leak in Node.js?",
      "code_example": "const memoryLeakDemo = () => {\n  const leakyArray = [];\n  let counter = 0;\n  \n  // This interval never gets cleared\n  const intervalId = setInterval(() => {\n    const huge = new Array(1000000).fill('memory leak');\n    leakyArray.push(huge);\n    \n    counter++;\n    console.log(`Iteration ${counter}: Array length ${leakyArray.length}`);\n    \n    // Only stop after 3 iterations for this demo\n    if (counter >= 3) {\n      clearInterval(intervalId);\n      console.log('Final memory state:', process.memoryUsage().heapUsed / 1024 / 1024, 'MB');\n    }\n  }, 100);\n};\n\nconst startMem = process.memoryUsage().heapUsed / 1024 / 1024;\nconsole.log('Initial memory usage:', startMem.toFixed(2), 'MB');\nmemoryLeakDemo();",
      "options": {
        "A": "The code doesn't cause a memory leak because clearInterval is called after 3 iterations",
        "B": "The code logs increasing memory usage across 3 iterations, but the garbage collector reclaims it immediately after",
        "C": "The code shows increased memory usage that doesn't get reclaimed even after the interval is cleared, demonstrating a memory leak",
        "D": "The code throws an out of memory error before completing the 3 iterations"
      },
      "correct_answer": "C"
    }
  ]
}
