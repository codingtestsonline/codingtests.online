{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled);",
      "options": {
        "A": "[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]",
        "B": "[2, 4, 6, 8, 10]",
        "C": "[1, 4, 9, 16, 25]",
        "D": "TypeError: numbers.map is not a function"
      },
      "correct_answer": "B"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What is the difference between '==' and '===' operators in JavaScript?",
      "options": {
        "A": "They are identical and can be used interchangeably",
        "B": "'==' compares values and types, while '===' only compares values",
        "C": "'==' compares values without type conversion, while '===' compares after type conversion",
        "D": "'==' compares values with type conversion if needed, while '===' compares values and types without conversion"
      },
      "correct_answer": "D"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const fruits = ['apple', 'banana', 'cherry'];\nfruits[5] = 'grape';\nconsole.log(fruits.length);",
      "options": {
        "A": "3",
        "B": "4",
        "C": "5",
        "D": "6"
      },
      "correct_answer": "D"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let x = 5;\nconst y = 10;\nvar z = 15;\n\n{\n  let x = 20;\n  const y = 25;\n  var z = 30;\n  console.log(x, y, z);\n}\n\nconsole.log(x, y, z);",
      "options": {
        "A": "20 25 30 then 5 10 15",
        "B": "20 25 30 then 5 10 30",
        "C": "5 10 30 then 5 10 30",
        "D": "20 25 30 then 20 25 30"
      },
      "correct_answer": "B"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function greet(name = 'Guest') {\n  return `Hello, ${name}!`;\n}\n\nconsole.log(greet());\nconsole.log(greet('John'));",
      "options": {
        "A": "\"Hello, undefined!\" and \"Hello, John!\"",
        "B": "\"Hello, Guest!\" and \"Hello, John!\"",
        "C": "\"Hello, !\" and \"Hello, John!\"",
        "D": "TypeError: Cannot read property 'name' of undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "Which statement about var, let, and const is correct?",
      "options": {
        "A": "var and let are block-scoped, while const is function-scoped",
        "B": "var is function-scoped, while let and const are block-scoped",
        "C": "var, let, and const are all block-scoped",
        "D": "var, let, and const are all function-scoped"
      },
      "correct_answer": "B"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const user1 = {};\nconst user2 = new Object();\n\nuser1.name = 'Alice';\nuser2.name = 'Bob';\n\nconsole.log(typeof user1, typeof user2);",
      "options": {
        "A": "\"object\" \"Object\"",
        "B": "\"Object\" \"object\"",
        "C": "\"object\" \"object\"",
        "D": "\"Object\" \"Object\""
      },
      "correct_answer": "C"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let num = 5;\nnum += 3;\nnum *= 2;\nnum /= 4;\nnum **= 2;\nconsole.log(num);",
      "options": {
        "A": "8",
        "B": "4",
        "C": "16",
        "D": "4.25"
      },
      "correct_answer": "B"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const person = { name: 'John', age: 30, job: 'Developer' };\nconst { name, job } = person;\n\nconsole.log(`${name} works as a ${job}`);",
      "options": {
        "A": "\"John works as a Developer\"",
        "B": "\"undefined works as a undefined\"",
        "C": "TypeError: Cannot destructure property 'name' of 'person' as it is undefined",
        "D": "\"[object Object] works as a [object Object]\""
      },
      "correct_answer": "A"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "Which statement about Node.js is correct?",
      "options": {
        "A": "Node.js is a programming language designed specifically for server-side development",
        "B": "Node.js is a framework built on top of Java for building web applications",
        "C": "Node.js is a runtime environment that allows executing JavaScript code outside of a browser",
        "D": "Node.js is a browser-based JavaScript library for building user interfaces"
      },
      "correct_answer": "C"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const a = true;\nconst b = false;\nconst c = null;\n\nconsole.log(a && b);\nconsole.log(a || c);\nconsole.log(!a);",
      "options": {
        "A": "false, true, false",
        "B": "false, false, true",
        "C": "false, null, false",
        "D": "false, true, true"
      },
      "correct_answer": "A"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "for (let i = 0; i < 5; i++) {\n  if (i === 2) {\n    continue;\n  }\n  if (i === 4) {\n    break;\n  }\n  console.log(i);\n}",
      "options": {
        "A": "0 1 3",
        "B": "0 1 2 3",
        "C": "0 1 3 4",
        "D": "0 1 2 3 4"
      },
      "correct_answer": "A"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const car = {\n  brand: 'Toyota',\n  model: 'Corolla',\n  year: 2020,\n  getInfo: function() {\n    return `${this.brand} ${this.model} (${this.year})`;\n  }\n};\n\nconsole.log(car.getInfo());",
      "options": {
        "A": "\"function getInfo() { return `${this.brand} ${this.model} (${this.year})`; }\"",
        "B": "\"undefined undefined (undefined)\"",
        "C": "\"Toyota Corolla (2020)\"",
        "D": "TypeError: car.getInfo is not a function"
      },
      "correct_answer": "C"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What is the main difference between require() and import() in JavaScript?",
      "options": {
        "A": "require() can only import JSON files, while import() can import any JavaScript module",
        "B": "require() is synchronous and part of CommonJS, while import() is asynchronous and part of ES modules",
        "C": "require() is used in frontend development, while import() is used in Node.js",
        "D": "They are identical and can be used interchangeably in all JavaScript environments"
      },
      "correct_answer": "B"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "Which of the following is NOT a reference type in JavaScript?",
      "options": {
        "A": "Object",
        "B": "Number",
        "C": "Array",
        "D": "Function"
      },
      "correct_answer": "B"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What is the correct way to add a click event listener to a button element with id 'myButton'?",
      "code_example": "// Which option is correct?\n\n// Option A\ndocument.getElementById('myButton').click = function() {\n  alert('Button clicked!');\n};\n\n// Option B\ndocument.getElementById('myButton').addEventListener('click', function() {\n  alert('Button clicked!');\n});\n\n// Option C\ndocument.getElementById('myButton').onClickListener = function() {\n  alert('Button clicked!');\n};\n\n// Option D\ndocument.getElementById('myButton').clickEvent(function() {\n  alert('Button clicked!');\n});",
      "options": {
        "A": "Option A",
        "B": "Option B",
        "C": "Option C",
        "D": "Option D"
      },
      "correct_answer": "B"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What does the following Express.js middleware function do?",
      "code_example": "function(req, res, next) {\n  console.log(`${req.method} ${req.url}`);\n  next();\n}",
      "options": {
        "A": "It redirects all requests to the next route handler",
        "B": "It logs the HTTP method and URL path of each request, then passes control to the next middleware",
        "C": "It validates that the request has a valid method and URL before proceeding",
        "D": "It checks if there's a next middleware and skips it if none exists"
      },
      "correct_answer": "B"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "Which statement about JWT (JSON Web Tokens) is correct?",
      "options": {
        "A": "JWTs store session data on the server to reduce client-side processing",
        "B": "JWTs are encrypted by default and cannot be read without a private key",
        "C": "JWTs contain three parts: header, payload, and signature, separated by dots",
        "D": "JWTs can only be used with HTTPS connections for security reasons"
      },
      "correct_answer": "C"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What will be the output of the following recursive function when called with factorial(5)?",
      "code_example": "function factorial(n) {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}",
      "options": {
        "A": "15",
        "B": "24",
        "C": "120",
        "D": "Stack overflow error"
      },
      "correct_answer": "C"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "Which of the following correctly describes Node.js streams?",
      "options": {
        "A": "Streams are synchronous methods for reading and writing files all at once",
        "B": "Streams are objects that let you read data from a source or write data to a destination in chunks, without loading everything into memory",
        "C": "Streams are only used for networking in Node.js and cannot be used for file operations",
        "D": "Streams are deprecated in Node.js and have been replaced with Promises for all I/O operations"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What does it mean that functions are first-class citizens in JavaScript?",
      "options": {
        "A": "Functions can only be defined at the top level of a program",
        "B": "Functions always have higher execution priority than other code",
        "C": "Functions can be assigned to variables, passed as arguments, and returned from other functions",
        "D": "Functions are always hoisted to the top of their scope"
      },
      "correct_answer": "C"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const numbers = [1, 2, 3, 4, 5];\n\n// Instead of using a loop\nconst sum = numbers.reduce((acc, current) => acc + current, 0);\nconst max = Math.max(...numbers);\n\nconsole.log(sum, max);",
      "options": {
        "A": "15 5",
        "B": "15 undefined",
        "C": "15 NaN",
        "D": "0 5"
      },
      "correct_answer": "A"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "Which statement about caching API responses with Redis in Node.js is correct?",
      "options": {
        "A": "Redis can only cache string data, not complex JSON objects",
        "B": "Redis caching requires a separate server process that runs independently of the Node.js application",
        "C": "Redis automatically caches all API responses; no additional code is needed",
        "D": "Redis cannot set expiration times on cached data; manual deletion is required"
      },
      "correct_answer": "B"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "Which HTTP status code would be most appropriate for an authentication failure due to invalid credentials?",
      "options": {
        "A": "400 Bad Request",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "correct_answer": "B"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What characteristics define a pure function in JavaScript?",
      "code_example": "// Which function is pure?\n\n// Function A\nfunction addA(a, b) {\n  return a + b;\n}\n\n// Function B\nlet total = 0;\nfunction addB(value) {\n  total += value;\n  return total;\n}\n\n// Function C\nfunction addC(arr, value) {\n  arr.push(value);\n  return arr;\n}\n\n// Function D\nfunction addD(a, b) {\n  console.log(`Adding ${a} and ${b}`);\n  return a + b;\n}",
      "options": {
        "A": "Function A",
        "B": "Function B",
        "C": "Function C",
        "D": "Function D"
      },
      "correct_answer": "A"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What is the main purpose of the Morgan middleware in Express.js?",
      "options": {
        "A": "Authentication and authorization of requests",
        "B": "Compression of HTTP responses",
        "C": "HTTP request logging",
        "D": "Rate limiting and throttling of requests"
      },
      "correct_answer": "C"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const app = require('express')();\n\napp.get('/test', (req, res, next) => {\n  throw new Error('Test error');\n});\n\napp.use((err, req, res, next) => {\n  res.status(500).json({ message: err.message });\n});\n\n// What will the response be when a request is made to /test?",
      "options": {
        "A": "HTTP 500 with { \"message\": \"Test error\" }",
        "B": "HTTP 404 Not Found",
        "C": "The server will crash with an unhandled exception",
        "D": "HTTP 200 with an empty response"
      },
      "correct_answer": "A"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\nemitter.on('message', (msg) => {\n  console.log(`Received: ${msg}`);\n});\n\nemitter.emit('message', 'Hello');\nemitter.emit('data', 'World');\nemitter.emit('message', 'Again');",
      "options": {
        "A": "\"Received: Hello\" and \"Received: Again\"",
        "B": "\"Received: Hello\", \"Received: World\", and \"Received: Again\"",
        "C": "\"Received: Hello\" only",
        "D": "No output, as events must be processed asynchronously"
      },
      "correct_answer": "A"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What will be the output of the following function composition code?",
      "code_example": "const add2 = x => x + 2;\nconst multiply3 = x => x * 3;\nconst divide2 = x => x / 2;\n\nconst compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);\nconst pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);\n\nconst composed = compose(divide2, multiply3, add2);\nconst piped = pipe(add2, multiply3, divide2);\n\nconsole.log(composed(4), piped(4));",
      "options": {
        "A": "9 9",
        "B": "9 6",
        "C": "6 9",
        "D": "6 6"
      },
      "correct_answer": "B"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What will be the output of the following Express.js code?",
      "code_example": "const express = require('express');\nconst app = express();\n\napp.get('/data', (req, res) => {\n  res.json({ success: true, data: [1, 2, 3] });\n});\n\n// What will be sent to the client when requesting /data?",
      "options": {
        "A": "A string with the text '{ success: true, data: [1, 2, 3] }'",
        "B": "A JSON object with Content-Type: application/json and the specified data",
        "C": "An error, because res.json() requires a string argument",
        "D": "The raw JavaScript object without proper JSON formatting"
      },
      "correct_answer": "B"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will be the output of the following timing code?",
      "code_example": "console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout 1');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise');\n});\n\nsetTimeout(() => {\n  console.log('Timeout 2');\n}, 0);\n\nconsole.log('End');",
      "options": {
        "A": "\"Start\", \"End\", \"Promise\", \"Timeout 1\", \"Timeout 2\"",
        "B": "\"Start\", \"Promise\", \"End\", \"Timeout 1\", \"Timeout 2\"",
        "C": "\"Start\", \"End\", \"Timeout 1\", \"Timeout 2\", \"Promise\"",
        "D": "\"Start\", \"Timeout 1\", \"Promise\", \"Timeout 2\", \"End\""
      },
      "correct_answer": "A"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What will be the output of the following Promise code?",
      "code_example": "const p1 = Promise.resolve('First');\nconst p2 = new Promise((resolve) => setTimeout(() => resolve('Second'), 100));\nconst p3 = Promise.reject('Third');\nconst p4 = new Promise((resolve) => setTimeout(() => resolve('Fourth'), 200));\n\nPromise.allSettled([p1, p2, p3, p4])\n  .then(results => {\n    console.log(results.map(r => r.status));\n  });",
      "options": {
        "A": "[\"fulfilled\", \"fulfilled\", \"rejected\", \"fulfilled\"]",
        "B": "[\"fulfilled\", \"pending\", \"rejected\", \"pending\"]",
        "C": "Error: Uncaught Promise rejection",
        "D": "[\"resolved\", \"resolved\", \"rejected\", \"resolved\"]"
      },
      "correct_answer": "A"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What will be the output of the following Node.js clustering code?",
      "code_example": "const cluster = require('cluster');\nconst http = require('http');\nconst os = require('os');\n\nif (cluster.isPrimary) {\n  console.log(`Primary ${process.pid} is running`);\n  for (let i = 0; i < 2; i++) {\n    const worker = cluster.fork();\n    worker.on('message', (msg) => {\n      console.log(`Message from worker ${worker.id}: ${msg}`);\n    });\n  }\n  cluster.on('exit', (worker) => {\n    console.log(`Worker ${worker.id} died`);\n  });\n} else {\n  process.send('Hello from worker');\n  console.log(`Worker ${process.pid} started`);\n}",
      "options": {
        "A": "It will log 'Primary {pid} is running' followed by 'Worker {pid} started' twice, and 'Message from worker {id}: Hello from worker' twice",
        "B": "It will log 'Primary {pid} is running' once, and throw an error because forking is not allowed in the cluster module",
        "C": "It will log 'Primary {pid} is running' followed by 'Worker {pid} started' for each CPU core in the system",
        "D": "It will log 'Primary {pid} is running' followed by 'Worker {pid} started' for each worker, but no message logging will occur"
      },
      "correct_answer": "A"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "Which of the following statements about V8 Engine optimizations and hidden classes is correct?",
      "options": {
        "A": "Hidden classes are created only when using the 'class' keyword in JavaScript",
        "B": "Adding properties to an object in different orders will result in the same hidden class",
        "C": "Deleting properties from an object doesn't affect its hidden class",
        "D": "Adding properties to an object after initialization can create new hidden classes and deoptimize code"
      },
      "correct_answer": "D"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What will be the output of the following code that uses the Node.js crypto module?",
      "code_example": "const crypto = require('crypto');\n\nconst algorithm = 'aes-256-cbc';\nconst key = crypto.randomBytes(32);\nconst iv = crypto.randomBytes(16);\n\nfunction encrypt(text) {\n  const cipher = crypto.createCipheriv(algorithm, key, iv);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nfunction decrypt(encryptedText) {\n  const decipher = crypto.createDecipheriv(algorithm, key, iv);\n  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n}\n\nconst secretMessage = 'Hello, World!';\nconst encrypted = encrypt(secretMessage);\nconst decrypted = decrypt(encrypted);\n\nconsole.log(decrypted === secretMessage);",
      "options": {
        "A": "false",
        "B": "true",
        "C": "A TypeError will be thrown because 'hex' is not a valid encoding",
        "D": "The code will hang indefinitely due to a deadlock in the crypto operations"
      },
      "correct_answer": "B"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "When implementing real-time data processing with Node.js streams, which of the following code snippets correctly implements a transform stream that converts data to uppercase?",
      "code_example": "const { Transform } = require('stream');\n\nclass UppercaseTransform extends Transform {\n  constructor(options) {\n    super(options);\n  }\n  \n  _transform(chunk, encoding, callback) {\n    this.push(chunk.toString().toUpperCase());\n    callback();\n  }\n}\n\nconst uppercaser = new UppercaseTransform();\nprocess.stdin.pipe(uppercaser).pipe(process.stdout);",
      "options": {
        "A": "The transform stream will error because _transform should return the transformed data instead of using push()",
        "B": "The transform stream will work but create memory leaks due to improper callback handling",
        "C": "The transform stream will correctly convert input to uppercase, but will fail on binary data",
        "D": "The transform stream will correctly convert input to uppercase as expected"
      },
      "correct_answer": "D"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "Which of the following is NOT a valid option when configuring a Winston logger for log monitoring in Node.js?",
      "options": {
        "A": "level: 'info'",
        "B": "format: winston.format.json()",
        "C": "transports: [new winston.transports.File({ filename: 'error.log' })]",
        "D": "retention: { days: 14 }"
      },
      "correct_answer": "D"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates hidden classes and inline caching in V8?",
      "code_example": "function createPoint(x, y) {\n  const obj = {};\n  obj.x = x;\n  obj.y = y;\n  return obj;\n}\n\nfunction createPointOptimized(x, y) {\n  return { x, y };\n}\n\nfunction distance(p1, p2) {\n  const dx = p1.x - p2.x;\n  const dy = p1.y - p2.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nconst points1 = [];\nconst points2 = [];\n\n// Create 1 million points\nfor (let i = 0; i < 1000000; i++) {\n  points1.push(createPoint(i, i));\n  points2.push(createPointOptimized(i, i));\n}\n\nconst start1 = performance.now();\nlet sum1 = 0;\nfor (let i = 0; i < 1000; i++) {\n  sum1 += distance(points1[i], points1[i+1]);\n}\nconst end1 = performance.now();\n\nconst start2 = performance.now();\nlet sum2 = 0;\nfor (let i = 0; i < 1000; i++) {\n  sum2 += distance(points2[i], points2[i+1]);\n}\nconst end2 = performance.now();\n\nconsole.log(`Difference: ${(end1 - start1) - (end2 - start2) > 0 ? 'createPointOptimized is faster' : 'createPoint is faster'}`);",
      "options": {
        "A": "createPoint is faster",
        "B": "createPointOptimized is faster",
        "C": "Both functions perform exactly the same",
        "D": "The code will throw an error because performance.now() is not available in Node.js"
      },
      "correct_answer": "B"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "When implementing refresh tokens and access tokens for authentication, which approach is considered a best practice?",
      "options": {
        "A": "Store both access and refresh tokens in localStorage for best performance",
        "B": "Use the same expiration time for both access and refresh tokens",
        "C": "Store access tokens in memory and refresh tokens in an HTTP-only secure cookie",
        "D": "Include the user's password hash in the refresh token for additional security"
      },
      "correct_answer": "C"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "What will be the output of the following code using custom event listeners in Node.js?",
      "code_example": "const EventEmitter = require('events');\n\nclass OrderProcessor extends EventEmitter {\n  constructor() {\n    super();\n    this.on('order:new', this.processOrder);\n  }\n\n  processOrder(order) {\n    console.log(`Processing order ${order.id}`);\n    this.emit('order:processed', order);\n  }\n}\n\nconst processor = new OrderProcessor();\n\nprocessor.on('order:processed', (order) => {\n  console.log(`Order ${order.id} has been processed`);\n});\n\nprocessor.emit('order:new', { id: 1234 });",
      "options": {
        "A": "Processing order 1234\nOrder 1234 has been processed",
        "B": "TypeError: Cannot read property 'id' of undefined",
        "C": "Order 1234 has been processed",
        "D": "Processing order 1234\nTypeError: this.emit is not a function"
      },
      "correct_answer": "D"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "When implementing WebSockets with socket.io, what will be the output of the following server-side code?",
      "code_example": "const http = require('http');\nconst server = http.createServer();\nconst io = require('socket.io')(server);\n\nio.on('connection', (socket) => {\n  console.log('New client connected');\n  \n  socket.on('join_room', (roomName) => {\n    socket.join(roomName);\n    console.log(`Socket ${socket.id} joined room: ${roomName}`);\n    \n    // Send message to all clients in the room except the sender\n    socket.to(roomName).emit('user_joined', `${socket.id} has joined ${roomName}`);\n    \n    // Send message to all clients in the room including the sender\n    io.to(roomName).emit('room_update', `Room ${roomName} has ${io.sockets.adapter.rooms.get(roomName).size} members`);\n  });\n});\n\nserver.listen(3000, () => {\n  console.log('Server listening on port 3000');\n});",
      "options": {
        "A": "The server will emit 'user_joined' to all clients including the sender",
        "B": "The server will emit 'room_update' only to the sender",
        "C": "The server will emit 'user_joined' to all clients except the sender, and 'room_update' to all clients in the room",
        "D": "The code will throw an error because rooms are not supported in socket.io"
      },
      "correct_answer": "C"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "When debugging Node.js applications with node --inspect, which of the following statements is TRUE?",
      "options": {
        "A": "The --inspect flag automatically stops execution at the first line of code",
        "B": "Chrome DevTools can connect to the Node.js debugger on the default port 9229",
        "C": "Using --inspect exposes the debugger to the internet by default on port 80",
        "D": "The --inspect flag only works with npm scripts and not with direct node execution"
      },
      "correct_answer": "B"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What is the security issue in the following code for JWT token creation?",
      "code_example": "const jwt = require('jsonwebtoken');\nconst express = require('express');\nconst app = express();\n\nconst JWT_SECRET = 'my-super-secret-key';\n\napp.post('/login', (req, res) => {\n  // Assume user is authenticated\n  const { username, role } = req.body;\n  \n  const token = jwt.sign(\n    { username, role, permissions: ['read', 'write'] },\n    JWT_SECRET,\n    { expiresIn: '1h' }\n  );\n  \n  res.json({ token });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
      "options": {
        "A": "The JWT algorithm should be explicitly specified for security",
        "B": "The JWT token doesn't include a 'jti' (JWT ID) claim",
        "C": "The JWT secret is hardcoded in the application code",
        "D": "The expiration time of 1 hour is too long for a JWT token"
      },
      "correct_answer": "C"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "When setting up Prometheus and Grafana for Node.js monitoring, which of the following statements is FALSE?",
      "options": {
        "A": "Prometheus collects metrics at regular intervals by scraping HTTP endpoints",
        "B": "The prom-client library is commonly used to expose metrics from Node.js applications",
        "C": "Grafana can connect directly to a Node.js application without Prometheus as an intermediary",
        "D": "Prometheus uses a pull model while most monitoring systems use a push model"
      },
      "correct_answer": "C"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What is the output of the following code that demonstrates container management with the Docker API?",
      "code_example": "const Docker = require('dockerode');\nconst docker = new Docker();\n\nasync function runContainer() {\n  try {\n    const container = await docker.createContainer({\n      Image: 'node:14',\n      Cmd: ['node', '-e', 'console.log(\"Hello from container!\")'],\n      AttachStdout: true,\n      AttachStderr: true\n    });\n    \n    await container.start();\n    \n    const stream = await container.logs({\n      follow: true,\n      stdout: true,\n      stderr: true\n    });\n    \n    stream.on('data', (chunk) => {\n      // Docker prefixes each line with 8 bytes of header\n      const message = chunk.toString('utf8').slice(8);\n      console.log(`Container output: ${message.trim()}`);\n    });\n    \n    await new Promise(resolve => setTimeout(resolve, 1000));\n    await container.remove({ force: true });\n    \n    return 'Container ran and was removed';\n  } catch (err) {\n    return `Error: ${err.message}`;\n  }\n}\n\nrunContainer().then(console.log);",
      "options": {
        "A": "Container output: Hello from container!\nContainer ran and was removed",
        "B": "Error: connect ECONNREFUSED 127.0.0.1:2375",
        "C": "The code will create a container but fail to remove it due to missing force parameter",
        "D": "The code will fail because dockerode doesn't support the logs method"
      },
      "correct_answer": "B"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "Which of the following correctly describes a Kubernetes pod configuration in a YAML file?",
      "options": {
        "A": "A pod can contain multiple containers that share the same filesystem",
        "B": "A pod must contain exactly one container",
        "C": "Pods are self-healing and automatically restart when they fail",
        "D": "Pods cannot communicate with each other unless explicitly linked with a Service"
      },
      "correct_answer": "A"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What will be the output of the following code after deploying it to Heroku?",
      "code_example": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\nconst server = app.listen(process.env.PORT || 3000, () => {\n  console.log(`Server running on port ${server.address().port}`);\n});\n\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM signal received: closing HTTP server');\n  server.close(() => {\n    console.log('HTTP server closed');\n  });\n});",
      "options": {
        "A": "The application will fail to start because Heroku doesn't support the SIGTERM signal",
        "B": "The application will start but crash because process.env.PORT is not defined on Heroku",
        "C": "The application will start successfully using a port assigned by Heroku",
        "D": "The application will start but will not properly handle Heroku's dyno cycling because it's missing a SIGINT handler"
      },
      "correct_answer": "C"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "Which statement about the differences between WebSockets, REST, and GraphQL is FALSE?",
      "code_example": "// WebSocket example\nconst WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', function connection(ws) {\n  ws.on('message', function incoming(message) {\n    console.log('received: %s', message);\n    ws.send('got your message!');\n  });\n});\n\n// REST example\napp.get('/users/:id', (req, res) => {\n  const user = getUser(req.params.id);\n  res.json(user);\n});\n\n// GraphQL example\nconst typeDefs = gql`\n  type User {\n    id: ID!\n    name: String\n    email: String\n    posts: [Post!]\n  }\n  \n  type Post {\n    id: ID!\n    title: String\n    content: String\n  }\n  \n  type Query {\n    user(id: ID!): User\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    user: (parent, { id }) => getUser(id)\n  },\n  User: {\n    posts: (user) => getUserPosts(user.id)\n  }\n};",
      "options": {
        "A": "WebSockets maintain a persistent connection while REST and GraphQL typically use stateless request-response cycles",
        "B": "REST endpoints typically return fixed data structures while GraphQL allows clients to request only the data they need",
        "C": "GraphQL always outperforms REST and WebSockets in terms of performance and bandwidth usage",
        "D": "WebSockets allow for real-time bidirectional communication while REST is primarily unidirectional"
      },
      "correct_answer": "C"
    }
  ]
}
