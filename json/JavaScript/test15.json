{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(typeof null);",
      "options": {
        "A": "null",
        "B": "undefined",
        "C": "object",
        "D": "string"
      },
      "correct_answer": "C"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What's the difference between require() and import() in JavaScript?",
      "options": {
        "A": "require() is synchronous, import() is asynchronous",
        "B": "require() is for Node.js only, import() is for browsers only",
        "C": "require() can be called anywhere in the code, import() must be at the top",
        "D": "require() can only import JSON files, import() can import any module"
      },
      "correct_answer": "A"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const obj = { a: 1, b: 2, c: 3 };\nconsole.log(Object.values(obj));",
      "options": {
        "A": "['a', 'b', 'c']",
        "B": "[1, 2, 3]",
        "C": "{ a: 1, b: 2, c: 3 }",
        "D": "[['a', 1], ['b', 2], ['c', 3]]"
      },
      "correct_answer": "B"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const person = { name: 'John', age: 30 };\nconst { name, height = 175 } = person;\nconsole.log(height);",
      "options": {
        "A": "undefined",
        "B": "null",
        "C": "0",
        "D": "175"
      },
      "correct_answer": "D"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "Which field in package.json specifies the entry point to your application?",
      "options": {
        "A": "entry",
        "B": "main",
        "C": "start",
        "D": "index"
      },
      "correct_answer": "B"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "for (let i = 0; i < 5; i++) {\n  if (i === 2) continue;\n  if (i === 4) break;\n  console.log(i);\n}",
      "options": {
        "A": "0 1 3",
        "B": "0 1 2 3",
        "C": "0 1 3 4",
        "D": "1 2 3"
      },
      "correct_answer": "A"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(5 & 3);",
      "options": {
        "A": "8",
        "B": "2",
        "C": "1",
        "D": "15"
      },
      "correct_answer": "C"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function sum() {\n  let total = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}\n\nconsole.log(sum(1, 2, 3));",
      "options": {
        "A": "1",
        "B": "3",
        "C": "6",
        "D": "Error: arguments is not defined"
      },
      "correct_answer": "C"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const arr = [1, 2, 3, 4];\nlet sum = 0;\n\narr.forEach(num => {\n  if (num % 2 === 0) {\n    sum += num;\n  }\n});\n\nconsole.log(sum);",
      "options": {
        "A": "0",
        "B": "6",
        "C": "10",
        "D": "[2, 4]"
      },
      "correct_answer": "B"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "Which of the following is NOT a primitive type in JavaScript?",
      "options": {
        "A": "string",
        "B": "array",
        "C": "number",
        "D": "symbol"
      },
      "correct_answer": "B"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled);",
      "options": {
        "A": "[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]",
        "B": "[2, 4, 6, 8, 10]",
        "C": "[1, 4, 9, 16, 25]",
        "D": "30"
      },
      "correct_answer": "B"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const car = {\n  brand: 'Toyota',\n  start: function() {\n    return `${this.brand} engine started`;\n  }\n};\n\nconsole.log(car.start());",
      "options": {
        "A": "undefined engine started",
        "B": "Toyota engine started",
        "C": "this.brand engine started",
        "D": "Error: this is undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const greet = name => `Hello, ${name}!`;\nconsole.log(greet('World'));",
      "options": {
        "A": "Hello, World!",
        "B": "Hello, name!",
        "C": "Hello, ${name}!",
        "D": "undefined"
      },
      "correct_answer": "A"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const name = 'John';\nconst greeting = `Hello, ${name}!`;\nconsole.log(greeting);",
      "options": {
        "A": "Hello, ${name}!",
        "B": "Hello, name!",
        "C": "Hello, John!",
        "D": "Error: Invalid syntax"
      },
      "correct_answer": "C"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(2 ** 3 + 4 * 2 - 6 / 2);",
      "options": {
        "A": "13",
        "B": "11",
        "C": "16",
        "D": "14"
      },
      "correct_answer": "A"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What is the difference between == and === in JavaScript?",
      "options": {
        "A": "== checks for equality, === checks for identity",
        "B": "== performs type conversion before comparison, === doesn't",
        "C": "== is used for numbers only, === works with all types",
        "D": "== is faster than ==="
      },
      "correct_answer": "B"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What HTTP status code indicates an unauthorized request?",
      "options": {
        "A": "400",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "correct_answer": "B"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "When working with large files in Node.js, which approach is most memory-efficient?",
      "options": {
        "A": "Using fs.readFile to load the entire file into memory",
        "B": "Using fs.createReadStream to process the file in chunks",
        "C": "Using child_process.exec to open the file in another process",
        "D": "Using require() to import the file directly"
      },
      "correct_answer": "B"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const person = {\n  name: 'John',\n  address: {\n    city: 'New York',\n    zip: '10001'\n  }\n};\n\nconst { name, address: { city } } = person;\nconsole.log(city);",
      "options": {
        "A": "undefined",
        "B": "{ city: 'New York', zip: '10001' }",
        "C": "New York",
        "D": "Error: Cannot read property 'city' of undefined"
      },
      "correct_answer": "C"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "In MongoDB with Mongoose, which method would you use to find and update a document in a single operation?",
      "options": {
        "A": "Model.update()",
        "B": "Model.findByIdAndUpdate()",
        "C": "Model.updateById()",
        "D": "Model.modifyOne()"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const obj = {\n  name: 'Test',\n  createArrow: function() {\n    return () => {\n      console.log(this.name);\n    };\n  },\n  createRegular: function() {\n    return function() {\n      console.log(this.name);\n    };\n  }\n};\n\nconst arrowFn = obj.createArrow();\nconst regularFn = obj.createRegular();\n\narrowFn();",
      "options": {
        "A": "undefined",
        "B": "Test",
        "C": "Error: this is not defined",
        "D": "window"
      },
      "correct_answer": "B"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "Which of the following is a characteristic of a pure function?",
      "options": {
        "A": "It modifies global variables for better performance",
        "B": "It produces different outputs for the same inputs depending on external state",
        "C": "It has no side effects and returns the same output for the same input",
        "D": "It always returns a Promise"
      },
      "correct_answer": "C"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "In Express.js, what is the correct order of middleware execution in the following code?",
      "code_example": "app.use(middleware1);\napp.get('/path', middleware2, (req, res) => {\n  res.send('Done');\n});\napp.use(middleware3);",
      "options": {
        "A": "middleware1, middleware3, middleware2",
        "B": "middleware1, middleware2, middleware3",
        "C": "middleware2, middleware1, middleware3",
        "D": "middleware3, middleware1, middleware2"
      },
      "correct_answer": "B"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What is required to enforce a unique email field in a Mongoose schema?",
      "code_example": "const UserSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    // What should be added here?\n  }\n});",
      "options": {
        "A": "unique: true",
        "B": "required: true",
        "C": "index: true",
        "D": "validate: /^.+@.+\\..+$/"
      },
      "correct_answer": "A"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function normalFunction() {\n  console.log('Normal called');\n}\n\nfunction debouncedFunction() {\n  console.log('Debounced called');\n}\n\nconst debounced = _.debounce(debouncedFunction, 1000);\n\nnormalFunction();\ndebounced();\ndebounced();\ndebounced();\n\n// After 1.5 seconds",
      "options": {
        "A": "Normal called (immediately), Debounced called (after 1 second)",
        "B": "Normal called (immediately), Debounced called (three times after 1 second)",
        "C": "Normal called (immediately), Debounced called (after 1.5 seconds, only once)",
        "D": "Normal called (immediately), no debounced calls (cancel each other)"
      },
      "correct_answer": "C"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What will be the output of the following function composition?",
      "code_example": "const add5 = x => x + 5;\nconst multiply2 = x => x * 2;\nconst subtract3 = x => x - 3;\n\nconst compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);\nconst operation = compose(subtract3, multiply2, add5);\n\nconsole.log(operation(10));",
      "options": {
        "A": "27",
        "B": "32",
        "C": "30",
        "D": "17"
      },
      "correct_answer": "A"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "In Express.js, what middleware is needed to parse JSON bodies from incoming requests?",
      "options": {
        "A": "app.use(express.json())",
        "B": "app.use(bodyParser.json())",
        "C": "app.use(express.parseJSON())",
        "D": "app.use(express.bodyParser())"
      },
      "correct_answer": "A"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { c: 3, d: 4 };\n\nconst result = { ...obj1, ...obj2, e: [...arr1, ...arr2] };\nconsole.log(result.e[3]);",
      "options": {
        "A": "undefined",
        "B": "1",
        "C": "4",
        "D": "[1, 2, 3, 4, 5, 6]"
      },
      "correct_answer": "C"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "When optimizing DOM performance, which of the following operations is most likely to cause a reflow?",
      "options": {
        "A": "Changing an element's background color with CSS",
        "B": "Reading an element's offsetHeight property",
        "C": "Using document.createDocumentFragment() to build a DOM structure",
        "D": "Adding a new class to an element"
      },
      "correct_answer": "B"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const data = [1, 2, 3, 4, 5];\nlet result = 0;\n\n// Instead of using a loop directly\ndata.reduce((_, item) => {\n  if (item % 2 === 0) {\n    result += item;\n  }\n}, 0);\n\nconsole.log(result);",
      "options": {
        "A": "15",
        "B": "9",
        "C": "6",
        "D": "0"
      },
      "correct_answer": "C"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "In Express.js, what's the best way to implement modular routes for different API endpoints?",
      "options": {
        "A": "Create separate app instances for each route category",
        "B": "Use express.Router() to create modular route handlers",
        "C": "Use if-else statements in a single route handler",
        "D": "Create separate Node.js processes for each endpoint"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What is a key difference between CommonJS modules and ES modules?",
      "code_example": "// CommonJS\nconst fs = require('fs');\nmodule.exports = { readFile };\n\n// ES Modules\nimport fs from 'fs';\nexport { readFile };",
      "options": {
        "A": "CommonJS modules are always faster than ES modules",
        "B": "ES modules are loaded synchronously, CommonJS modules asynchronously",
        "C": "CommonJS uses static imports, ES modules use dynamic imports",
        "D": "ES modules are loaded and parsed before code execution, CommonJS modules load on demand"
      },
      "correct_answer": "D"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What vulnerability does the following code introduce, and how does it relate to Cross-Site Scripting (XSS)?",
      "options": {
        "A": "The vulnerability occurs because innerHTML directly inserts unvalidated content into the DOM",
        "B": "The vulnerability occurs because document.write is used to output user input",
        "C": "No vulnerability exists as the input is coming from a URL parameter",
        "D": "This code is secure because it doesn't use any eval() functions"
      },
      "correct_answer": "A",
      "code_example": "// URL: https://example.com/?name=John\nconst params = new URLSearchParams(window.location.search);\nconst userName = params.get('name');\ndocument.getElementById('greeting').innerHTML = `<h1>Welcome, ${userName}!</h1>`;"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "Which of the following best describes the primary difference between an anti-CSRF token and a JWT token?",
      "options": {
        "A": "Anti-CSRF tokens are always stored in the database while JWTs are only stored client-side",
        "B": "Anti-CSRF tokens are designed to prevent cross-site request forgery attacks by ensuring requests come from the same origin, while JWTs are primarily for authentication and authorization",
        "C": "Anti-CSRF tokens expire after each request while JWTs can persist for multiple sessions",
        "D": "Anti-CSRF tokens are encrypted while JWTs are plain text"
      },
      "correct_answer": "B",
      "code_example": ""
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates WeakMap's behavior compared to a regular Map?",
      "options": {
        "A": "First log: 'object', Second log: 'undefined'",
        "B": "First log: 'object', Second log: 'object'",
        "C": "First log: 'undefined', Second log: 'object'",
        "D": "First log: 'object', Error: Cannot read property 'value' of undefined"
      },
      "correct_answer": "A",
      "code_example": "let regularMap = new Map();\nlet weakMap = new WeakMap();\n\n(function() {\n  let obj = { value: 'test' };\n  \n  regularMap.set(obj, 'stored in regular map');\n  weakMap.set(obj, 'stored in weak map');\n  \n  console.log(typeof regularMap.get(obj));\n})();\n\n// After garbage collection\nsetTimeout(() => {\n  console.log(typeof weakMap.get(Object.keys(weakMap)[0]));\n}, 0);"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "What security concern exists with the following docker-compose.yml file?",
      "options": {
        "A": "Using the latest tag for images is not recommended for production",
        "B": "Environment variables with sensitive data should not be directly in the docker-compose file",
        "C": "The ports binding uses 0.0.0.0 which exposes the service to all network interfaces",
        "D": "The volume mount grants the container unnecessary access to the host file system"
      },
      "correct_answer": "B",
      "code_example": "version: '3'\nservices:\n  api:\n    image: my-node-app:latest\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n      - DB_CONNECTION=mongodb://mongo:27017/myapp\n      - JWT_SECRET=my_super_secret_key_123\n    depends_on:\n      - mongo\n  mongo:\n    image: mongo:4\n    volumes:\n      - mongodata:/data/db\nvolumes:\n  mongodata:"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "What is the output of this code demonstrating parallel processing in Node.js?",
      "options": {
        "A": "A list of numbers from 1 to 4 in random order",
        "B": "Always '1, 2, 3, 4' in sequence",
        "C": "Four 'Task completed' messages in random order",
        "D": "An error because the worker_threads API requires additional configuration"
      },
      "correct_answer": "C",
      "code_example": "const { Worker, isMainThread, parentPort } = require('worker_threads');\n\nif (isMainThread) {\n  for (let i = 1; i <= 4; i++) {\n    const worker = new Worker(__filename, { workerData: i });\n    worker.on('message', (msg) => {\n      console.log(msg);\n    });\n  }\n} else {\n  // Simulate different processing times\n  setTimeout(() => {\n    parentPort.postMessage('Task completed');\n  }, Math.random() * 1000);\n}"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates memory allocation in JavaScript?",
      "options": {
        "A": "The value of 'a' remains 1 throughout",
        "B": "All three values of 'a' will be different",
        "C": "The last two logs will show 'a' as 2",
        "D": "The first and last logs will show 'a' as 1, and the middle log will show 'a' as 2"
      },
      "correct_answer": "D",
      "code_example": "let a = 1;\nlet b = a;\nlet obj1 = { a: 1 };\nlet obj2 = obj1;\n\nconsole.log(a);  // First log\n\nb = 2;\nobj2.a = 2;\n\nconsole.log(a);  // Second log\nconsole.log(obj1.a); // Not relevant to answer\n\nfunction resetValues() {\n  a = 1;\n  obj1 = { a: 1 };\n}\n\nresetValues();\nconsole.log(a);  // Third log"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "Which statement about the use of bcrypt for password hashing in Node.js is correct?",
      "options": {
        "A": "Higher salt rounds provide less security but faster performance",
        "B": "bcrypt.compare() function can verify a password against a stored hash in a single synchronous operation",
        "C": "bcrypt generates a different hash each time, even for the same password and salt rounds, making direct comparison impossible",
        "D": "bcrypt automatically implements salting and prevents rainbow table attacks, making each hash of the same password unique"
      },
      "correct_answer": "D",
      "code_example": "const bcrypt = require('bcrypt');\nconst saltRounds = 10;\nconst password = 'user_password';\n\n// First hash\nbcrypt.hash(password, saltRounds, (err, hash1) => {\n  console.log(hash1);\n  \n  // Second hash of the same password\n  bcrypt.hash(password, saltRounds, (err, hash2) => {\n    console.log(hash2);\n    console.log(hash1 === hash2); // Will log: false\n    \n    // Verify the password against first hash\n    bcrypt.compare(password, hash1, (err, result) => {\n      console.log(result); // Will log: true\n    });\n  });\n});"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "What will be the memory behavior of this code using WeakSet compared to a standard Set?",
      "options": {
        "A": "Both collections will retain all objects indefinitely",
        "B": "WeakSet will allow primitive values but Set won't",
        "C": "Objects in the WeakSet will be eligible for garbage collection when no other references exist",
        "D": "WeakSet will automatically clear itself after the timeout"
      },
      "correct_answer": "C",
      "code_example": "let regularSet = new Set();\nlet weakSet = new WeakSet();\n\n// IIFE to create scope\n(function() {\n  let tempObj = { data: 'test' };\n  regularSet.add(tempObj);\n  weakSet.add(tempObj);\n  \n  console.log(regularSet.size); // Outputs: 1\n  \n  // WeakSet doesn't have a size property\n  console.log(weakSet.has(tempObj)); // Outputs: true\n})();\n\n// After garbage collection\nsetTimeout(() => {\n  console.log(regularSet.size); // Still outputs: 1\n  // No way to check weakSet.size, but the object is eligible for GC\n}, 100);"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What is the output of this Node.js code using streams to read a large file?",
      "options": {
        "A": "It prints all the data at once after reading is complete",
        "B": "It prints 'Reading complete' followed by the entire file content",
        "C": "It prints chunks of data as they are read, followed by 'Reading complete'",
        "D": "It throws an error because .pipe() is required for proper stream handling"
      },
      "correct_answer": "C",
      "code_example": "const fs = require('fs');\n\nconst readStream = fs.createReadStream('./large-file.txt', {\n  highWaterMark: 1024 // Read in 1KB chunks\n});\n\nreadStream.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data`);\n});\n\nreadStream.on('end', () => {\n  console.log('Reading complete');\n});\n\nreadStream.on('error', (error) => {\n  console.error('Error reading file:', error);\n});"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "In a Helm chart for a Node.js application, which of the following is the most secure way to handle sensitive environment variables?",
      "options": {
        "A": "Store them directly in values.yaml with proper documentation",
        "B": "Use Kubernetes Secrets, referenced in the Helm templates, with values stored externally",
        "C": "Pass sensitive values through the --set flag during helm install",
        "D": "Store them as environment variables in the Dockerfile used to build the application image"
      },
      "correct_answer": "B",
      "code_example": ""
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What is the output of the following Node.js clustering code?",
      "options": {
        "A": "It logs 'Worker started' exactly once",
        "B": "It logs 'Worker started' the same number of times as logical CPU cores",
        "C": "It logs 'Master process is running' followed by multiple 'Worker started' messages",
        "D": "It causes an error because the cluster module cannot fork processes"
      },
      "correct_answer": "C",
      "code_example": "const cluster = require('cluster');\nconst os = require('os');\n\nif (cluster.isMaster) {\n  console.log('Master process is running');\n  \n  // Fork workers equal to CPU cores\n  const numCPUs = os.cpus().length;\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  \n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n  });\n} else {\n  console.log('Worker started');\n  // Workers can share the TCP connection\n  // In this example, it's a simple HTTP server\n  require('http')\n    .createServer((req, res) => {\n      res.writeHead(200);\n      res.end('Hello World\\n');\n    })\n    .listen(8000);\n}"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "Which of the following is the most secure configuration for implementing JWT authentication in a Node.js application?",
      "options": {
        "A": "Store the JWT secret in an environment variable and use short-lived tokens with refresh capability",
        "B": "Hardcode the JWT secret in the application for simplicity and use long-lived tokens",
        "C": "Store the JWT secret in a database and update it periodically",
        "D": "Use the same JWT secret for both development and production environments for consistency"
      },
      "correct_answer": "A",
      "code_example": ""
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What will be the output of this code implementing rate limiting with express-rate-limit?",
      "options": {
        "A": "All requests will be processed normally, with rate-limit headers added",
        "B": "The 6th request within the window will be rejected with a 429 status code",
        "C": "The code will throw an error because the configuration is incorrect",
        "D": "The 11th request within the window will be rejected with a 429 status code"
      },
      "correct_answer": "B",
      "code_example": "const express = require('express');\nconst rateLimit = require('express-rate-limit');\n\nconst app = express();\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // limit each IP to 5 requests per windowMs\n  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers\n  legacyHeaders: false, // Disable the `X-RateLimit-*` headers\n  message: 'Too many requests, please try again later.'\n});\n\n// Apply the rate limiting middleware to API calls only\napp.use('/api', apiLimiter);\n\napp.get('/api/data', (req, res) => {\n  res.json({ message: 'This is rate limited API data' });\n});\n\napp.get('/', (req, res) => {\n  res.send('Hello World! This route is not rate limited');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "What is the primary advantage of using WebSockets over REST APIs for real-time communication?",
      "options": {
        "A": "WebSockets are always more secure than REST APIs by default",
        "B": "WebSockets maintain a persistent connection allowing for bidirectional communication with less overhead",
        "C": "WebSockets eliminate the need for authentication and authorization",
        "D": "WebSockets automatically scale better in containerized environments"
      },
      "correct_answer": "B",
      "code_example": ""
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What will be the output of this code when run in Node.js?",
      "options": {
        "A": "The encrypted and decrypted text will match the original",
        "B": "The decryption will fail because the IV is not properly managed",
        "C": "This will throw an error because crypto.createCipher is deprecated",
        "D": "The output will be an empty string due to the invalid key length"
      },
      "correct_answer": "C",
      "code_example": "const crypto = require('crypto');\n\nfunction encryptData(text, password) {\n  const cipher = crypto.createCipher('aes-256-cbc', password);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nfunction decryptData(encrypted, password) {\n  const decipher = crypto.createDecipher('aes-256-cbc', password);\n  let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n}\n\nconst sensitiveData = 'This is confidential information';\nconst password = 'my-secure-password';\n\nconst encrypted = encryptData(sensitiveData, password);\nconsole.log('Encrypted:', encrypted);\n\nconst decrypted = decryptData(encrypted, password);\nconsole.log('Decrypted:', decrypted);"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "Which of the following statements about using Helmet.js for security in Express applications is incorrect?",
      "options": {
        "A": "Helmet.js automatically prevents all XSS attacks without any additional configuration",
        "B": "The Content-Security-Policy header helps prevent injection of malicious scripts",
        "C": "Helmet.js sets the X-XSS-Protection header to enable browser XSS filters",
        "D": "Helmet.js can be configured to set the Strict-Transport-Security header to enforce HTTPS"
      },
      "correct_answer": "A",
      "code_example": "const express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// Apply Helmet's default security headers\napp.use(helmet());\n\n// Custom CSP configuration\napp.use(\n  helmet.contentSecurityPolicy({\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\", 'trusted-cdn.com'],\n      styleSrc: [\"'self'\", 'styles.example.com'],\n      imgSrc: ['*'],\n      connectSrc: [\"'self'\", 'api.example.com']\n    }\n  })\n);\n\napp.get('/', (req, res) => {\n  res.send('Secured with Helmet.js');\n});\n\napp.listen(3000, () => {\n  console.log('Secure server running on port 3000');\n});"
    }
  ]
}
