{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let fruits = ['apple', 'banana', 'cherry'];\nfruits.forEach((fruit, index) => {\n  if (fruit === 'banana') {\n    console.log(index);\n  }\n});",
      "options": {
        "A": "0",
        "B": "1",
        "C": "2",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What does the following code print to the console?",
      "code_example": "function greet(name = 'Guest') {\n  return `Hello, ${name}!`;\n}\n\nconsole.log(greet());",
      "options": {
        "A": "Hello, undefined!",
        "B": "Hello, null!",
        "C": "Hello, Guest!",
        "D": "Error: Missing argument"
      },
      "correct_answer": "C"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be the result of the following code?",
      "code_example": "const numbers = [1, 2, 3];\nconst newArray = [...numbers, 4, 5];\nconsole.log(newArray);",
      "options": {
        "A": "[1, 2, 3, 4, 5]",
        "B": "[[1, 2, 3], 4, 5]",
        "C": "[4, 5, 1, 2, 3]",
        "D": "Error: Spread operator can only be used in function calls"
      },
      "correct_answer": "A"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "const person = { name: 'Alice', age: 30, job: 'Developer' };\nconst { name, ...rest } = person;\nconsole.log(rest);",
      "options": {
        "A": "{ name: 'Alice' }",
        "B": "{ age: 30, job: 'Developer' }",
        "C": "['age', 'job']",
        "D": "{ name: undefined, age: 30, job: 'Developer' }"
      },
      "correct_answer": "B"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "Which of the following best describes Node.js?",
      "options": {
        "A": "A JavaScript framework for building user interfaces",
        "B": "A JavaScript runtime environment that executes code outside a web browser",
        "C": "A database management system for JavaScript applications",
        "D": "A JavaScript library for DOM manipulation"
      },
      "correct_answer": "B"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let score = 85;\n\nif (score >= 90) {\n  console.log('A');\n} else if (score >= 80) {\n  console.log('B');\n} else if (score >= 70) {\n  console.log('C');\n} else {\n  console.log('F');\n}",
      "options": {
        "A": "A",
        "B": "B",
        "C": "C",
        "D": "F"
      },
      "correct_answer": "B"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "In a Node.js application, how would you access an environment variable named 'API_KEY'?",
      "options": {
        "A": "environment.API_KEY",
        "B": "process.env.API_KEY",
        "C": "env.API_KEY",
        "D": "global.API_KEY"
      },
      "correct_answer": "B"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "const age = 17;\nconst message = age >= 18 ? 'Adult' : 'Minor';\nconsole.log(message);",
      "options": {
        "A": "Adult",
        "B": "Minor",
        "C": "true",
        "D": "false"
      },
      "correct_answer": "B"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "Which of the following methods will select an element with the ID 'user-profile' from the DOM?",
      "options": {
        "A": "document.findElement('#user-profile')",
        "B": "document.querySelector('#user-profile')",
        "C": "document.getElementsByName('user-profile')",
        "D": "document.select('#user-profile')"
      },
      "correct_answer": "B"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What is the difference between a function declaration and a function expression?",
      "options": {
        "A": "Function declarations are not hoisted, but function expressions are",
        "B": "Function declarations can't be anonymous, while function expressions can",
        "C": "Function declarations must include parameters, while function expressions don't need parameters",
        "D": "Function declarations can only be defined at the top level of a script"
      },
      "correct_answer": "B"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "async function fetchData() {\n  return 'Data fetched';\n}\n\nasync function getData() {\n  const result = await fetchData();\n  console.log(result);\n}\n\ngetData();",
      "options": {
        "A": "undefined",
        "B": "Promise { 'Data fetched' }",
        "C": "Data fetched",
        "D": "Error: await can only be used in async functions"
      },
      "correct_answer": "C"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "for (let i = 0; i < 5; i++) {\n  if (i === 2) {\n    continue;\n  }\n  console.log(i);\n  if (i === 3) {\n    break;\n  }\n}",
      "options": {
        "A": "0 1 3",
        "B": "0 1 2 3",
        "C": "0 1 3 4",
        "D": "0 1 2 3 4"
      },
      "correct_answer": "A"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "function sum() {\n  let total = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}\n\nconsole.log(sum(1, 2, 3));",
      "options": {
        "A": "Error: arguments is not defined",
        "B": "6",
        "C": "[1, 2, 3]",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "Which of the following is NOT a primitive type in JavaScript?",
      "options": {
        "A": "string",
        "B": "number",
        "C": "array",
        "D": "symbol"
      },
      "correct_answer": "C"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "Which method is used to stop an event from propagating up or down the DOM tree?",
      "options": {
        "A": "event.preventDefault()",
        "B": "event.stopPropagation()",
        "C": "event.stopBubbling()",
        "D": "event.cancelEvent()"
      },
      "correct_answer": "B"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What is the difference between using textContent and innerHTML to change the content of an element?",
      "options": {
        "A": "textContent can only set plain text, while innerHTML can set HTML content",
        "B": "innerHTML is faster than textContent in all browsers",
        "C": "textContent works with all DOM elements, but innerHTML only works with div elements",
        "D": "There is no difference; they are aliases of the same method"
      },
      "correct_answer": "A"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What will the following code output?",
      "code_example": "function Shape() {\n  this.name = 'Shape';\n}\n\nShape.prototype.getName = function() {\n  return this.name;\n};\n\nfunction Circle() {\n  this.name = 'Circle';\n}\n\nCircle.prototype = Object.create(Shape.prototype);\n\nconst circle = new Circle();\nconsole.log(circle.getName());",
      "options": {
        "A": "Shape",
        "B": "Circle",
        "C": "undefined",
        "D": "Error: getName is not a function"
      },
      "correct_answer": "B"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "Which of the following is a correct implementation of the Event Emitter pattern in Node.js?",
      "code_example": "const EventEmitter = require('events');\n\nclass Logger extends EventEmitter {\n  log(message) {\n    console.log(message);\n    this.emit('logged', { message });\n  }\n}\n\nconst logger = new Logger();\nlogger.on('logged', (data) => {\n  console.log('Listener called:', data);\n});\n\nlogger.log('Hello World');",
      "options": {
        "A": "The code is incorrect because EventEmitter cannot be extended",
        "B": "The code is incorrect because 'on' method is not part of EventEmitter",
        "C": "The code is correct and demonstrates the Event Emitter pattern",
        "D": "The code is incorrect because 'emit' should be called before logging"
      },
      "correct_answer": "C"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "Which of the following Node.js code snippets properly prevents SQL injection?",
      "code_example": "// Option A\nconst query = `SELECT * FROM users WHERE username = '${username}'`;\ndb.query(query);\n\n// Option B\nconst query = 'SELECT * FROM users WHERE username = ?';\ndb.query(query, [username]);\n\n// Option C\nconst query = `SELECT * FROM users WHERE username = \"${escape(username)}\"`;\ndb.query(query);\n\n// Option D\nconst query = 'SELECT * FROM users WHERE username = ' + JSON.stringify(username);\ndb.query(query);",
      "options": {
        "A": "Option A",
        "B": "Option B",
        "C": "Option C",
        "D": "Option D"
      },
      "correct_answer": "B"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "When implementing API response caching in Node.js, which of the following approaches is most efficient for frequently accessed data?",
      "options": {
        "A": "Store responses in a global JavaScript object within the application",
        "B": "Use Redis as an in-memory data store with expiration policies",
        "C": "Save responses to the file system with unique filenames",
        "D": "Cache responses in browser localStorage via response headers"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What is the correct way to validate that a request body contains a valid email using express-validator?",
      "code_example": "const { body, validationResult } = require('express-validator');\n\napp.post('/register',\n  body('email').isEmail().normalizeEmail(),\n  (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n    // Process valid data\n    res.status(201).json({ message: 'User registered' });\n  }\n);",
      "options": {
        "A": "The code should use validator.isEmail() instead of body('email').isEmail()",
        "B": "The code should call validate() before accessing validationResult",
        "C": "The code correctly implements email validation using express-validator",
        "D": "The code should return res.send(errors) instead of res.status(400).json()"
      },
      "correct_answer": "C"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What will the following Express.js middleware code do?",
      "code_example": "app.use(express.json());\napp.use(express.urlencoded({ extended: true }));",
      "options": {
        "A": "Parse JSON requests and form data with nested objects",
        "B": "Convert all incoming requests to JSON format",
        "C": "Enable file uploads with multipart/form-data",
        "D": "Compress response bodies for all request types"
      },
      "correct_answer": "A"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const person = {\n  name: 'Alice',\n  greet: function() {\n    console.log(`Hello, my name is ${this.name}`);\n  },\n  greetArrow: () => {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n};\n\nperson.greetArrow();",
      "options": {
        "A": "Hello, my name is Alice",
        "B": "Hello, my name is undefined",
        "C": "Hello, my name is null",
        "D": "Error: this.name is not accessible"
      },
      "correct_answer": "B"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What will the following code output?",
      "code_example": "const value = null;\nconst result = value ?? 'Default';\nconsole.log(result);",
      "options": {
        "A": "null",
        "B": "'Default'",
        "C": "undefined",
        "D": "Error: Unexpected token ??"
      },
      "correct_answer": "B"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "Which of the following approaches is best for implementing API versioning in an Express.js application?",
      "options": {
        "A": "Using different port numbers for each API version",
        "B": "Using URL path segments (e.g., /api/v1/resource, /api/v2/resource)",
        "C": "Using different subdomains for each version",
        "D": "Using separate code repositories for each API version"
      },
      "correct_answer": "B"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What is the correct way to set up modular routes using Express Router?",
      "code_example": "// users.js\nconst express = require('express');\nconst router = express.Router();\n\nrouter.get('/', (req, res) => {\n  res.send('Get all users');\n});\n\nrouter.get('/:id', (req, res) => {\n  res.send(`Get user ${req.params.id}`);\n});\n\nmodule.exports = router;\n\n// app.js\nconst express = require('express');\nconst usersRouter = require('./users');\n\nconst app = express();\napp.use('/api/users', usersRouter);",
      "options": {
        "A": "The code is correct: app.use mounts the router on the specified path",
        "B": "router.use should be used instead of app.use",
        "C": "module.exports = router is incorrect; it should export an object",
        "D": "The router paths should include the full path (e.g., /api/users/)"
      },
      "correct_answer": "A"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function outer() {\n  let count = 0;\n  function inner() {\n    count++;\n    return count;\n  }\n  return inner;\n}\n\nconst counter1 = outer();\nconst counter2 = outer();\n\nconsole.log(counter1());\nconsole.log(counter1());\nconsole.log(counter2());",
      "options": {
        "A": "1, 2, 3",
        "B": "1, 2, 1",
        "C": "1, 1, 1",
        "D": "NaN, NaN, NaN"
      },
      "correct_answer": "B"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "Which of the following is a pure function?",
      "code_example": "// Function A\nfunction add(a, b) {\n  return a + b;\n}\n\n// Function B\nlet total = 0;\nfunction addToTotal(value) {\n  total += value;\n  return total;\n}\n\n// Function C\nfunction randomNumber() {\n  return Math.random();\n}\n\n// Function D\nfunction formatName(user) {\n  user.fullName = user.firstName + ' ' + user.lastName;\n  return user;\n}",
      "options": {
        "A": "Function A",
        "B": "Function B",
        "C": "Function C",
        "D": "Function D"
      },
      "correct_answer": "A"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What is the purpose of the following Express.js middleware?",
      "code_example": "const rateLimit = require('express-rate-limit');\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: 'Too many requests, please try again later'\n});\n\napp.use('/api/', apiLimiter);",
      "options": {
        "A": "To compress API responses to improve performance",
        "B": "To limit the number of requests an IP can make within a time window",
        "C": "To validate API request parameters",
        "D": "To cache API responses to reduce database load"
      },
      "correct_answer": "B"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What will the following code output?",
      "code_example": "const data = {\n  user: {\n    profile: {\n      name: 'John',\n      address: {\n        city: 'New York',\n        zip: '10001'\n      }\n    }\n  }\n};\n\nconst { user: { profile: { address: { city, zip } } } } = data;\nconsole.log(city, zip);",
      "options": {
        "A": "undefined undefined",
        "B": "{ city: 'New York' } { zip: '10001' }",
        "C": "New York 10001",
        "D": "Error: Cannot destructure property"
      },
      "correct_answer": "C"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What best describes a closure in JavaScript?",
      "options": {
        "A": "A way to secure variables from being accessed from outside the function",
        "B": "A function that has access to variables from its outer (enclosing) lexical scope, even after the outer function has returned",
        "C": "A design pattern for organizing code into reusable modules",
        "D": "A special syntax for anonymous functions that preserves the this context"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What is the difference between CommonJS and ES Modules?",
      "code_example": "// CommonJS\nconst fs = require('fs');\nmodule.exports = { readFile: fs.readFile };\n\n// ES Modules\nimport fs from 'fs';\nexport const readFile = fs.readFile;",
      "options": {
        "A": "CommonJS is synchronous, ES Modules support asynchronous loading",
        "B": "CommonJS is only for Node.js, ES Modules only work in browsers",
        "C": "CommonJS allows circular dependencies, ES Modules do not",
        "D": "CommonJS uses dynamic imports, ES Modules use static imports"
      },
      "correct_answer": "A"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates aspects of Just-In-Time (JIT) compilation optimization?",
      "code_example": "function test() {\n  let sum = 0;\n  \n  // First loop with mixed types\n  for (let i = 0; i < 5; i++) {\n    if (i === 3) {\n      sum += '3'; // String concatenation here\n    } else {\n      sum += i;\n    }\n  }\n  \n  // Second loop with consistent types\n  let result = 0;\n  for (let i = 0; i < 1000000; i++) {\n    result += 1;\n  }\n  \n  return sum;\n}\n\nconsole.log(test());",
      "options": {
        "A": "10",
        "B": "0123",
        "C": "6",
        "D": "03"
      },
      "correct_answer": "D"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "Which of the following statements about refresh tokens and access tokens is FALSE?",
      "options": {
        "A": "Access tokens typically have a shorter lifespan than refresh tokens",
        "B": "Refresh tokens should be stored in HTTP-only cookies for better security",
        "C": "Access tokens should be included in local storage for optimal security",
        "D": "Refresh tokens are used to obtain new access tokens without re-authentication"
      },
      "correct_answer": "C"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What will be the result of running the following code using Node.js crypto module?",
      "code_example": "const crypto = require('crypto');\n\nfunction encryptData(data, password) {\n  // Create a 16-byte initialization vector\n  const iv = crypto.randomBytes(16);\n  \n  // Create a cipher using AES-256-CBC algorithm\n  const cipher = crypto.createCipheriv(\n    'aes-256-cbc', \n    crypto.scryptSync(password, 'salt', 32), \n    iv\n  );\n  \n  // Encrypt the data\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  \n  return {\n    iv: iv.toString('hex'),\n    encryptedData: encrypted\n  };\n}\n\nfunction decryptData(encryptedObj, password) {\n  const decipher = crypto.createDecipheriv(\n    'aes-256-cbc',\n    crypto.scryptSync(password, 'salt', 32),\n    Buffer.from(encryptedObj.iv, 'hex')\n  );\n  \n  let decrypted = decipher.update(encryptedObj.encryptedData, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  \n  return decrypted;\n}\n\nconst data = 'Secret message';\nconst password = 'my-secure-password';\n\nconst encrypted = encryptData(data, password);\nconst decrypted = decryptData(encrypted, password);\n\nconsole.log(decrypted === data);",
      "options": {
        "A": "false",
        "B": "true",
        "C": "Error: Invalid key length",
        "D": "Error: Unsupported cipher mode"
      },
      "correct_answer": "B"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "What is the correct way to handle unhandled Promise rejections in Node.js to prevent the process from terminating?",
      "code_example": "// Approach 1\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n});\n\n// Approach 2\nwindow.addEventListener('unhandledrejection', (event) => {\n  console.error('Unhandled Rejection at:', event.promise, 'reason:', event.reason);\n});\n\n// Approach 3\nprocess.on('uncaughtException', (err) => {\n  console.error('Uncaught Exception:', err);\n});\n\n// Approach 4\ntry {\n  Promise.reject(new Error('Test'));\n} catch (err) {\n  console.error('Caught rejection:', err);\n}",
      "options": {
        "A": "Approach 1",
        "B": "Approach 2",
        "C": "Approach 3",
        "D": "Approach 4"
      },
      "correct_answer": "A"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "When using Node.js clustering, which of the following statements is TRUE?",
      "options": {
        "A": "Child processes created with cluster.fork() share the same port, allowing for load balancing",
        "B": "The master process handles all incoming connections and distributes them to worker processes",
        "C": "cluster.fork() creates multiple threads within the same process",
        "D": "Worker processes can directly communicate with each other without going through the master process"
      },
      "correct_answer": "A"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "Which of the following is NOT a typical use case for Helm in a JavaScript application deployment?",
      "options": {
        "A": "Managing complex Kubernetes deployments with templated YAML files",
        "B": "Versioning and rolling back application deployments",
        "C": "Optimizing JavaScript code execution at runtime",
        "D": "Sharing application configurations across different environments"
      },
      "correct_answer": "C"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "What will be the output of this code that demonstrates a common memory leak pattern in JavaScript?",
      "code_example": "let theLeak = [];\n\nfunction createLargeObject() {\n  return new Array(1000000).fill('potentially leaky data');\n}\n\nfunction processData() {\n  // Create some objects\n  const largeData = createLargeObject();\n  \n  // Store a reference\n  theLeak.push({ \n    data: largeData,\n    timestamp: Date.now() \n  });\n  \n  // Process and return result\n  return 'Processed data successfully';\n}\n\n// Call the function multiple times\nfor (let i = 0; i < 3; i++) {\n  processData();\n}\n\n// What's the approximate memory usage pattern?\nconsole.log(theLeak.length);",
      "options": {
        "A": "0 - The garbage collector will clear theLeak immediately",
        "B": "1 - Only the last processed object remains in memory",
        "C": "3 - Each large object remains in memory due to persistent references",
        "D": "Undefined - The code will crash with an out-of-memory error"
      },
      "correct_answer": "C"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "Which of the following is INCORRECT about multi-stage builds in a Dockerfile for a Node.js application?",
      "options": {
        "A": "They help reduce the final image size by discarding build dependencies",
        "B": "They allow the use of different base images for building and running the application",
        "C": "They automatically optimize the JavaScript code execution through JIT compilation",
        "D": "They can improve security by reducing the attack surface of the final image"
      },
      "correct_answer": "C"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What is the output of the following code that demonstrates Transform streams in Node.js?",
      "code_example": "const { Transform } = require('stream');\nconst { createReadStream, createWriteStream } = require('fs');\n\nclass CounterTransform extends Transform {\n  constructor(options) {\n    super(options);\n    this.count = 0;\n  }\n  \n  _transform(chunk, encoding, callback) {\n    // Count the number of uppercase 'A's in the chunk\n    const str = chunk.toString();\n    for (let i = 0; i < str.length; i++) {\n      if (str[i] === 'A') {\n        this.count++;\n      }\n    }\n    \n    // Pass the chunk through unchanged\n    this.push(chunk);\n    callback();\n  }\n  \n  _flush(callback) {\n    // Add the count to the end of the stream\n    this.push(`\\nFound ${this.count} letter A's\\n`);\n    callback();\n  }\n}\n\n// Sample string for testing\nconst testString = 'ABCABC AABB CCDD';\n\n// Create transform stream instance\nconst counter = new CounterTransform();\n\n// Simulate processing the string through the transform stream\nlet result = '';\ncounter.on('data', chunk => {\n  result += chunk.toString();\n});\n\ncounter.write(testString);\ncounter.end();\n\n// Wait for the stream to finish and then log result\ncounter.on('end', () => {\n  console.log(result);\n});",
      "options": {
        "A": "ABCABC AABB CCDD",
        "B": "Found 6 letter A's",
        "C": "ABCABC AABB CCDD\nFound 6 letter A's\n",
        "D": "ABCABC AABB CCDD\nFound 4 letter A's\n"
      },
      "correct_answer": "C"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "Which statement about horizontal vs. vertical scaling in Node.js applications is FALSE?",
      "options": {
        "A": "Horizontal scaling involves adding more machines to your pool of resources",
        "B": "Vertical scaling provides better fault tolerance than horizontal scaling",
        "C": "Horizontal scaling can be implemented using Node.js cluster module",
        "D": "Vertical scaling involves adding more power (CPU, RAM) to existing machines"
      },
      "correct_answer": "B"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates hidden classes and inline caching in V8?",
      "code_example": "function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\n// Create points consistently\nconst consistentPoints = [];\nfor (let i = 0; i < 100000; i++) {\n  consistentPoints.push(new Point(i, i * 2));\n}\n\n// Time a consistent property access\nlet start = performance.now();\nlet sum1 = 0;\nfor (let i = 0; i < consistentPoints.length; i++) {\n  sum1 += consistentPoints[i].x;\n}\nlet consistent = performance.now() - start;\n\n// Create inconsistent points\nconst inconsistentPoints = [];\nfor (let i = 0; i < 100000; i++) {\n  let point = new Point(i, i * 2);\n  // Add properties in different order\n  if (i % 2 === 0) {\n    point.z = i * 3;\n    point.w = i * 4;\n  } else {\n    point.w = i * 4;\n    point.z = i * 3;\n  }\n  inconsistentPoints.push(point);\n}\n\n// Time an inconsistent property access\nstart = performance.now();\nlet sum2 = 0;\nfor (let i = 0; i < inconsistentPoints.length; i++) {\n  sum2 += inconsistentPoints[i].x;\n}\nlet inconsistent = performance.now() - start;\n\n// Compare which was faster (lower time is better)\nconsole.log(consistent < inconsistent ? \"Consistent is faster\" : \"Inconsistent is faster\");",
      "options": {
        "A": "Consistent is faster",
        "B": "Inconsistent is faster",
        "C": "They perform the same",
        "D": "Error: performance is not defined"
      },
      "correct_answer": "A"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "Which of the following is NOT a valid configuration option in a docker-compose.yml file for a Node.js application?",
      "options": {
        "A": "depends_on: Specifies service dependencies",
        "B": "volumes: Mounts host paths or named volumes",
        "C": "jit_options: Controls JavaScript JIT compilation settings",
        "D": "environment: Sets environment variables for the container"
      },
      "correct_answer": "C"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What will be the output of the following code using WeakMap for memory-sensitive caching?",
      "code_example": "// Create a cache using WeakMap\nconst cache = new WeakMap();\n\n// Create a key object\nlet user = { id: 1, name: 'John' };\n\n// Store expensive calculation result in cache\nfunction getExpensiveData(user) {\n  if (cache.has(user)) {\n    console.log('Cache hit');\n    return cache.get(user);\n  }\n  \n  console.log('Cache miss');\n  // Simulate expensive operation\n  const data = { result: 'Expensive calculation for ' + user.name };\n  cache.set(user, data);\n  return data;\n}\n\n// First call - should be a cache miss\ngetExpensiveData(user);\n\n// Second call - should be a cache hit\ngetExpensiveData(user);\n\n// Reassign user variable to a new object\nuser = { id: 1, name: 'John' };\n\n// Third call - what happens now?\ngetExpensiveData(user);\n\n// Output the last two console.log results\n",
      "options": {
        "A": "Cache hit\nCache hit",
        "B": "Cache hit\nCache miss",
        "C": "Cache miss\nCache miss",
        "D": "Cache miss\nCache hit"
      },
      "correct_answer": "B"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "Which of the following is NOT a typical component of a CI/CD pipeline for a Node.js application?",
      "options": {
        "A": "Automated unit and integration testing",
        "B": "Automatic runtime memory optimization",
        "C": "Static code analysis and linting",
        "D": "Container image building and versioning"
      },
      "correct_answer": "B"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What will be the output of this code demonstrating a Cross-Site Scripting (XSS) vulnerability?",
      "code_example": "// User input from a form\nconst userInput = \"<img src='x' onerror='alert(\"XSS\")'>\";\n\n// Different ways to handle the input\n\n// Method 1: Direct insertion\nfunction method1(input) {\n  const element = document.createElement('div');\n  element.innerHTML = input;\n  return element.textContent || element.innerText;\n}\n\n// Method 2: Using innerHTML\nfunction method2(input) {\n  const element = document.createElement('div');\n  element.innerHTML = input;\n  return element;\n}\n\n// Method 3: Using textContent\nfunction method3(input) {\n  const element = document.createElement('div');\n  element.textContent = input;\n  return element;\n}\n\n// Method 4: Using a simple escaping function\nfunction method4(input) {\n  const escaped = input\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;');\n  \n  const element = document.createElement('div');\n  element.innerHTML = escaped;\n  return element;\n}\n\n// Which method properly prevents XSS?\nconsole.log('Safe method number:',\n  [method1, method2, method3, method4].findIndex(method => {\n    const result = method(userInput);\n    // Check if the method prevents script execution\n    return result && \n           !result.querySelector('img') && \n           result.textContent.includes('<img');\n  }) + 1\n);",
      "options": {
        "A": "Safe method number: 1",
        "B": "Safe method number: 2",
        "C": "Safe method number: 3",
        "D": "Safe method number: 4"
      },
      "correct_answer": "C"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "What will be the output of this code demonstrating Nginx as a reverse proxy configuration with Node.js?",
      "code_example": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  // Log headers received from Nginx\n  console.log('Headers:', JSON.stringify(req.headers));\n  \n  // Check for specific Nginx headers\n  const hasXRealIP = 'x-real-ip' in req.headers;\n  const hasXForwardedFor = 'x-forwarded-for' in req.headers;\n  const hasXForwardedProto = 'x-forwarded-proto' in req.headers;\n  \n  // Response based on headers presence\n  if (hasXRealIP && hasXForwardedFor && hasXForwardedProto) {\n    res.end('Full Nginx proxy configuration detected');\n  } else if (hasXRealIP || hasXForwardedFor) {\n    res.end('Partial Nginx proxy configuration detected');\n  } else {\n    res.end('No Nginx proxy detected');\n  }\n});\n\n// Simulate an incoming request with headers\n// as if it came through an Nginx reverse proxy\nconst simulateRequest = () => {\n  const headers = {\n    'host': 'example.com',\n    'x-real-ip': '203.0.113.7',\n    'x-forwarded-for': '203.0.113.7, 10.1.1.1',\n    'accept': 'text/html'\n    // Note: x-forwarded-proto is missing\n  };\n  \n  // Create a mock request object\n  const req = new http.IncomingMessage();\n  req.headers = headers;\n  \n  // Create a mock response object\n  const res = {\n    end: (content) => {\n      console.log(content);\n    }\n  };\n  \n  // Pass to the server handler\n  server.emit('request', req, res);\n};\n\nsimulateRequest();",
      "options": {
        "A": "Full Nginx proxy configuration detected",
        "B": "Partial Nginx proxy configuration detected",
        "C": "No Nginx proxy detected",
        "D": "Error: Cannot create IncomingMessage directly"
      },
      "correct_answer": "B"
    }
  ]
}
