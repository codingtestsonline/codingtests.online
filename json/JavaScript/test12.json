{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const add = function(a, b) {\n  return a + b;\n};\nconst subtract = (a, b) => {\n  return a - b;\n};\nconsole.log(typeof add, typeof subtract);",
      "options": {
        "A": "'function' 'function'",
        "B": "'object' 'function'",
        "C": "'function' 'object'",
        "D": "'object' 'object'"
      },
      "correct_answer": "A"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What is the difference between document.getElementById() and document.querySelector()?",
      "options": {
        "A": "querySelector can only select elements by class name",
        "B": "getElementById is faster but querySelector can use any CSS selector",
        "C": "getElementById returns a NodeList while querySelector returns a single element",
        "D": "querySelector is deprecated in modern browsers"
      },
      "correct_answer": "B"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log('5' == 5);\nconsole.log('5' === 5);",
      "options": {
        "A": "false false",
        "B": "true true",
        "C": "true false",
        "D": "false true"
      },
      "correct_answer": "C"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled);",
      "options": {
        "A": "[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]",
        "B": "[2, 4, 6, 8, 10]",
        "C": "[1, 4, 9, 16, 25]",
        "D": "TypeError: numbers.map is not a function"
      },
      "correct_answer": "B"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = [...arr1, ...arr2];\nconsole.log(combined);",
      "options": {
        "A": "[1, 2, 3, 4, 5, 6]",
        "B": "[[1, 2, 3], [4, 5, 6]]",
        "C": "[1, 2, 3, [4, 5, 6]]",
        "D": "TypeError: Spread operator cannot be used with arrays"
      },
      "correct_answer": "A"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const fruits = ['apple', 'banana', 'cherry'];\nfruits.push('date');\nfruits.shift();\nconsole.log(fruits);",
      "options": {
        "A": "['apple', 'banana', 'cherry', 'date']",
        "B": "['banana', 'cherry', 'date']",
        "C": "['date', 'apple', 'banana', 'cherry']",
        "D": "['apple', 'banana', 'cherry']"
      },
      "correct_answer": "B"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function doSomething(callback) {\n  callback('Hello from callback');\n}\n\ndoSomething(function(message) {\n  console.log(message);\n});",
      "options": {
        "A": "undefined",
        "B": "Hello from callback",
        "C": "TypeError: callback is not a function",
        "D": "function(message) { console.log(message); }"
      },
      "correct_answer": "B"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const regularFunction = function() {\n  console.log(this);\n};\n\nconst arrowFunction = () => {\n  console.log(this);\n};\n\nconsole.log(typeof regularFunction === typeof arrowFunction);",
      "options": {
        "A": "false",
        "B": "true",
        "C": "TypeError",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let x = 10;\n\nfunction test() {\n  let x = 20;\n  if (true) {\n    let x = 30;\n    console.log('A:', x);\n  }\n  console.log('B:', x);\n}\n\ntest();\nconsole.log('C:', x);",
      "options": {
        "A": "A: 30 B: 30 C: 10",
        "B": "A: 30 B: 20 C: 10",
        "C": "A: 30 B: 20 C: 20",
        "D": "A: 10 B: 20 C: 30"
      },
      "correct_answer": "B"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What is the correct way to add a click event listener to an element with the ID 'myButton'?",
      "options": {
        "A": "document.getElementById('myButton').addEventListener('click', function() {});",
        "B": "document.getElementById('myButton').click(function() {});",
        "C": "document.getElementById('myButton').event('click', function() {});",
        "D": "document.getElementById('myButton').listen('click', function() {});"
      },
      "correct_answer": "A"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const person1 = {};\nperson1.name = 'John';\n\nconst person2 = new Object();\nperson2.name = 'Jane';\n\nconsole.log(person1.name + ' and ' + person2.name);",
      "options": {
        "A": "undefined and undefined",
        "B": "[object Object] and [object Object]",
        "C": "John and Jane",
        "D": "TypeError: Cannot set property 'name' of {}"
      },
      "correct_answer": "C"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const div = document.createElement('div');\ndiv.innerHTML = '<span>Hello</span>';\ndiv.textContent = 'World';\nconsole.log(div.innerHTML);",
      "options": {
        "A": "<span>Hello</span>",
        "B": "World",
        "C": "<span>World</span>",
        "D": "HelloWorld"
      },
      "correct_answer": "B"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "Which of the following best describes Node.js?",
      "options": {
        "A": "A JavaScript framework for building user interfaces",
        "B": "A runtime environment that executes JavaScript outside of a browser",
        "C": "A programming language that compiles to JavaScript",
        "D": "A database management system for storing JavaScript objects"
      },
      "correct_answer": "B"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const color = 'blue';\n\nswitch (color) {\n  case 'red':\n    console.log('Stop');\n    break;\n  case 'yellow':\n    console.log('Caution');\n    break;\n  case 'green':\n    console.log('Go');\n    break;\n  default:\n    console.log('Invalid color');\n}",
      "options": {
        "A": "Stop",
        "B": "Caution",
        "C": "Go",
        "D": "Invalid color"
      },
      "correct_answer": "D"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const car = {\n  make: 'Toyota',\n  model: 'Corolla',\n  year: 2022,\n  getDescription: function() {\n    return `${this.year} ${this.make} ${this.model}`;\n  }\n};\n\nconsole.log(car.getDescription());",
      "options": {
        "A": "function() { return `${this.year} ${this.make} ${this.model}`; }",
        "B": "undefined undefined undefined",
        "C": "2022 Toyota Corolla",
        "D": "[object Object]"
      },
      "correct_answer": "C"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const name = 'John';\nconst greeting = `Hello, ${name}!`;\nconsole.log(greeting);",
      "options": {
        "A": "Hello, ${name}!",
        "B": "Hello, John!",
        "C": "Hello, \"John\"!",
        "D": "TypeError: Template literals are not supported"
      },
      "correct_answer": "B"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "Which of the following correctly creates a simple Express server that listens on port 3000?",
      "code_example": "// Option A\nconst express = require('express');\nconst app = express();\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\n\n// Option B\nconst http = require('http');\nconst server = http.createServer();\nserver.listen(3000);\n\n// Option C\nconst express = require('express');\nexpress.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\n\n// Option D\nconst express = require('express');\nconst app = express;\napp.listen(3000);",
      "options": {
        "A": "Option A",
        "B": "Option B",
        "C": "Option C",
        "D": "Option D"
      },
      "correct_answer": "A"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "Which MongoDB operation would you use to find a single document by its ID and update it?",
      "options": {
        "A": "Model.update({ _id: id }, updatedData)",
        "B": "Model.findAndModify({ _id: id }, updatedData)",
        "C": "Model.findByIdAndUpdate(id, updatedData)",
        "D": "Model.findOne({ _id: id }).save(updatedData)"
      },
      "correct_answer": "C"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "Which HTTP method is most appropriate for updating an existing resource?",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "correct_answer": "C"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const fs = require('fs');\n\ntry {\n  const data = fs.readFileSync('nonexistent.txt', 'utf8');\n  console.log(data);\n} catch (error) {\n  console.log('Error type:', error.code);\n}",
      "options": {
        "A": "null",
        "B": "Error type: ENOENT",
        "C": "undefined",
        "D": "Error type: 404"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What is the purpose of the following MongoDB schema configuration?",
      "code_example": "const UserSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: [true, 'Email is required'],\n    unique: true,\n    match: [/.+\\@.+\\..+/, 'Please fill a valid email address']\n  },\n  password: {\n    type: String,\n    required: true,\n    minlength: 8\n  }\n});",
      "options": {
        "A": "It only ensures data types are correct",
        "B": "It validates inputs before saving to database",
        "C": "It encrypts sensitive user information",
        "D": "It generates automatic documentation for the API"
      },
      "correct_answer": "B"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/user', (req, res) => {\n  console.log(typeof req.body);\n  res.send('OK');\n});\n\n// What will be logged when a POST request with JSON payload is received?",
      "options": {
        "A": "string",
        "B": "object",
        "C": "array",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const express = require('express');\nconst app = express();\n\napp.use((err, req, res, next) => {\n  console.log('Error middleware activated');\n  res.status(500).send('Something broke!');\n});\n\napp.get('/test', (req, res) => {\n  throw new Error('Test error');\n});\n\n// What happens when /test endpoint is accessed?",
      "options": {
        "A": "'Error middleware activated' is logged and error response is sent",
        "B": "Application crashes with uncaught error",
        "C": "Default Express error handler responds with stack trace",
        "D": "Request timeouts after 30 seconds"
      },
      "correct_answer": "C"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "async function getData() {\n  try {\n    const response = await Promise.reject('Data error');\n    return 'Success';\n  } catch (error) {\n    return 'Failed: ' + error;\n  } finally {\n    return 'Completed';\n  }\n}\n\ngetData().then(result => console.log(result));",
      "options": {
        "A": "Success",
        "B": "Failed: Data error",
        "C": "Completed",
        "D": "UnhandledPromiseRejection"
      },
      "correct_answer": "C"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  console.log('First middleware');\n  next();\n});\n\napp.use((req, res, next) => {\n  console.log('Second middleware');\n  // No next() call here\n});\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});\n\n// What happens when the root endpoint is accessed?",
      "options": {
        "A": "First middleware, Second middleware, then 'Hello World' response",
        "B": "First middleware, then 'Hello World' response (skipping the second middleware)",
        "C": "First middleware, Second middleware, then the request hangs",
        "D": "Internal Server Error due to middleware chain being broken"
      },
      "correct_answer": "C"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "Which of the following is the most secure way to prevent NoSQL injection when querying MongoDB?",
      "options": {
        "A": "Using string concatenation to build queries",
        "B": "Using MongoDB's $where operator with user input",
        "C": "Using sanitize-html module on user inputs that go into queries",
        "D": "Using MongoDB's query operators ({$eq, $gt, etc.}) with validated inputs"
      },
      "correct_answer": "D"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const value1 = null;\nconst value2 = undefined;\nconst value3 = 'Hello';\n\nconst result1 = value1 ?? 'Default1';\nconst result2 = value2 ?? 'Default2';\nconst result3 = value3 ?? 'Default3';\n\nconsole.log(result1, result2, result3);",
      "options": {
        "A": "null undefined Hello",
        "B": "Default1 Default2 Default3",
        "C": "Default1 Default2 Hello",
        "D": "null Default2 Hello"
      },
      "correct_answer": "C"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const parent = {\n  name: 'Parent',\n  greet() {\n    return `Hello from ${this.name}`;\n  }\n};\n\nconst child = Object.create(parent);\nchild.name = 'Child';\n\nconsole.log(child.greet());",
      "options": {
        "A": "Hello from Parent",
        "B": "Hello from Child",
        "C": "Hello from undefined",
        "D": "TypeError: child.greet is not a function"
      },
      "correct_answer": "B"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "Which code correctly configures Multer for handling file uploads in Express?",
      "code_example": "// Option A\nconst multer = require('multer');\nconst upload = multer({ dest: 'uploads/' });\napp.post('/upload', upload.single('avatar'), (req, res) => {\n  console.log(req.file);\n  res.send('Uploaded');\n});\n\n// Option B\nconst multer = require('multer');\napp.use(multer());\napp.post('/upload', (req, res) => {\n  console.log(req.files.avatar);\n  res.send('Uploaded');\n});\n\n// Option C\nconst multer = require('multer');\napp.post('/upload', (req, res) => {\n  multer.upload(req.files.avatar, 'uploads/');\n  res.send('Uploaded');\n});\n\n// Option D\nconst multer = require('multer');\napp.post('/upload', multer({ dest: 'uploads/' }), (req, res) => {\n  console.log(req.body.avatar);\n  res.send('Uploaded');\n});",
      "options": {
        "A": "Option A",
        "B": "Option B",
        "C": "Option C",
        "D": "Option D"
      },
      "correct_answer": "A"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const person = {\n  name: {\n    first: 'John',\n    last: 'Doe'\n  },\n  hobbies: ['reading', 'swimming', 'coding']\n};\n\nconst { name: { first }, hobbies: [, secondHobby] } = person;\n\nconsole.log(first, secondHobby);",
      "options": {
        "A": "undefined undefined",
        "B": "{first: 'John', last: 'Doe'} ['reading', 'swimming', 'coding']",
        "C": "John swimming",
        "D": "John reading"
      },
      "correct_answer": "C"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "Which of the following correctly applies compression middleware in an Express application?",
      "options": {
        "A": "app.use(express.compress())",
        "B": "app.use(require('compression')())",
        "C": "app.compress('gzip')",
        "D": "app.use(require('express-compress'))"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What will be the output of the following code using express-validator?",
      "code_example": "const express = require('express');\nconst { body, validationResult } = require('express-validator');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/user',\n  body('email').isEmail(),\n  body('password').isLength({ min: 5 }),\n  (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n    res.send('Valid input');\n  }\n);\n\n// What happens when a POST request with {\"email\": \"not-an-email\", \"password\": \"123\"} is received?",
      "options": {
        "A": "Server responds with 'Valid input'",
        "B": "Server responds with status 400 and a list of two validation errors",
        "C": "Server responds with status 500 (Internal Server Error)",
        "D": "Server crashes due to invalid input"
      },
      "correct_answer": "B"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "When reading large files with Node.js streams, what does the 'highWaterMark' option define?",
      "options": {
        "A": "The maximum size of the file that can be read",
        "B": "The threshold at which backpressure is applied",
        "C": "The minimum amount of data required before emitting 'data' events",
        "D": "The maximum number of concurrent readers allowed"
      },
      "correct_answer": "B",
      "code_example": "const fs = require('fs');\n\nconst readStream = fs.createReadStream('large-file.txt', {\n  highWaterMark: 64 * 1024, // 64KB chunks\n  encoding: 'utf8'\n});\n\nreadStream.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data`);\n  // Process data here\n});\n\nreadStream.on('end', () => {\n  console.log('Finished reading file');\n});"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "What will be logged to the console when the following code is executed?",
      "options": {
        "A": "first second third",
        "B": "first third second",
        "C": "third first second",
        "D": "second first third"
      },
      "correct_answer": "B",
      "code_example": "class EventBus {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(callback);\n    return this;\n  }\n\n  emit(event, ...args) {\n    if (this.events[event]) {\n      this.events[event].forEach(callback => {\n        setTimeout(() => callback(...args), 0);\n      });\n    }\n    return this;\n  }\n}\n\nconst bus = new EventBus();\n\nbus.on('message', () => console.log('first'));\nbus.on('message', () => console.log('second'));\n\nconsole.log('third');\nbus.emit('message');"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "When creating a Kubernetes Pod configuration in YAML, which of the following correctly specifies resource limits for a Node.js container?",
      "options": {
        "A": "resources: { limit: { memory: '512Mi', cpu: '500m' } }",
        "B": "resources: { limits: { memory: '512Mi', cpu: '500m' } }",
        "C": "container: { resources: { memory: '512Mi', cpu: '500m' } }",
        "D": "spec: { resources: { memory: '512Mi', cpu: '500m' } }"
      },
      "correct_answer": "B"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "What will be the result of executing this code?",
      "options": {
        "A": "Child process started with id: 1",
        "B": "Error: Cannot call fork() from a worker thread",
        "C": "Primary has pid 1234\nWorker started with id: 1, pid: 5678",
        "D": "NaN"
      },
      "correct_answer": "C",
      "code_example": "const cluster = require('cluster');\nconst os = require('os');\n\nif (cluster.isPrimary) {\n  console.log(`Primary has pid ${process.pid}`);\n  \n  // Fork a single worker\n  cluster.fork();\n  \n  // Track worker events\n  for (const id in cluster.workers) {\n    cluster.workers[id].on('message', (msg) => {\n      console.log(`Message from worker ${id}: ${msg}`);\n    });\n  }\n} else {\n  // This code runs in worker processes\n  console.log(`Worker started with id: ${cluster.worker.id}, pid: ${process.pid}`);\n}"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "In V8 JavaScript engine optimization, when does a hidden class transition occur?",
      "options": {
        "A": "Only when a property is deleted from an object",
        "B": "Only when a new property is added to an object",
        "C": "When properties are added, deleted, or reordered on an object",
        "D": "Only when a property's data type changes"
      },
      "correct_answer": "C",
      "code_example": "// First object - creates hidden class C0\nconst user1 = {};\n\n// Adds property 'name' - transitions to hidden class C1\nuser1.name = 'Alice';\n\n// Adds property 'age' - transitions to hidden class C2\nuser1.age = 30;\n\n// Second object follows the same pattern\nconst user2 = {};\nuser2.name = 'Bob';\nuser2.age = 25; // Same hidden class C2 is reused\n\n// Third object with different property order\nconst user3 = {};\nuser3.age = 40; // Different order - creates new hidden class C3\nuser3.name = 'Charlie'; // Creates another hidden class C4"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "What is the most effective way to prevent memory leaks when using event listeners in Node.js?",
      "options": {
        "A": "Always use arrow functions for event callbacks",
        "B": "Call process.gc() after removing listeners",
        "C": "Remove event listeners when they are no longer needed using removeListener() or removeAllListeners()",
        "D": "Use weakref to create weak references to event listeners"
      },
      "correct_answer": "C",
      "code_example": "const EventEmitter = require('events');\nconst fs = require('fs');\n\nfunction processFile(filePath) {\n  const emitter = new EventEmitter();\n  const readStream = fs.createReadStream(filePath);\n  \n  // Set up event handlers\n  const dataHandler = (chunk) => {\n    emitter.emit('data', chunk);\n  };\n  \n  const errorHandler = (err) => {\n    emitter.emit('error', err);\n  };\n  \n  const endHandler = () => {\n    emitter.emit('end');\n    \n    // Clean up event listeners to prevent memory leaks\n    readStream.removeListener('data', dataHandler);\n    readStream.removeListener('error', errorHandler);\n    readStream.removeListener('end', endHandler);\n  };\n  \n  // Attach event listeners\n  readStream.on('data', dataHandler);\n  readStream.on('error', errorHandler);\n  readStream.on('end', endHandler);\n  \n  return emitter;\n}"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "Which statement is true about the 'once' method in Node.js EventEmitter?",
      "options": {
        "A": "It emits an event exactly once, regardless of how many times emit() is called",
        "B": "It registers a listener that will be invoked only once, then automatically removed",
        "C": "It synchronously executes a callback exactly once when called",
        "D": "It ensures all listeners are executed exactly one time in sequence"
      },
      "correct_answer": "B",
      "code_example": "const EventEmitter = require('events');\n\nclass Database extends EventEmitter {\n  constructor() {\n    super();\n    this.connected = false;\n  }\n  \n  connect() {\n    // Simulate connection\n    setTimeout(() => {\n      this.connected = true;\n      this.emit('connect');\n    }, 1000);\n  }\n  \n  query(sql) {\n    if (!this.connected) {\n      // Execute query once connection is established\n      this.once('connect', () => {\n        console.log(`Executing query: ${sql}`);\n      });\n      this.connect();\n    } else {\n      console.log(`Executing query: ${sql}`);\n    }\n  }\n}\n\nconst db = new Database();\ndb.query('SELECT * FROM users');\n\n// Later...\nsetTimeout(() => {\n  // This will cause 'connect' to be emitted again, but our\n  // query handler won't run a second time because of .once()\n  db.emit('connect');\n}, 2000);"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "Which of the following is the most effective defense against Cross-Site Request Forgery (CSRF) attacks in a modern Node.js web application?",
      "options": {
        "A": "Using JSON Web Tokens (JWT) for authentication",
        "B": "Implementing a Content Security Policy (CSP)",
        "C": "Using HTTPS for all communications",
        "D": "Implementing Same-Site cookies and anti-CSRF tokens"
      },
      "correct_answer": "D"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What will be logged to the console when this code is executed?",
      "options": {
        "A": "undefined",
        "B": "\"<p>Hello World</p>\"",
        "C": "\"&lt;p&gt;Hello World&lt;/p&gt;\"",
        "D": "Error: Potential XSS attack detected"
      },
      "correct_answer": "C",
      "code_example": "function sanitizeHTML(input) {\n  return input\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n}\n\nfunction displayUserInput(input) {\n  // Sanitize input to prevent XSS\n  const sanitized = sanitizeHTML(input);\n  console.log(sanitized);\n  \n  // In a real app, we might do:\n  // document.getElementById('output').innerHTML = sanitized;\n}\n\n// Simulate user input that could be malicious\nconst userInput = '<p>Hello World</p>';\ndisplayUserInput(userInput);"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "When configuring Prometheus for monitoring a Node.js application, which of the following metrics would be most useful for detecting memory leaks?",
      "options": {
        "A": "process_cpu_seconds_total",
        "B": "nodejs_eventloop_lag_seconds",
        "C": "process_resident_memory_bytes showing a steady increase over time",
        "D": "http_request_duration_seconds"
      },
      "correct_answer": "C"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What is the output of the following code that implements refresh token rotation?",
      "options": {
        "A": "{ accessToken: 'new_access_token', refreshToken: 'new_refresh_token' }",
        "B": "Error: Invalid refresh token",
        "C": "{ accessToken: 'new_access_token', refreshToken: 'same_refresh_token' }",
        "D": "Error: Refresh token reuse detected"
      },
      "correct_answer": "A",
      "code_example": "// Simulated token storage\nconst tokenStore = {\n  'valid_refresh_token': {\n    userId: 123,\n    used: false,\n    family: 'abc'\n  }\n};\n\nfunction rotateTokens(refreshToken) {\n  // Check if token exists\n  if (!tokenStore[refreshToken]) {\n    throw new Error('Invalid refresh token');\n  }\n  \n  const tokenData = tokenStore[refreshToken];\n  \n  // Check if token was already used (potential reuse attack)\n  if (tokenData.used) {\n    // In a real system, we would invalidate the entire token family\n    delete tokenStore[refreshToken];\n    throw new Error('Refresh token reuse detected');\n  }\n  \n  // Mark current token as used\n  tokenData.used = true;\n  \n  // Generate new tokens\n  const newAccessToken = 'new_access_token';\n  const newRefreshToken = 'new_refresh_token';\n  \n  // Store new refresh token with same family\n  tokenStore[newRefreshToken] = {\n    userId: tokenData.userId,\n    used: false,\n    family: tokenData.family\n  };\n  \n  return {\n    accessToken: newAccessToken,\n    refreshToken: newRefreshToken\n  };\n}\n\n// Test with valid token\nconst result = rotateTokens('valid_refresh_token');\nconsole.log(result);"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "What will be the output of this code using the worker_threads module for parallel processing?",
      "options": {
        "A": "Main thread: 0\nWorker result: 45",
        "B": "Main thread: 45\nWorker result: 0",
        "C": "Error: Cannot transfer ArrayBuffer while it is being used",
        "D": "Main thread: 0\nWorker result: [object Object]"
      },
      "correct_answer": "A",
      "code_example": "const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');\n\nif (isMainThread) {\n  // This code runs in the main thread\n  const buffer = new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT);\n  const array = new Int32Array(buffer);\n  array[0] = 0;\n  \n  const worker = new Worker(__filename, {\n    workerData: { buffer }\n  });\n  \n  worker.on('message', (result) => {\n    console.log('Main thread:', array[0]);\n    console.log('Worker result:', result);\n  });\n} else {\n  // This code runs in the worker thread\n  const { buffer } = workerData;\n  const array = new Int32Array(buffer);\n  \n  // Calculate sum of numbers from 1 to 9\n  let result = 0;\n  for (let i = 1; i <= 9; i++) {\n    result += i;\n  }\n  \n  parentPort.postMessage(result);\n}"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What will be output when running this transform stream code?",
      "options": {
        "A": "Transformed: HELLO",
        "B": "Transformed: HELLO\nTransformed: WORLD",
        "C": "Transformed: H\nTransformed: E\nTransformed: L\nTransformed: L\nTransformed: O",
        "D": "Transformed: H,E,L,L,O\nTransformed: W,O,R,L,D"
      },
      "correct_answer": "B",
      "code_example": "const { Transform } = require('stream');\n\nclass UppercaseTransform extends Transform {\n  constructor(options) {\n    super(options);\n  }\n  \n  _transform(chunk, encoding, callback) {\n    // Convert chunk to uppercase\n    const upperChunk = chunk.toString().toUpperCase();\n    this.push(`Transformed: ${upperChunk}`);\n    callback();\n  }\n}\n\n// Create the transform stream\nconst uppercaseTransform = new UppercaseTransform();\n\n// Set up output handling\nuppercaseTransform.on('data', (data) => {\n  console.log(data.toString());\n});\n\n// Write data to the stream\nuppercaseTransform.write('hello');\nuppercaseTransform.write('world');\nuppercaseTransform.end();"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "Which of the following strategies correctly describes horizontal scaling for a Node.js application?",
      "options": {
        "A": "Adding more CPU cores to a single server running the application",
        "B": "Adding more RAM to improve application performance",
        "C": "Deploying the application across multiple servers behind a load balancer",
        "D": "Using cluster module to utilize all available CPU cores on a single machine"
      },
      "correct_answer": "C"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What is the main security advantage of using the PKCE extension in OAuth 2.0 compared to the Implicit flow?",
      "options": {
        "A": "It allows for faster authentication",
        "B": "It protects against authorization code interception attacks for public clients",
        "C": "It provides backward compatibility with OAuth 1.0",
        "D": "It reduces the number of HTTP requests required"
      },
      "correct_answer": "B"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "What will be the result of running this CI/CD pipeline code?",
      "options": {
        "A": "Error: Invalid stage configuration",
        "B": "Pipeline completed: [\"UNIT TESTS PASSED\",\"INTEGRATION TESTS PASSED\",\"DEPLOYMENT SUCCEEDED\"]",
        "C": "Pipeline completed: [\"UNIT TESTS PASSED\",\"INTEGRATION TESTS PASSED\"]",
        "D": "Pipeline completed: []"
      },
      "correct_answer": "B",
      "code_example": "class Pipeline {\n  constructor() {\n    this.stages = [];\n    this.results = [];\n  }\n  \n  addStage(name, task) {\n    this.stages.push({ name, task });\n    return this;\n  }\n  \n  async run() {\n    for (const stage of this.stages) {\n      try {\n        const result = await stage.task();\n        this.results.push(result);\n      } catch (error) {\n        console.error(`Pipeline failed at stage: ${stage.name}`);\n        console.error(error);\n        return this.results;\n      }\n    }\n    \n    return this.results;\n  }\n}\n\n// Usage\nasync function runPipeline() {\n  const pipeline = new Pipeline();\n  \n  // Add stages to the pipeline\n  pipeline\n    .addStage('Unit Tests', async () => {\n      // Simulate unit tests\n      await new Promise(resolve => setTimeout(resolve, 100));\n      return 'UNIT TESTS PASSED';\n    })\n    .addStage('Integration Tests', async () => {\n      // Simulate integration tests\n      await new Promise(resolve => setTimeout(resolve, 100));\n      return 'INTEGRATION TESTS PASSED';\n    })\n    .addStage('Deployment', async () => {\n      // Simulate deployment\n      await new Promise(resolve => setTimeout(resolve, 100));\n      return 'DEPLOYMENT SUCCEEDED';\n    });\n  \n  // Run the pipeline\n  const results = await pipeline.run();\n  console.log(`Pipeline completed: ${JSON.stringify(results)}`);\n  return results;\n}\n\nrunPipeline();"
    }
  ]
}
