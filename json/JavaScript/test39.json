{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(1 == '1');",
      "options": {
        "A": "true",
        "B": "false",
        "C": "undefined",
        "D": "TypeError"
      },
      "correct_answer": "A"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(1 === '1');",
      "options": {
        "A": "true",
        "B": "false",
        "C": "undefined",
        "D": "TypeError"
      },
      "correct_answer": "B"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What happens when you call the pop() method on an empty array?",
      "options": {
        "A": "It throws an error",
        "B": "It returns null",
        "C": "It returns undefined",
        "D": "It returns an empty array"
      },
      "correct_answer": "C"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const arr = [1, 2, 3];\narr.unshift(4);\nconsole.log(arr);",
      "options": {
        "A": "[1, 2, 3, 4]",
        "B": "[4, 1, 2, 3]",
        "C": "[4]",
        "D": "TypeError: arr.unshift is not a function"
      },
      "correct_answer": "B"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const promise = new Promise((resolve, reject) => {\n  resolve('Success!');\n  reject('Failure!');\n});\n\npromise\n  .then(value => console.log(value))\n  .catch(error => console.log(error));",
      "options": {
        "A": "Success!",
        "B": "Failure!",
        "C": "Success! followed by Failure!",
        "D": "No output"
      },
      "correct_answer": "A"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const arr = [10, 20, 30, 40];\nconst sliced = arr.slice(1, 3);\nconsole.log(sliced);",
      "options": {
        "A": "[10, 20]",
        "B": "[20, 30]",
        "C": "[20, 30, 40]",
        "D": "[10, 20, 30]"
      },
      "correct_answer": "B"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What's the difference between function declarations and function expressions?",
      "options": {
        "A": "There is no difference",
        "B": "Function declarations can be called before they are defined (hoisted), function expressions cannot",
        "C": "Function expressions can be called before they are defined (hoisted), function declarations cannot",
        "D": "Function declarations cannot be assigned to variables, function expressions can"
      },
      "correct_answer": "B"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(parseInt('10.5') + parseFloat('10.5'));",
      "options": {
        "A": "20.5",
        "B": "21",
        "C": "20",
        "D": "1010.5"
      },
      "correct_answer": "B"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let i = 0;\nlet text = '';\n\ndo {\n  text += i + ' ';\n  i++;\n} while (i < 3);\n\nconsole.log(text);",
      "options": {
        "A": "0 1 2",
        "B": "0 1 2 ",
        "C": "1 2 3",
        "D": "0 1 2 3"
      },
      "correct_answer": "B"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(true && false || true);",
      "options": {
        "A": "true",
        "B": "false",
        "C": "undefined",
        "D": "SyntaxError"
      },
      "correct_answer": "A"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "for (let i = 0; i < 5; i++) {\n  if (i === 2) {\n    continue;\n  }\n  console.log(i);\n  if (i === 3) {\n    break;\n  }\n}",
      "options": {
        "A": "0 1 3",
        "B": "0 1 2 3",
        "C": "0 1 3 4",
        "D": "0 1 2 3 4"
      },
      "correct_answer": "A"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const obj = { a: 1, b: 2, c: 3 };\nconsole.log(Object.keys(obj));",
      "options": {
        "A": "{a, b, c}",
        "B": "[a, b, c]",
        "C": "[\"a\", \"b\", \"c\"]",
        "D": "1, 2, 3"
      },
      "correct_answer": "C"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "Which method is used to select the first HTML element that matches a specified CSS selector?",
      "options": {
        "A": "getElementById()",
        "B": "getElementsByClassName()",
        "C": "querySelector()",
        "D": "getElementsByTagName()"
      },
      "correct_answer": "C"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What's the main difference between let and var declarations?",
      "options": {
        "A": "let is block-scoped, var is function-scoped",
        "B": "var is block-scoped, let is function-scoped",
        "C": "let can be redeclared in the same scope, var cannot",
        "D": "var can be reassigned, let cannot"
      },
      "correct_answer": "A"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const name = 'John';\nconst age = 30;\nconsole.log(`${name} is ${age} years old.`);",
      "options": {
        "A": "${name} is ${age} years old.",
        "B": "John is 30 years old.",
        "C": "name is age years old.",
        "D": "SyntaxError"
      },
      "correct_answer": "B"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "In a package.json file, what does the 'dependencies' section contain?",
      "options": {
        "A": "Libraries required for the application to run in production",
        "B": "Libraries required only for development purposes",
        "C": "Libraries that can be optionally installed",
        "D": "Libraries that are globally installed on the system"
      },
      "correct_answer": "A"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What will be the output of the following code when used in an Express application?",
      "code_example": "const morgan = require('morgan');\napp.use(morgan('combined'));\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});",
      "options": {
        "A": "It will log all requests to the console using the 'combined' format",
        "B": "It will log only GET requests to the console",
        "C": "It will log request and response times only",
        "D": "It will create a new log file for each request"
      },
      "correct_answer": "A"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "What is the purpose of the Express Router?",
      "options": {
        "A": "To create middleware for Express applications",
        "B": "To enable routing between different Express applications",
        "C": "To modularize route handling by creating multiple mini route handlers",
        "D": "To automatically route requests based on HTTP methods"
      },
      "correct_answer": "C"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const obj = { name: 'John' };\n\nfunction greet() {\n  console.log(`Hello, ${this.name}!`);\n}\n\ngreet.call(obj);",
      "options": {
        "A": "Hello, undefined!",
        "B": "Hello, John!",
        "C": "TypeError: Cannot read property 'name' of undefined",
        "D": "Hello, !"
      },
      "correct_answer": "B"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const numbers = [1, 2, 3];\nconst letters = ['a', 'b', 'c'];\n\nconst combined = { ...numbers, ...letters };\nconsole.log(combined);",
      "options": {
        "A": "{ '0': 'a', '1': 'b', '2': 'c' }",
        "B": "{ '0': 1, '1': 2, '2': 3, '3': 'a', '4': 'b', '5': 'c' }",
        "C": "{ '0': 1, '1': 2, '2': 3 }",
        "D": "{ '0': 1, '1': 2, '2': 'c' }"
      },
      "correct_answer": "A"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What is a potential issue with the following code?",
      "code_example": "function readFileContent(filename, callback) {\n  fs.readFile(filename, 'utf8', (err, data) => {\n    if (err) {\n      console.error('Error reading file:', err);\n      return;\n    }\n    callback(data);\n  });\n}",
      "options": {
        "A": "The function doesn't handle errors properly",
        "B": "The encoding should be 'utf-8' not 'utf8'",
        "C": "The function should be async/await instead of using callbacks",
        "D": "Errors are not passed to the callback function"
      },
      "correct_answer": "D"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const add = (a, b) => a + b;\nconst multiply = (a, b) => a * b;\n\nconst calculate = (a, b, operation) => operation(a, b);\n\nconsole.log(calculate(5, 3, multiply));",
      "options": {
        "A": "8",
        "B": "15",
        "C": "Function reference",
        "D": "TypeError"
      },
      "correct_answer": "B"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What is 'callback hell' in JavaScript?",
      "options": {
        "A": "A situation when too many callback functions are defined in a single file",
        "B": "A situation where callbacks are nested within callbacks, making code hard to read and maintain",
        "C": "When callbacks are executed in the wrong order",
        "D": "When callbacks cause memory leaks in the application"
      },
      "correct_answer": "B"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "In the JavaScript Event Loop, what's the difference between microtasks and macrotasks?",
      "options": {
        "A": "Microtasks are executed before rendering, macrotasks after rendering",
        "B": "Microtasks have higher priority and are processed before the next macrotask",
        "C": "Macrotasks have higher priority and are processed before microtasks",
        "D": "Microtasks are used for I/O operations, macrotasks for calculations"
      },
      "correct_answer": "B"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const person = {\n  name: 'John',\n  address: {\n    city: 'New York',\n    country: 'USA'\n  },\n  hobbies: ['reading', 'coding']\n};\n\nconst { name, address: { city }, hobbies: [firstHobby] } = person;\n\nconsole.log(name, city, firstHobby);",
      "options": {
        "A": "John New York reading",
        "B": "John [object Object] reading",
        "C": "John New York [reading, coding]",
        "D": "John undefined undefined"
      },
      "correct_answer": "A"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What makes JavaScript functions 'first-class'?",
      "options": {
        "A": "They can only be defined at the top level of a program",
        "B": "They can be passed as arguments, returned from other functions, and assigned to variables",
        "C": "They can only be called using the function keyword",
        "D": "They have higher priority in the execution context"
      },
      "correct_answer": "B"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will the following middleware do in an Express application?",
      "code_example": "const helmet = require('helmet');\napp.use(helmet());",
      "options": {
        "A": "It will automatically encrypt all data sent from the server",
        "B": "It will block all requests from unknown IP addresses",
        "C": "It will set various HTTP headers to help secure the application",
        "D": "It will prevent all cross-origin requests to the application"
      },
      "correct_answer": "C"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "When working with large files in Node.js, what is the recommended approach?",
      "options": {
        "A": "Use fs.readFileSync to load the entire file into memory",
        "B": "Use streams to process the file in chunks",
        "C": "Use multiple worker threads to read different parts of the file",
        "D": "Use external libraries as Node.js can't handle large files efficiently"
      },
      "correct_answer": "B"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function outer() {\n  const x = 10;\n  \n  function inner() {\n    console.log(x);\n  }\n  \n  return inner;\n}\n\nconst closureFn = outer();\nclosureFn();",
      "options": {
        "A": "undefined",
        "B": "10",
        "C": "ReferenceError: x is not defined",
        "D": "function inner() { console.log(x); }"
      },
      "correct_answer": "B"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "In Express.js, what does the following middleware do?",
      "code_example": "const compression = require('compression');\napp.use(compression());",
      "options": {
        "A": "It compresses the application code before sending it to the client",
        "B": "It compresses HTTP responses sent to the client",
        "C": "It compresses incoming request data",
        "D": "It compresses the database connections for better performance"
      },
      "correct_answer": "B"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "app.get('/users', (req, res, next) => {\n  try {\n    const users = getUsersFromDatabase(); // Assuming this function may throw\n    res.json(users);\n  } catch (error) {\n    next(error);\n  }\n});",
      "options": {
        "A": "It will send user data as JSON if successful, or pass errors to the next middleware",
        "B": "It will always return a 500 error when getUsersFromDatabase throws",
        "C": "It will crash the server if getUsersFromDatabase throws",
        "D": "The error will be caught but never handled properly"
      },
      "correct_answer": "A"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What action(s) can trigger JavaScript's garbage collection?",
      "options": {
        "A": "Explicitly calling the global.gc() method",
        "B": "Setting variables to null or undefined",
        "C": "Removing event listeners from DOM elements",
        "D": "All of the above can help, but garbage collection timing is determined by the JavaScript engine"
      },
      "correct_answer": "D"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What happens when an unhandled Promise rejection occurs in a Node.js application without proper error handling?",
      "options": {
        "A": "The application will immediately terminate with exit code 1",
        "B": "The event loop will be blocked indefinitely",
        "C": "Node.js will emit an 'unhandledRejection' event and continue execution",
        "D": "The Promise will be automatically retried three times"
      },
      "correct_answer": "C",
      "code_example": "const promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject(new Error('Something went wrong'));\n  }, 100);\n});\n\n// No .catch() or try/catch with await\npromise.then(result => console.log(result));\n\n// Process will continue running"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "Using Node.js streams, what will be the output of this code that reads a large file?",
      "options": {
        "A": "An error because the readStream is never closed",
        "B": "Memory error due to the entire file being loaded at once",
        "C": "Chunks of data as they are read from the file",
        "D": "The total byte count of the file"
      },
      "correct_answer": "C",
      "code_example": "const fs = require('fs');\nconst readStream = fs.createReadStream('./large-file.txt', {\n  encoding: 'utf8',\n  highWaterMark: 1024 // Read in 1kb chunks\n});\n\nreadStream.on('data', (chunk) => {\n  console.log(chunk); // This will log each chunk as it's read\n});\n\nreadStream.on('error', (err) => {\n  console.error('Error reading file:', err);\n});"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What is the primary difference between horizontal and vertical scaling in the context of Node.js applications?",
      "options": {
        "A": "Horizontal scaling uses PM2, vertical scaling uses Forever",
        "B": "Horizontal scaling adds more machines, vertical scaling adds more resources to existing machines",
        "C": "Horizontal scaling is only possible with containerized applications",
        "D": "Vertical scaling requires cloud infrastructure, horizontal scaling works on-premises"
      },
      "correct_answer": "B"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "What will be the output of this code demonstrating a memory leak pattern in JavaScript?",
      "options": {
        "A": "The memory usage remains constant",
        "B": "Memory usage increases linearly until the program crashes",
        "C": "The garbage collector prevents any memory leak",
        "D": "The references array becomes empty after each iteration"
      },
      "correct_answer": "B",
      "code_example": "const references = [];\n\nfunction createLargeObject() {\n  return new Array(1000000).fill('x');\n}\n\nfunction leakMemory() {\n  setInterval(() => {\n    // We keep adding objects to the references array without ever clearing it\n    const largeObject = createLargeObject();\n    references.push(largeObject);\n    \n    console.log(`Current references: ${references.length}`);\n  }, 1000);\n}\n\nleakMemory();\n// Memory usage will continuously increase"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "What will the following code using Transform streams output?",
      "options": {
        "A": "hello world",
        "B": "HELLO WORLD",
        "C": "Helloworld",
        "D": "[object Object]"
      },
      "correct_answer": "B",
      "code_example": "const { Transform } = require('stream');\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nconst upperCaseTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    callback(null, chunk.toString().toUpperCase());\n  }\n});\n\nasync function run() {\n  const readStream = fs.createReadStream('./input.txt');\n  const writeStream = fs.createWriteStream('./output.txt');\n  \n  await pipeline(\n    readStream,\n    upperCaseTransform,\n    writeStream\n  );\n  \n  // Assuming input.txt contains 'hello world'\n  const result = fs.readFileSync('./output.txt', 'utf8');\n  console.log(result);\n}\n\nrun().catch(console.error);"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "In Helmet.js, which of the following is NOT a default security header that it sets?",
      "options": {
        "A": "X-XSS-Protection",
        "B": "Content-Security-Policy",
        "C": "X-Frame-Options",
        "D": "Strict-Transport-Security"
      },
      "correct_answer": "B"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "What will be the output of this code using Node.js clustering?",
      "options": {
        "A": "Only one worker process is created",
        "B": "The master process handles all HTTP requests",
        "C": "Multiple worker processes are created based on available CPUs",
        "D": "The cluster.fork() method throws an error"
      },
      "correct_answer": "C",
      "code_example": "const cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`);\n\n  // Fork workers based on CPU count\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n  });\n} else {\n  // Workers share the same port\n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end(`Worker ${process.pid} handled the request\\n`);\n  }).listen(8000);\n\n  console.log(`Worker ${process.pid} started`);\n}"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "Which of the following is NOT a valid Dockerfile instruction for a Node.js application?",
      "options": {
        "A": "ENTRYPOINT [\"node\", \"app.js\"]",
        "B": "ENV NODE_ENV=production",
        "C": "VOLUME [\"/app/logs\"]",
        "D": "NODEJS_VERSION 16.14.2"
      },
      "correct_answer": "D"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What will happen if a client exceeds the rate limit in the following Express rate limiter configuration?",
      "options": {
        "A": "The client will be blocked for 15 minutes",
        "B": "The application will send a 429 Too Many Requests response",
        "C": "The excess requests will be queued and processed later",
        "D": "The client's IP will be blacklisted permanently"
      },
      "correct_answer": "B",
      "code_example": "const express = require('express');\nconst rateLimit = require('express-rate-limit');\n\nconst app = express();\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers\n  legacyHeaders: false, // Disable the `X-RateLimit-*` headers\n  message: 'Too many requests, please try again after 15 minutes'\n});\n\n// Apply the rate limiting middleware to API calls only\napp.use('/api', apiLimiter);\n\napp.get('/api/data', (req, res) => {\n  res.json({ message: 'Here is your data' });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "Which of the following configurations properly prevents CORS vulnerabilities in a Node.js Express application?",
      "options": {
        "A": "Setting Access-Control-Allow-Origin to '*' for all routes",
        "B": "Using cors middleware with a whitelist of allowed origins and credentials: true",
        "C": "Disabling CORS checks entirely for better performance",
        "D": "Setting the 'Same-Origin' header to 'strict'"
      },
      "correct_answer": "B",
      "code_example": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\n// Whitelist of allowed origins\nconst whitelist = ['https://example.com', 'https://www.trusted-site.com'];\n\n// CORS configuration with whitelist\nconst corsOptions = {\n  origin: function (origin, callback) {\n    if (whitelist.indexOf(origin) !== -1 || !origin) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization'],\n  credentials: true,\n  maxAge: 86400 // 24 hours\n};\n\n// Apply CORS middleware\napp.use(cors(corsOptions));\n\napp.get('/api/secure-data', (req, res) => {\n  res.json({ data: 'This is secure data' });\n});\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "How does JavaScript's memory allocation work for the following code snippet?",
      "options": {
        "A": "The string 'Hello' is stored in the stack memory",
        "B": "The array is stored in the stack, elements in the heap",
        "C": "Both the object and array are allocated in heap memory",
        "D": "The function createObject allocates memory in a special execution context"
      },
      "correct_answer": "C",
      "code_example": "function createObject() {\n  const obj = {\n    name: 'Example',\n    values: [1, 2, 3, 4, 5],\n    description: 'This is a test object'\n  };\n  \n  return obj;\n}\n\nconst myObject = createObject();\nconst anotherObject = myObject; // Creates a reference, not a copy\n\nanotherObject.name = 'Modified';\nconsole.log(myObject.name); // Outputs: 'Modified'"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "When using Prometheus and Grafana to monitor a Node.js application, which of the following metrics would be LEAST useful for identifying performance bottlenecks?",
      "options": {
        "A": "HTTP request duration",
        "B": "Memory usage",
        "C": "Event loop lag",
        "D": "Number of npm packages installed"
      },
      "correct_answer": "D"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What is the output of this code demonstrating differences between promises and WebSockets?",
      "options": {
        "A": "The WebSocket messages are received in order: 1, 2, 3",
        "B": "The WebSocket connection fails due to incorrect URL format",
        "C": "Messages are received in random order due to asynchronous nature",
        "D": "The code prints 'Connected' then closes immediately"
      },
      "correct_answer": "A",
      "code_example": "// Client-side code\nconst socket = new WebSocket('ws://localhost:8080');\n\nsocket.addEventListener('open', function (event) {\n  console.log('Connected');\n  \n  // Send messages in sequence\n  socket.send('Message 1');\n  socket.send('Message 2');\n  socket.send('Message 3');\n});\n\nsocket.addEventListener('message', function (event) {\n  console.log('Received:', event.data);\n});\n\nsocket.addEventListener('close', function (event) {\n  console.log('Connection closed');\n});\n\n// Server-side (Node.js with ws package)\n// const WebSocket = require('ws');\n// const wss = new WebSocket.Server({ port: 8080 });\n// wss.on('connection', function connection(ws) {\n//   ws.on('message', function incoming(message) {\n//     console.log('received: %s', message);\n//     // Echo back the message (maintains order)\n//     ws.send(message);\n//   });\n// });"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "What will be logged by the following code using Winston for logging?",
      "options": {
        "A": "Only 'error' and 'warn' messages in the error.log file",
        "B": "All messages in combined.log, only errors in error.log",
        "C": "All messages in both log files",
        "D": "No logs will be created due to missing transports"
      },
      "correct_answer": "B",
      "code_example": "const winston = require('winston');\nconst { format, transports } = winston;\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: format.combine(\n    format.timestamp({\n      format: 'YYYY-MM-DD HH:mm:ss'\n    }),\n    format.errors({ stack: true }),\n    format.splat(),\n    format.json()\n  ),\n  defaultMeta: { service: 'user-service' },\n  transports: [\n    // Write all logs with level 'info' and below to combined.log\n    new transports.File({ filename: 'combined.log' }),\n    // Write all logs with level 'error' and below to error.log\n    new transports.File({ filename: 'error.log', level: 'error' })\n  ]\n});\n\n// Add console transport if not in production\nif (process.env.NODE_ENV !== 'production') {\n  logger.add(new transports.Console({\n    format: format.combine(\n      format.colorize(),\n      format.simple()\n    )\n  }));\n}\n\nlogger.info('User logged in');\nlogger.warn('Memory usage high');\nlogger.error('Database connection failed');"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "Which of the following is NOT a valid Helm chart component for deploying a Node.js application?",
      "options": {
        "A": "values.yaml for configuration variables",
        "B": "Chart.yaml for metadata like version and description",
        "C": "templates/deployment.yaml for Kubernetes Deployment specs",
        "D": "nodeconfig.js for JavaScript runtime settings"
      },
      "correct_answer": "D"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "What is the output of this code showing how to properly handle unhandled Promise rejections in Node.js?",
      "options": {
        "A": "The process exits with code 1",
        "B": "Caught rejection: Error: Operation failed",
        "C": "UnhandledPromiseRejectionWarning is shown",
        "D": "The process hangs indefinitely"
      },
      "correct_answer": "B",
      "code_example": "process.on('unhandledRejection', (reason, promise) => {\n  console.log('Caught rejection:', reason);\n  // Prevent the process from exiting\n});\n\nfunction failingAsyncOperation() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error('Operation failed'));\n    }, 100);\n  });\n}\n\n// Call the function without handling the rejection in the immediate scope\nfailingAsyncOperation();\n\n// Keep the process alive to see the event handler in action\nsetTimeout(() => {\n  console.log('Process still running');\n}, 1000);"
    }
  ]
}
