{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const preventClick = (event) => {\n  event.preventDefault();\n  console.log('Default prevented');\n};\n\n// Assuming this function is attached to a button's click event\n// What would be logged when the button is clicked?",
      "options": {
        "A": "Nothing would be logged as preventDefault() stops all JavaScript execution",
        "B": "Default prevented",
        "C": "TypeError: event.preventDefault is not a function",
        "D": "Event prevented"
      },
      "correct_answer": "B"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What will be the result of the following arithmetic operation?",
      "code_example": "console.log(5 ** 2 % 3);",
      "options": {
        "A": "25",
        "B": "1",
        "C": "7",
        "D": "2"
      },
      "correct_answer": "B"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "Which of the following statements about let, const, and var is correct?",
      "options": {
        "A": "let variables can be redeclared within the same scope",
        "B": "const variables can be reassigned but not redeclared",
        "C": "var variables are block-scoped just like let",
        "D": "let and const are hoisted but not initialized, while var is hoisted and initialized with undefined"
      },
      "correct_answer": "D"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const name = 'Alice';\nconst age = 25;\nconsole.log(`${name} is ${age + 5} years old`);",
      "options": {
        "A": "Alice is 25 + 5 years old",
        "B": "Alice is 30 years old",
        "C": "${name} is ${age + 5} years old",
        "D": "name is age + 5 years old"
      },
      "correct_answer": "B"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "sayHello();\n\nfunction sayHello() {\n  console.log('Hello!');\n}\n\nsayGoodbye();\n\nconst sayGoodbye = function() {\n  console.log('Goodbye!');\n};",
      "options": {
        "A": "Hello! Goodbye!",
        "B": "Hello! followed by a ReferenceError",
        "C": "ReferenceError for both function calls",
        "D": "Undefined for both function calls"
      },
      "correct_answer": "B"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What is the key difference between let and const?",
      "options": {
        "A": "let is block-scoped, while const is function-scoped",
        "B": "let can be declared without initialization, while const must be initialized during declaration",
        "C": "let is not hoisted, while const is hoisted",
        "D": "let cannot be reassigned, while const can be reassigned"
      },
      "correct_answer": "B"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const normalFunction = function(a, b) {\n  return a + b;\n};\n\nconst arrowFunction = (a, b) => a + b;\n\nconsole.log(normalFunction(5, 3), arrowFunction(5, 3));",
      "options": {
        "A": "8 8",
        "B": "5 3 5 3",
        "C": "undefined undefined",
        "D": "8 undefined"
      },
      "correct_answer": "A"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function greet(name = 'Guest', greeting = `Hello, ${name}!`) {\n  console.log(greeting);\n}\n\ngreet('Developer');",
      "options": {
        "A": "Hello, Guest!",
        "B": "Hello, ${name}!",
        "C": "Hello, Developer!",
        "D": "undefined"
      },
      "correct_answer": "C"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "Which method is used to read a file synchronously in Node.js?",
      "options": {
        "A": "fs.readFile()",
        "B": "fs.readFileSync()",
        "C": "fs.read()",
        "D": "fs.openSync()"
      },
      "correct_answer": "B"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What is a key difference between require() and import() in JavaScript?",
      "options": {
        "A": "require() is synchronous, while import() is asynchronous",
        "B": "require() is for Node.js only, while import() won't work in any Node.js version",
        "C": "require() loads the entire module, while import() always performs tree-shaking",
        "D": "require() is a statement, while import() is always a function"
      },
      "correct_answer": "A"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const promise = new Promise((resolve, reject) => {\n  resolve('Success!');\n  reject('Error!');\n});\n\npromise\n  .then(value => console.log(value))\n  .catch(error => console.log(error));",
      "options": {
        "A": "Error!",
        "B": "Success!",
        "C": "Success! Error!",
        "D": "Nothing will be logged"
      },
      "correct_answer": "B"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "Which of the following is NOT a key difference between Node.js and browser JavaScript?",
      "options": {
        "A": "Node.js has access to the file system via the fs module",
        "B": "Browser JavaScript has the window object, while Node.js has the global object",
        "C": "Node.js can access HTTP modules directly, while browsers use fetch or XMLHttpRequest",
        "D": "Node.js is single-threaded, while browser JavaScript is multi-threaded"
      },
      "correct_answer": "D"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(1 == '1');\nconsole.log(1 === '1');",
      "options": {
        "A": "true true",
        "B": "false false",
        "C": "true false",
        "D": "false true"
      },
      "correct_answer": "C"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(Number('123.45'));\nconsole.log(parseInt('123.45'));\nconsole.log(parseFloat('123.45'));",
      "options": {
        "A": "123.45 123 123.45",
        "B": "123.45 123.45 123.45",
        "C": "NaN NaN NaN",
        "D": "123 123 123"
      },
      "correct_answer": "A"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const value = 3;\n\nif (value === 1) {\n  console.log('One');\n} else if (value === 2) {\n  console.log('Two');\n} else {\n  console.log('Other');\n}\n\nswitch (value) {\n  case 1:\n    console.log('Uno');\n    break;\n  case 2:\n    console.log('Dos');\n    break;\n  default:\n    console.log('Otro');\n}",
      "options": {
        "A": "One Uno",
        "B": "Two Dos",
        "C": "Other Otro",
        "D": "Nothing will be logged"
      },
      "correct_answer": "C"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let num = 5;\nnum += 2;\nnum *= 3;\nnum /= 2;\nconsole.log(num);",
      "options": {
        "A": "10.5",
        "B": "15",
        "C": "7",
        "D": "21"
      },
      "correct_answer": "A"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "How does JavaScript's prototypal inheritance differ from classical inheritance in languages like Java or C++?",
      "options": {
        "A": "JavaScript uses 'extends' keyword while classical languages use prototypes",
        "B": "In JavaScript, objects inherit directly from other objects, not from classes",
        "C": "JavaScript doesn't support inheritance between objects",
        "D": "Classical inheritance is dynamic while JavaScript's is static"
      },
      "correct_answer": "B"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "What will happen in the following code regarding memory management?",
      "code_example": "function createLargeArray() {\n  let arr = new Array(10000000).fill('data');\n  return function() {\n    console.log('Array length:', arr.length);\n  };\n}\n\nconst getArrayInfo = createLargeArray();\ngetArrayInfo();\n// Later in the code\ngetArrayInfo = null;",
      "options": {
        "A": "The large array becomes eligible for garbage collection immediately after createLargeArray() is called",
        "B": "The large array becomes eligible for garbage collection when getArrayInfo is set to null",
        "C": "The large array is never eligible for garbage collection",
        "D": "The large array becomes eligible for garbage collection after getArrayInfo() is called once"
      },
      "correct_answer": "B"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "Which of the following correctly sets up morgan middleware for logging HTTP requests in an Express application?",
      "code_example": "const express = require('express');\nconst morgan = require('morgan');\nconst app = express();\n\n// What is the correct way to set up morgan for logging all requests in the 'combined' format?\n",
      "options": {
        "A": "app.use(morgan.combined());",
        "B": "app.use(morgan('combined'));",
        "C": "app.use(new morgan('combined'));",
        "D": "app.logger(morgan('combined'));"
      },
      "correct_answer": "B"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "What is the correct way to implement rate limiting in an Express application to limit users to 100 requests per hour?",
      "code_example": "const express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst app = express();\n\n// What code should be added here?",
      "options": {
        "A": "app.use(rateLimit({ windowMs: 60 * 60 * 1000, max: 100 }));",
        "B": "app.limit({ requests: 100, timeWindow: '1h' });",
        "C": "app.use(rateLimit.create({ max: 100, window: '60m' }));",
        "D": "app.middleware(new rateLimit({ maxRequests: 100, time: 3600 }));"
      },
      "correct_answer": "A"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What will be the output of the following MongoDB schema validation code?",
      "code_example": "const mongoose = require('mongoose');\n\nconst userSchema = new mongoose.Schema({\n  username: { type: String, required: true, unique: true },\n  email: { \n    type: String, \n    validate: {\n      validator: function(v) {\n        return /^\\S+@\\S+\\.\\S+$/.test(v);\n      },\n      message: 'Email format is invalid'\n    }\n  },\n  age: { type: Number, min: 18 }\n});\n\n// What happens when creating this user?\nconst User = mongoose.model('User', userSchema);\nconst user = new User({\n  username: 'testuser',\n  email: 'invalid-email',\n  age: 16\n});\n\nuser.validate(err => console.log(err ? 'Invalid' : 'Valid'));",
      "options": {
        "A": "Valid (the validation passes)",
        "B": "Invalid (only the email validation fails)",
        "C": "Invalid (only the age validation fails)",
        "D": "Invalid (both email and age validation fail)"
      },
      "correct_answer": "D"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const value1 = 0;\nconst value2 = '';\nconst value3 = null;\nconst value4 = undefined;\n\nconsole.log(value1 || 'default');\nconsole.log(value1 ?? 'default');\n\nconsole.log(value2 || 'default');\nconsole.log(value2 ?? 'default');\n\nconsole.log(value3 || 'default');\nconsole.log(value3 ?? 'default');\n\nconsole.log(value4 || 'default');\nconsole.log(value4 ?? 'default');",
      "options": {
        "A": "default, 0, default, '', default, default, default, default",
        "B": "0, 0, '', '', null, default, undefined, default",
        "C": "default, 0, default, '', default, null, default, undefined",
        "D": "default, 0, default, '', default, 'default', default, 'default'"
      },
      "correct_answer": "A"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "In an Express application, what is the correct sequence for middleware execution in the following code?",
      "code_example": "app.use((req, res, next) => {\n  console.log('Middleware 1');\n  next();\n});\n\napp.get('/api', (req, res, next) => {\n  console.log('Route handler');\n  next();\n}, (req, res, next) => {\n  console.log('Middleware 2');\n  next();\n});\n\napp.use((req, res, next) => {\n  console.log('Middleware 3');\n  res.send('Done');\n});\n\n// What will be logged when making a GET request to /api?",
      "options": {
        "A": "Middleware 1, Route handler, Middleware 2, Middleware 3",
        "B": "Middleware 1, Middleware 3 (the route handler is skipped)",
        "C": "Route handler, Middleware 2, Middleware 3 (Middleware 1 is skipped)",
        "D": "Middleware 1, Middleware 2, Middleware 3 (the route handler is skipped)"
      },
      "correct_answer": "A"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What is the correct way to enable CORS for all routes in an Express application?",
      "code_example": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\n// What should be added here to enable CORS for all origins?",
      "options": {
        "A": "app.headers({'Access-Control-Allow-Origin': '*'});",
        "B": "app.use(cors());",
        "C": "app.enable('cors');",
        "D": "app.use(new cors({ origins: '*' }));"
      },
      "correct_answer": "B"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What is the correct way to configure Express to parse URL-encoded form data with nested objects?",
      "code_example": "const express = require('express');\nconst app = express();\n\n// What code should be added here to handle form data?",
      "options": {
        "A": "app.use(express.urlencoded({ extended: true }));",
        "B": "app.use(express.formParser({ nested: true }));",
        "C": "app.use(express.bodyParser());",
        "D": "app.use(express.urlencoded());"
      },
      "correct_answer": "A"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout 1');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 1');\n});\n\nrequestAnimationFrame(() => {\n  console.log('Animation Frame');\n});\n\nsetTimeout(() => {\n  console.log('Timeout 2');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise 2');\n});\n\nconsole.log('End');",
      "options": {
        "A": "Start, End, Promise 1, Promise 2, Timeout 1, Timeout 2, Animation Frame",
        "B": "Start, End, Timeout 1, Timeout 2, Promise 1, Promise 2, Animation Frame",
        "C": "Start, End, Animation Frame, Promise 1, Promise 2, Timeout 1, Timeout 2",
        "D": "Start, End, Promise 1, Promise 2, Animation Frame, Timeout 1, Timeout 2"
      },
      "correct_answer": "A"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What is the correct way to connect to a MongoDB database using Mongoose?",
      "code_example": "const mongoose = require('mongoose');\n\n// What code should be added to connect to a MongoDB database running at\n// mongodb://localhost:27017/myapp with proper error handling?",
      "options": {
        "A": "mongoose.connect('mongodb://localhost:27017/myapp', { useNewUrlParser: true }).catch(err => console.error(err));",
        "B": "mongoose.createConnection('mongodb://localhost:27017/myapp');",
        "C": "mongoose.connect('mongodb://localhost:27017/myapp', { useNewUrlParser: true }).then(() => console.log('Connected')).catch(err => console.error(err));",
        "D": "mongoose.open('mongodb://localhost:27017/myapp', function(err) { if(err) console.error(err); });"
      },
      "correct_answer": "C"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What technique would best reduce redundant database queries in the following Express route handler?",
      "code_example": "app.get('/users/:id/profile', async (req, res) => {\n  const user = await User.findById(req.params.id);\n  const userPosts = await Post.find({ userId: req.params.id });\n  const userComments = await Comment.find({ userId: req.params.id });\n  \n  res.json({\n    user,\n    posts: userPosts,\n    comments: userComments\n  });\n});",
      "options": {
        "A": "Using database indexes on the userId fields",
        "B": "Using Promise.all() to run queries concurrently",
        "C": "Using MongoDB's $lookup to perform a join operation",
        "D": "Using a separate microservice for each query"
      },
      "correct_answer": "B"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What is the correct implementation of lazy loading for images in a web application?",
      "code_example": "// Which approach correctly implements lazy loading for images?",
      "options": {
        "A": "<img src=\"large-image.jpg\" loading=\"lazy\" alt=\"Description\">",
        "B": "<img data-src=\"large-image.jpg\" class=\"lazy\" alt=\"Description\">",
        "C": "<img src=\"placeholder.jpg\" data-src=\"large-image.jpg\" class=\"lazy\" alt=\"Description\">",
        "D": "All of the above are valid approaches depending on requirements"
      },
      "correct_answer": "D"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const obj = {};\nconst nameSymbol = Symbol('name');\nconst nameString = 'name';\n\nobj[nameSymbol] = 'John';\nobj[nameString] = 'Jane';\n\nconsole.log(obj[nameSymbol]);\nconsole.log(obj[nameString]);\nconsole.log(obj.name);\nconsole.log(Object.keys(obj).length);",
      "options": {
        "A": "John, Jane, Jane, 2",
        "B": "John, Jane, Jane, 1",
        "C": "John, Jane, undefined, 1",
        "D": "undefined, Jane, Jane, 1"
      },
      "correct_answer": "B"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function fetchData() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => reject(new Error('Network error')), 100);\n  });\n}\n\nasync function getData() {\n  try {\n    const data = await fetchData();\n    console.log('Data:', data);\n    return 'Success';\n  } catch (error) {\n    console.log('Error:', error.message);\n    return 'Failed';\n  } finally {\n    console.log('Completed');\n  }\n}\n\ngetData().then(result => console.log('Result:', result));",
      "options": {
        "A": "Data: undefined, Completed, Result: Success",
        "B": "Error: Network error, Result: Failed",
        "C": "Error: Network error, Completed, Result: Failed",
        "D": "Completed, Error: Network error, Result: Failed"
      },
      "correct_answer": "C"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function Vehicle() {\n  this.wheels = 4;\n}\n\nVehicle.prototype.start = function() {\n  return 'Starting vehicle';\n};\n\nfunction Car() {\n  Vehicle.call(this);\n  this.doors = 4;\n}\n\nCar.prototype = Object.create(Vehicle.prototype);\nCar.prototype.constructor = Car;\n\nCar.prototype.start = function() {\n  return 'Starting car';\n};\n\nconst vehicle = new Vehicle();\nconst car = new Car();\n\nconsole.log(car.wheels);\nconsole.log(car.start());\nconsole.log(car instanceof Vehicle);\nconsole.log(car.__proto__ === Car.prototype);",
      "options": {
        "A": "4, Starting car, true, true",
        "B": "4, Starting car, false, true",
        "C": "undefined, Starting car, true, true",
        "D": "4, Starting vehicle, true, true"
      },
      "correct_answer": "A"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What is the output of the following code that uses the worker_threads module in Node.js?",
      "options": {
        "A": "Main thread: 15, Worker: 20",
        "B": "Main thread: 10, Worker: 20",
        "C": "Main thread: 10, Worker: undefined",
        "D": "Main thread: 15, Worker: undefined"
      },
      "correct_answer": "B",
      "code_example": "const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');\n\nif (isMainThread) {\n  const worker = new Worker(__filename, {\n    workerData: { value: 20 }\n  });\n  \n  console.log('Main thread:', 10);\n  \n  worker.on('message', (msg) => {\n    console.log('Worker:', msg);\n  });\n} else {\n  parentPort.postMessage(workerData.value);\n}"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "Which statement about Prometheus and Grafana integration with Node.js is FALSE?",
      "options": {
        "A": "prom-client is a popular Node.js client library for Prometheus",
        "B": "Grafana can directly collect metrics from a Node.js application without Prometheus",
        "C": "The default metrics collection in prom-client includes heap size and event loop lag",
        "D": "Counter, Gauge, Histogram, and Summary are the four main metric types in Prometheus"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What will be the output when executing this Socket.io server and client code?",
      "options": {
        "A": "Server: Client connected!\nClient: Server acknowledged connection\nServer: Received: Hello Server\nClient: Server response: Echo: Hello Server",
        "B": "Client: Server acknowledged connection\nServer: Client connected!\nClient: Server response: Echo: Hello Server\nServer: Received: Hello Server",
        "C": "Server: Client connected!\nClient: Server acknowledged connection\nClient: Server response: Echo: Hello Server\nServer: Received: Hello Server",
        "D": "Client: Server acknowledged connection\nServer: Client connected!\nServer: Received: Hello Server\nClient: Server response: Echo: Hello Server"
      },
      "correct_answer": "A",
      "code_example": "// Server code\nconst io = require('socket.io')(3000);\n\nio.on('connection', (socket) => {\n  console.log('Server: Client connected!');\n  socket.emit('acknowledge');\n  \n  socket.on('message', (data) => {\n    console.log('Server: Received:', data);\n    socket.emit('response', 'Echo: ' + data);\n  });\n});\n\n// Client code\nconst socket = require('socket.io-client')('http://localhost:3000');\n\nsocket.on('acknowledge', () => {\n  console.log('Client: Server acknowledged connection');\n  socket.emit('message', 'Hello Server');\n});\n\nsocket.on('response', (data) => {\n  console.log('Client: Server response:', data);\n});"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "What happens when executing the following code that demonstrates handling unhandled Promise rejections?",
      "options": {
        "A": "Nothing is logged, and the Node.js process continues running",
        "B": "Logs 'Caught rejection: Error occurred' and the process terminates with exit code 1",
        "C": "Logs 'Caught rejection: Error occurred' and the process continues running",
        "D": "Logs 'Unhandled promise rejection' and the Node.js process terminates with a non-zero exit code"
      },
      "correct_answer": "C",
      "code_example": "process.on('unhandledRejection', (reason, promise) => {\n  console.log('Caught rejection:', reason);\n});\n\nfunction asyncOperation() {\n  return new Promise((resolve, reject) => {\n    reject('Error occurred');\n  });\n}\n\nasyncOperation(); // No .catch() or try/catch with await"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "What is the best practice for implementing refresh token rotation in Node.js applications?",
      "options": {
        "A": "Store both access and refresh tokens in browser localStorage for easy access",
        "B": "Use the same expiration time for both access and refresh tokens",
        "C": "Issue a new refresh token with each access token refresh and invalidate the old one",
        "D": "Keep refresh tokens valid indefinitely to avoid user re-authentication"
      },
      "correct_answer": "C",
      "code_example": null
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "What will the following code output when encrypting and then decrypting sensitive data?",
      "options": {
        "A": "Original: my-api-key-123\nEncrypted: [Buffer object]\nDecrypted: my-api-key-123",
        "B": "Original: my-api-key-123\nEncrypted: (encrypted string)\nDecrypted: my-api-key-133",
        "C": "Original: my-api-key-123\nError: Invalid initialization vector",
        "D": "Original: my-api-key-123\nEncrypted: (encrypted string)\nDecrypted: my-api-key-123"
      },
      "correct_answer": "D",
      "code_example": "const crypto = require('crypto');\n\nconst algorithm = 'aes-256-cbc';\nconst key = crypto.randomBytes(32);\nconst iv = crypto.randomBytes(16);\n\nfunction encrypt(text) {\n  const cipher = crypto.createCipheriv(algorithm, key, iv);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nfunction decrypt(encryptedText) {\n  const decipher = crypto.createDecipheriv(algorithm, key, iv);\n  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n}\n\nconst originalText = 'my-api-key-123';\nconsole.log('Original:', originalText);\n\nconst encryptedText = encrypt(originalText);\nconsole.log('Encrypted:', encryptedText);\n\nconst decryptedText = decrypt(encryptedText);\nconsole.log('Decrypted:', decryptedText);"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "Which statement about WebSockets, REST, and GraphQL is correct?",
      "options": {
        "A": "GraphQL always provides better performance than REST for complex queries",
        "B": "WebSockets connections use the HTTP protocol for the entire communication lifecycle",
        "C": "REST supports real-time bidirectional communication similar to WebSockets",
        "D": "WebSockets establish a persistent connection while REST and GraphQL use request-response cycles"
      },
      "correct_answer": "D",
      "code_example": null
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "When debugging a Node.js application with 'node --inspect', what will be the output when running the following code?",
      "options": {
        "A": "Value at line 1: 10\nValue at line 2: undefined",
        "B": "Value at line 1: 10\nValue at line 2: 30",
        "C": "The debugger will pause at the first debugger statement only",
        "D": "The debugger will pause at both debugger statements and show variable values when inspected"
      },
      "correct_answer": "D",
      "code_example": "// Run with: node --inspect debug-example.js\nlet x = 10;\nlet y;\n\ndebugger; // First breakpoint\nconsole.log('Value at line 1:', x);\n\ny = x * 3;\n\ndebugger; // Second breakpoint\nconsole.log('Value at line 2:', y);"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What is the correct way to configure PM2 for load balancing a Node.js application across all available CPU cores?",
      "options": {
        "A": "pm2 start app.js -i max --load-balance",
        "B": "pm2 start app.js -i 0",
        "C": "pm2 start app.js --instances max",
        "D": "pm2 start app.js -c all-cores"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "What will be the output of this code that demonstrates a common memory leak pattern in Node.js?",
      "options": {
        "A": "The program runs indefinitely with growing memory usage",
        "B": "The program outputs 'Memory usage: ~100MB' and terminates",
        "C": "The program throws a 'RangeError: Maximum call stack size exceeded' after some time",
        "D": "The program logs increasing memory usage values until it reaches the heap limit"
      },
      "correct_answer": "D",
      "code_example": "const memoryLeakDemo = () => {\n  const leakyArray = [];\n  \n  // Create a timer that adds objects to the array every 50ms\n  const interval = setInterval(() => {\n    for (let i = 0; i < 10000; i++) {\n      // Each object references its index and a large string\n      leakyArray.push({\n        index: i,\n        data: new Array(10000).fill('x').join(''),\n        timestamp: new Date()\n      });\n    }\n    \n    // Log current memory usage\n    const memoryUsage = process.memoryUsage().heapUsed / 1024 / 1024;\n    console.log(`Memory usage: ~${Math.round(memoryUsage * 100) / 100}MB`);\n    \n    // If we've added enough data, the process will eventually crash\n    // due to memory exhaustion (exceeding heap memory limit)\n  }, 50);\n};\n\nmemoryLeakDemo();"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What will be the output when running this code that demonstrates JavaScript's hidden classes and inline caching optimization?",
      "options": {
        "A": "Time with consistent object structure: 5ms\nTime with inconsistent object structure: 50ms",
        "B": "Time with consistent object structure: 10ms\nTime with inconsistent object structure: 10ms",
        "C": "Time with consistent object structure: Less than time with inconsistent structure",
        "D": "Time with consistent object structure: 10ms\nTime with inconsistent object structure: Error: Inconsistent object structure"
      },
      "correct_answer": "C",
      "code_example": "function runTest() {\n  // Test 1: Consistent object structure\n  const consistentStart = performance.now();\n  \n  for (let i = 0; i < 1000000; i++) {\n    const obj = {\n      x: i,\n      y: i * 2\n    };\n    const result = obj.x + obj.y;\n  }\n  \n  const consistentTime = performance.now() - consistentStart;\n  \n  // Test 2: Inconsistent object structure\n  const inconsistentStart = performance.now();\n  \n  for (let i = 0; i < 1000000; i++) {\n    const obj = { x: i };\n    if (i % 2 === 0) {\n      obj.y = i * 2;\n    } else {\n      obj.z = i * 2;\n    }\n    const result = obj.x + (obj.y || obj.z);\n  }\n  \n  const inconsistentTime = performance.now() - inconsistentStart;\n  \n  console.log(`Time with consistent object structure: ${Math.round(consistentTime)}ms`);\n  console.log(`Time with inconsistent object structure: ${Math.round(inconsistentTime)}ms`);\n}\n\nrunTest();"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "What will be logged when running this code demonstrating WeakMap and WeakSet for memory-sensitive caching?",
      "options": {
        "A": "Cache hit for user1: User data for Alice\nCache hit for user2: undefined\nFound in visited set: false",
        "B": "Cache hit for user1: User data for Alice\nCache hit for user2: User data for Bob\nFound in visited set: true",
        "C": "Cache hit for user1: undefined\nCache hit for user2: undefined\nFound in visited set: false",
        "D": "Cache hit for user1: User data for Alice\nCache hit for user2: undefined\nFound in visited set: true"
      },
      "correct_answer": "A",
      "code_example": "// Using WeakMap for memory-sensitive caching\nconst userCache = new WeakMap();\nconst visitedUsers = new WeakSet();\n\n// Create user objects\nlet user1 = { id: 1, name: 'Alice' };\nlet user2 = { id: 2, name: 'Bob' };\n\n// Store data in the cache and mark user1 as visited\nuserCache.set(user1, 'User data for Alice');\nvisitedUsers.add(user1);\n\n// Retrieve from cache\nconsole.log('Cache hit for user1:', userCache.get(user1));\n\n// Simulate user2 being garbage collected\nuser2 = null;\n\n// Try to get data for user2 (should be undefined)\nconsole.log('Cache hit for user2:', userCache.get({ id: 2, name: 'Bob' }));\n\n// Check if a new object with same properties is in the visited set\nconsole.log('Found in visited set:', visitedUsers.has({ id: 1, name: 'Alice' }));"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What is the output of the following code that reads a large file using Node.js streams?",
      "options": {
        "A": "The code will process the entire file at once and then output the total number of lines",
        "B": "The code will output 'Processing chunk of size: X bytes' for each chunk and then the total line count",
        "C": "The code throws an error because Transform streams can't be used for line counting",
        "D": "The code will output nothing because no 'data' event listener is attached to the readStream"
      },
      "correct_answer": "B",
      "code_example": "const fs = require('fs');\nconst { Transform } = require('stream');\n\n// Create a file with sample content for this example\nfs.writeFileSync('large-file.txt', 'Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\n'.repeat(1000));\n\n// Create a transform stream to count lines\nclass LineCounter extends Transform {\n  constructor(options) {\n    super(options);\n    this.lineCount = 0;\n    this.remainder = '';\n  }\n  \n  _transform(chunk, encoding, callback) {\n    console.log(`Processing chunk of size: ${chunk.length} bytes`);\n    \n    // Convert Buffer to string and add remainder from previous chunk\n    const data = this.remainder + chunk.toString();\n    \n    // Split by newline character\n    const lines = data.split('\\n');\n    \n    // Save the last incomplete line for the next chunk\n    this.remainder = lines.pop();\n    \n    // Update line count\n    this.lineCount += lines.length;\n    \n    // Pass the chunk through unchanged\n    callback(null, chunk);\n  }\n  \n  _flush(callback) {\n    // Count the last line if it's not empty\n    if (this.remainder) {\n      this.lineCount++;\n    }\n    \n    console.log(`Total line count: ${this.lineCount}`);\n    callback();\n  }\n}\n\n// Create read stream for the large file\nconst readStream = fs.createReadStream('large-file.txt', {\n  highWaterMark: 1024 * 64 // 64KB chunks\n});\n\n// Pipe through the line counter and then to /dev/null (or nul on Windows)\nreadStream\n  .pipe(new LineCounter())\n  .pipe(fs.createWriteStream('/dev/null'));\n\n// Clean up the file after execution\nreadStream.on('end', () => {\n  fs.unlinkSync('large-file.txt');\n});"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "What will be the output when comparing passwords using bcrypt in the following code?",
      "options": {
        "A": "Password1 verification: true\nPassword2 verification: true",
        "B": "Password1 verification: true\nPassword2 verification: false",
        "C": "Password1 verification: false\nPassword2 verification: false",
        "D": "Error: bcrypt.hash() requires a callback function"
      },
      "correct_answer": "B",
      "code_example": "const bcrypt = require('bcrypt');\n\nasync function passwordDemo() {\n  const plainPassword = 'Secret123!';\n  const wrongPassword = 'Secret123';\n  \n  // Generate a hash with salt (automatically generated with cost factor 10)\n  const hash = await bcrypt.hash(plainPassword, 10);\n  \n  // Verify the correct password\n  const isPassword1Valid = await bcrypt.compare(plainPassword, hash);\n  console.log('Password1 verification:', isPassword1Valid);\n  \n  // Verify the wrong password\n  const isPassword2Valid = await bcrypt.compare(wrongPassword, hash);\n  console.log('Password2 verification:', isPassword2Valid);\n}\n\npasswordDemo().catch(err => console.error(err));"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What will be the output of this code that creates custom event listeners?",
      "options": {
        "A": "Connection opened\nMessage received: Hello\nError: Connection failed\nConnection closed",
        "B": "Connection opened\nMessage received: Hello\nConnection closed",
        "C": "Connection opened\nMessage received: Hello\nConnection closed\nConnection closed",
        "D": "Error: Maximum number of event listeners exceeded"
      },
      "correct_answer": "C",
      "code_example": "const EventEmitter = require('events');\n\nclass Connection extends EventEmitter {\n  constructor() {\n    super();\n    // Set maximum event listeners (default is 10)\n    this.setMaxListeners(5);\n  }\n  \n  connect() {\n    this.emit('open');\n    return this;\n  }\n  \n  send(message) {\n    this.emit('message', message);\n    return this;\n  }\n  \n  close() {\n    this.emit('close');\n    return this;\n  }\n}\n\n// Create a new connection\nconst connection = new Connection();\n\n// Add event listeners\nconnection.on('open', () => console.log('Connection opened'));\nconnection.on('message', (msg) => console.log('Message received:', msg));\nconnection.on('close', () => console.log('Connection closed'));\n\n// Add a duplicate listener for 'close' event\nconnection.on('close', () => console.log('Connection closed'));\n\n// Add a listener for an event that won't be emitted\nconnection.on('error', (err) => console.log('Error:', err));\n\n// Use the connection\nconnection\n  .connect()\n  .send('Hello')\n  .close();"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "What is the correct way to implement real-time data handling with streams in Node.js?",
      "options": {
        "A": "Use fs.readFile() and parse the entire file when data changes",
        "B": "Implement polling with setInterval() to check for new data",
        "C": "Use fs.watch() in combination with readable streams to process file changes",
        "D": "Use WebSockets to constantly request new data from the server"
      },
      "correct_answer": "C",
      "code_example": null
    }
  ]
}
