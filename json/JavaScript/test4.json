{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let arr = [1, 2, 3];\narr.push(4);\nconsole.log(arr.length);",
      "options": {
        "A": "3",
        "B": "4",
        "C": "5",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "Which of the following statements about the '===' operator is correct?",
      "options": {
        "A": "It converts operands to the same type before comparison",
        "B": "It only compares values, not types",
        "C": "It compares both value and type without conversion",
        "D": "It is the same as the '==' operator"
      },
      "correct_answer": "C"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be logged to the console?",
      "code_example": "console.log(null == undefined);",
      "options": {
        "A": "true",
        "B": "false",
        "C": "TypeError",
        "D": "undefined"
      },
      "correct_answer": "A"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "const arr = [10, 20, 30];\nconst newArr = arr.slice(1, 2);\nconsole.log(newArr);",
      "options": {
        "A": "[10]",
        "B": "[20]",
        "C": "[20, 30]",
        "D": "[10, 20]"
      },
      "correct_answer": "B"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What is the result of the following expression?",
      "code_example": "console.log(true && false || true);",
      "options": {
        "A": "true",
        "B": "false",
        "C": "undefined",
        "D": "TypeError"
      },
      "correct_answer": "A"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const obj = { a: 1, b: 2 };\ndelete obj.a;\nconsole.log(obj);",
      "options": {
        "A": "{ a: 1, b: 2 }",
        "B": "{ a: undefined, b: 2 }",
        "C": "{ b: 2 }",
        "D": "Error"
      },
      "correct_answer": "C"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "const numbers = [1, 4, 9];\nconst roots = numbers.map(Math.sqrt);\nconsole.log(roots);",
      "options": {
        "A": "[1, 2, 3]",
        "B": "[1, 4, 9]",
        "C": "[1, 16, 81]",
        "D": "TypeError"
      },
      "correct_answer": "A"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What is Node.js?",
      "options": {
        "A": "A JavaScript library for building user interfaces",
        "B": "A JavaScript runtime built on Chrome's V8 JavaScript engine",
        "C": "A new version of JavaScript with advanced features",
        "D": "A framework for building mobile applications"
      },
      "correct_answer": "B"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "Which method would you use to create and start a basic HTTP server in Node.js?",
      "code_example": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('Hello World');\n});\n\nserver.listen(3000, () => {\n  console.log('Server running at http://localhost:3000/');\n});",
      "options": {
        "A": "http.startServer()",
        "B": "http.makeServer()",
        "C": "http.createServer()",
        "D": "http.buildServer()"
      },
      "correct_answer": "C"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let i = 0;\nwhile (i < 3) {\n  console.log(i);\n  i++;\n}\nconsole.log('Final:', i);",
      "options": {
        "A": "0, 1, 2, Final: 3",
        "B": "0, 1, 2, Final: 2",
        "C": "0, 1, 2, 3, Final: 3",
        "D": "1, 2, 3, Final: 3"
      },
      "correct_answer": "A"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "function getFullName() {\n  console.log(arguments.length);\n}\n\ngetFullName('John', 'Doe');",
      "options": {
        "A": "undefined",
        "B": "0",
        "C": "1",
        "D": "2"
      },
      "correct_answer": "D"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function processData(callback) {\n  setTimeout(() => {\n    const data = 'Processed data';\n    callback(data);\n  }, 1000);\n}\n\nprocessData(function(result) {\n  console.log(result);\n});\n\nconsole.log('Waiting for data...');",
      "options": {
        "A": "Processed data, Waiting for data...",
        "B": "Waiting for data..., Processed data",
        "C": "Waiting for data...",
        "D": "Processed data"
      },
      "correct_answer": "B"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What is the value of x after the following operation?",
      "code_example": "let x = 5;\nlet y = 3;\nx &= y;\nconsole.log(x);",
      "options": {
        "A": "5",
        "B": "3",
        "C": "1",
        "D": "8"
      },
      "correct_answer": "C"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function greet(name = 'Guest') {\n  return `Hello, ${name}!`;\n}\n\nconsole.log(greet());",
      "options": {
        "A": "Hello, undefined!",
        "B": "Hello, !",
        "C": "Hello, Guest!",
        "D": "Error: Missing parameter"
      },
      "correct_answer": "C"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "Which of the following is NOT a reference type in JavaScript?",
      "options": {
        "A": "Object",
        "B": "Array",
        "C": "Number",
        "D": "RegExp"
      },
      "correct_answer": "C"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What will be logged to the console?",
      "code_example": "const promise = new Promise((resolve, reject) => {\n  resolve('Success!');\n});\n\npromise\n  .then(value => {\n    console.log(value);\n    return 'Next step';\n  })\n  .then(value => {\n    console.log(value);\n  });",
      "options": {
        "A": "Success! only",
        "B": "Next step only",
        "C": "Success! followed by Next step",
        "D": "Promise {<fulfilled>: 'Success!'}"
      },
      "correct_answer": "C"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "When using JWT tokens for authentication, which of the following is a security best practice?",
      "options": {
        "A": "Store the JWT secret in the client-side code",
        "B": "Include sensitive user data in the JWT payload",
        "C": "Set a reasonable expiration time for tokens",
        "D": "Use the same secret for all your applications"
      },
      "correct_answer": "C"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const fs = require('fs');\n\ntry {\n  const data = fs.readFileSync('nonexistent.txt', 'utf8');\n  console.log(data);\n} catch (err) {\n  console.log('Error reading file');\n} finally {\n  console.log('Operation attempted');\n}",
      "options": {
        "A": "Error reading file",
        "B": "Operation attempted",
        "C": "Error reading file, Operation attempted",
        "D": "ENOENT: no such file or directory"
      },
      "correct_answer": "C"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "In an Express application, how would you access a route parameter named 'userId' from the URL /users/:userId?",
      "code_example": "const express = require('express');\nconst app = express();\n\napp.get('/users/:userId', (req, res) => {\n  // How to access userId?\n});",
      "options": {
        "A": "req.userId",
        "B": "req.params.userId",
        "C": "req.query.userId",
        "D": "req.body.userId"
      },
      "correct_answer": "B"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "What is the primary purpose of debouncing a function?",
      "options": {
        "A": "To execute the function immediately on every event",
        "B": "To cancel a function execution if it's called again within a specified time period",
        "C": "To limit a function to executing at most once every N milliseconds",
        "D": "To increase the execution speed of a function"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What is the problem with the following code pattern and what is this pattern commonly called?",
      "code_example": "getData(function(a) {\n  getMoreData(a, function(b) {\n    getEvenMoreData(b, function(c) {\n      getYetEvenMoreData(c, function(d) {\n        getFinalData(d, function(finalData) {\n          console.log(finalData);\n        });\n      });\n    });\n  });\n});",
      "options": {
        "A": "Promise chaining - it's inefficient",
        "B": "Callback hell - it's hard to read and maintain",
        "C": "Event bubbling - it creates memory leaks",
        "D": "Function hoisting - it causes scope issues"
      },
      "correct_answer": "B"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "In Express, what is the purpose of the express.json() middleware?",
      "code_example": "const express = require('express');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/api/data', (req, res) => {\n  console.log(req.body);\n  res.json({ received: true });\n});",
      "options": {
        "A": "To serve JSON files from the server",
        "B": "To parse JSON data in request bodies",
        "C": "To validate JSON schemas",
        "D": "To convert all responses to JSON format"
      },
      "correct_answer": "B"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "When using the morgan middleware for logging in Express, what does the 'combined' format provide that the 'dev' format doesn't?",
      "options": {
        "A": "Color-coded status codes",
        "B": "Response time",
        "C": "IP address and detailed HTTP request information",
        "D": "Database query logs"
      },
      "correct_answer": "C"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function multiply(a, b = 1) {\n  return a * b;\n}\n\nfunction calculate(x, y = x) {\n  return multiply(x, y);\n}\n\nconsole.log(calculate(5));",
      "options": {
        "A": "5",
        "B": "6",
        "C": "10",
        "D": "25"
      },
      "correct_answer": "D"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "When connecting to MongoDB with Mongoose, what is the purpose of a schema?",
      "code_example": "const mongoose = require('mongoose');\n\nconst userSchema = new mongoose.Schema({\n  name: String,\n  email: { type: String, required: true, unique: true },\n  password: String,\n  createdAt: { type: Date, default: Date.now }\n});\n\nconst User = mongoose.model('User', userSchema);",
      "options": {
        "A": "To create indexes for faster queries",
        "B": "To define the structure and constraints for documents in a collection",
        "C": "To encrypt sensitive data before storage",
        "D": "To handle database connection pooling"
      },
      "correct_answer": "B"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What is the correct way to handle form data submitted via a POST request in Express?",
      "code_example": "const express = require('express');\nconst app = express();\n\n// Missing middleware\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  // Process login\n  res.send('Login processed');\n});",
      "options": {
        "A": "app.use(express.formdata())",
        "B": "app.use(express.urlencoded({ extended: true }))",
        "C": "app.use(express.bodyParser())",
        "D": "app.use(express.form())"
      },
      "correct_answer": "B"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "When working with large files in Node.js, which approach is most memory-efficient?",
      "options": {
        "A": "Using fs.readFile to load the entire file into memory",
        "B": "Using streams to process the file chunk by chunk",
        "C": "Using fs.readFileSync for synchronous processing",
        "D": "Loading the file in a worker thread"
      },
      "correct_answer": "B"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const buffer = Buffer.from('Hello World');\nconst sliced = buffer.slice(0, 5);\nsliced[0] = 74; // ASCII for 'J'\nconsole.log(buffer.toString());",
      "options": {
        "A": "Hello World",
        "B": "Jello World",
        "C": "J World",
        "D": "JelloWorld"
      },
      "correct_answer": "B"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What is the primary purpose of Helmet.js in an Express application?",
      "code_example": "const express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\napp.use(helmet());",
      "options": {
        "A": "To improve application performance",
        "B": "To encrypt database connections",
        "C": "To set security-related HTTP headers",
        "D": "To provide authentication mechanisms"
      },
      "correct_answer": "C"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "Which of the following is a best practice for API versioning in a Node.js application?",
      "options": {
        "A": "Include the version number directly in the endpoint URL (e.g., /api/v1/users)",
        "B": "Use different port numbers for different API versions",
        "C": "Include version information only in request bodies",
        "D": "Maintain only one version and force all clients to upgrade"
      },
      "correct_answer": "A"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will be the output of the following code showcasing closures?",
      "code_example": "function createCounter() {\n  let count = 0;\n  return function() {\n    count += 1;\n    return count;\n  };\n}\n\nconst counter1 = createCounter();\nconst counter2 = createCounter();\n\nconsole.log(counter1());\nconsole.log(counter1());\nconsole.log(counter2());\n",
      "options": {
        "A": "1, 1, 1",
        "B": "1, 2, 1",
        "C": "1, 2, 3",
        "D": "1, 1, 2"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "When using Sequelize with PostgreSQL, what is the purpose of the following code?",
      "code_example": "const { DataTypes } = require('sequelize');\n\nmodule.exports = (sequelize) => {\n  const User = sequelize.define('User', {\n    id: {\n      type: DataTypes.UUID,\n      defaultValue: DataTypes.UUIDV4,\n      primaryKey: true\n    },\n    name: DataTypes.STRING,\n    email: {\n      type: DataTypes.STRING,\n      unique: true,\n      allowNull: false\n    }\n  });\n  \n  return User;\n};",
      "options": {
        "A": "To connect to the PostgreSQL database",
        "B": "To define a model representing a 'users' table",
        "C": "To migrate database changes",
        "D": "To seed the database with initial data"
      },
      "correct_answer": "B"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What will be the output of the following WebSocket connection code?",
      "code_example": "const socket = require('socket.io-client')('http://localhost:3000');\n\nsocket.on('connect', () => {\n  console.log('Connection established');\n  \n  socket.emit('customEvent', { data: 'test' });\n  \n  socket.on('response', (data) => {\n    console.log(data.message);\n  });\n  \n  socket.on('disconnect', () => {\n    console.log('Disconnected from server');\n  });\n});\n\n// What is logged first after connection is established?",
      "options": {
        "A": "Connection established",
        "B": "test",
        "C": "Disconnected from server",
        "D": "Nothing is logged until the server responds"
      },
      "correct_answer": "A"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "Which statement about Just-In-Time (JIT) compilation in JavaScript is correct?",
      "options": {
        "A": "JIT compilation converts JavaScript directly to machine code without any intermediate bytecode",
        "B": "V8's JIT compiler optimizes frequently executed code paths while interpreting less frequent ones",
        "C": "JIT compilation in JavaScript happens before the code execution starts, similar to ahead-of-time compilation",
        "D": "JavaScript engines like V8 don't use JIT compilation at all, they only use interpretation"
      },
      "correct_answer": "B"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What will be the output of the following code demonstrating V8 engine optimizations?",
      "code_example": "function addNumbers(a, b) {\n  return a + b;\n}\n\n// Warm up the function with same-type arguments\nfor (let i = 0; i < 100000; i++) {\n  addNumbers(i, i + 1);\n}\n\n// Now call with different types\nconst result1 = addNumbers(5, 10);\nconst result2 = addNumbers('5', 10);\n\nconsole.log(result1, result2);",
      "options": {
        "A": "15 510",
        "B": "15 '510'",
        "C": "15 15",
        "D": "TypeError: Cannot optimize function with inconsistent argument types"
      },
      "correct_answer": "B"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "Which of the following correctly describes how JavaScript allocates memory for objects?",
      "options": {
        "A": "JavaScript allocates a fixed memory block for all objects, regardless of their properties",
        "B": "Objects are allocated on the stack, while primitives are allocated on the heap",
        "C": "Objects are allocated on the heap with a hidden class structure that V8 uses for property access optimization",
        "D": "JavaScript uses reference counting as its only mechanism for memory management of objects"
      },
      "correct_answer": "C"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "What will be the output of this code demonstrating hidden classes and inline caching?",
      "code_example": "function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nconst p1 = new Point(1, 2);\nconst p2 = new Point(3, 4);\n\n// Add a property to p1 but not p2\np1.z = 5;\n\nfunction getSum(point) {\n  return point.x + point.y + (point.z || 0);\n}\n\n// Call multiple times with p2 to optimize\nfor (let i = 0; i < 1000; i++) {\n  getSum(p2);\n}\n\nconsole.log(getSum(p1), getSum(p2));",
      "options": {
        "A": "8 7",
        "B": "3 7",
        "C": "8 NaN",
        "D": "TypeError: Cannot read property 'z' of undefined"
      },
      "correct_answer": "A"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "What is the primary difference between REST and GraphQL?",
      "options": {
        "A": "REST uses HTTP methods while GraphQL uses WebSockets exclusively",
        "B": "REST typically requires multiple endpoints for different resources, while GraphQL uses a single endpoint where clients specify exactly what data they need",
        "C": "REST provides real-time updates by default, while GraphQL requires polling",
        "D": "REST is asynchronous while GraphQL is synchronous by design"
      },
      "correct_answer": "B"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "What will be the output of this code that demonstrates memory leaks in closures?",
      "code_example": "let leaked = [];\n\nfunction leakMemory() {\n  const largeArray = new Array(1000000).fill('potentially leaked data');\n  \n  const innocent = () => {\n    console.log('Length:', largeArray.length);\n  };\n  \n  leaked.push(innocent);\n  \n  return 'Function completed';\n}\n\n// Call the function multiple times\nfor (let i = 0; i < 3; i++) {\n  console.log(leakMemory());\n}\n\n// Try to clean up\nlargeArray = null;\n\nconsole.log('Final leaked array length:', leaked.length);",
      "options": {
        "A": "ReferenceError: largeArray is not defined",
        "B": "Function completed, Function completed, Function completed, Final leaked array length: 0",
        "C": "Function completed, Function completed, Function completed, Final leaked array length: 3",
        "D": "ReferenceError: assignment to constant variable"
      },
      "correct_answer": "C"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "Which statement about implementing custom event listeners in JavaScript is correct?",
      "code_example": "class EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(listener);\n    return () => this.off(event, listener);\n  }\n\n  off(event, listener) {\n    if (!this.events[event]) return;\n    this.events[event] = this.events[event].filter(l => l !== listener);\n  }\n\n  emit(event, ...args) {\n    if (!this.events[event]) return;\n    this.events[event].forEach(listener => listener(...args));\n  }\n\n  once(event, listener) {\n    const remove = this.on(event, (...args) => {\n      remove();\n      listener(...args);\n    });\n  }\n}",
      "options": {
        "A": "The implementation has a memory leak because listeners are never properly removed",
        "B": "The 'once' method is incorrectly implemented as it will execute the listener multiple times",
        "C": "The implementation properly allows for removing event listeners using the return value from the 'on' method",
        "D": "The emit method should return a Promise to handle asynchronous listeners"
      },
      "correct_answer": "C"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What is the correct order of operations when setting up a WebSocket connection using socket.io?",
      "options": {
        "A": "1. Server emits 'connection' event, 2. Client calls connect(), 3. Client emits 'connect' event, 4. Server listens for custom events",
        "B": "1. Client calls connect(), 2. Server emits 'connection' event, 3. Client emits 'connect' event, 4. Both sides can now emit and listen for events",
        "C": "1. Server creates socket.io instance, 2. Client connects to server, 3. Server automatically assigns a unique ID, 4. Client must authenticate before emitting events",
        "D": "1. Client connects via HTTP, 2. Connection upgrades to WebSocket, 3. Client must emit 'handshake' event, 4. Server validates handshake before allowing further communication"
      },
      "correct_answer": "B"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "What will be the output of this code using worker threads in Node.js?",
      "code_example": "const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');\n\nif (isMainThread) {\n  const worker = new Worker(__filename, {\n    workerData: { value: 42 }\n  });\n  \n  worker.on('message', (result) => {\n    console.log('Worker result:', result);\n  });\n  \n  worker.on('error', (error) => {\n    console.error('Worker error:', error);\n  });\n  \n  worker.on('exit', (code) => {\n    console.log('Worker exited with code:', code);\n  });\n  \n  console.log('Main thread: Worker started');\n} else {\n  // This is executed in the worker thread\n  const result = workerData.value * 2;\n  parentPort.postMessage(result);\n  console.log('Worker thread: Calculation complete');\n}",
      "options": {
        "A": "Main thread: Worker started\nWorker result: 84\nWorker exited with code: 0",
        "B": "Main thread: Worker started\nWorker thread: Calculation complete\nWorker result: 84\nWorker exited with code: 0",
        "C": "Worker thread: Calculation complete\nMain thread: Worker started\nWorker result: 84\nWorker exited with code: 0",
        "D": "Main thread: Worker started\nWorker thread: Calculation complete\nWorker result: 84"
      },
      "correct_answer": "A"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What is the correct way to secure JWT secrets in a Node.js application?",
      "options": {
        "A": "Store the secret directly in the application code to ensure it can't be modified at runtime",
        "B": "Use environment variables and ensure they're not committed to version control, with different secrets for different environments",
        "C": "Store the secret in a plaintext configuration file that's committed to version control for easier deployment",
        "D": "Use the same secret across all environments to ensure tokens can be validated regardless of where they were issued"
      },
      "correct_answer": "B"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "What will be the output of this code showing how to handle real-time data with streams?",
      "code_example": "const fs = require('fs');\nconst { Transform } = require('stream');\n\n// Create a transform stream that converts data to uppercase\nconst uppercaseTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    this.push(chunk.toString().toUpperCase());\n    callback();\n  }\n});\n\n// Create a writable stream to count characters\nlet charCount = 0;\nconst countStream = new Transform({\n  transform(chunk, encoding, callback) {\n    charCount += chunk.length;\n    this.push(chunk);\n    callback();\n  },\n  flush(callback) {\n    console.log(`Total characters: ${charCount}`);\n    callback();\n  }\n});\n\n// Set up the pipeline\nconst sourceStream = fs.createReadStream(__filename, { highWaterMark: 1024 });\nconst output = sourceStream\n  .pipe(uppercaseTransform)\n  .pipe(countStream);\n\n// When the pipeline is complete\noutput.on('finish', () => {\n  console.log('Stream processing completed');\n});",
      "options": {
        "A": "It logs the total character count followed by 'Stream processing completed'",
        "B": "It transforms the file to uppercase but doesn't log anything",
        "C": "It throws an error because Transform streams require a 'readable' event handler",
        "D": "It logs 'Stream processing completed' followed by the total character count"
      },
      "correct_answer": "A"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "Which of the following is the correct way to implement refresh tokens alongside access tokens?",
      "options": {
        "A": "Store both access and refresh tokens in localStorage for persistence across page refreshes",
        "B": "Store the access token in memory or a JavaScript variable, and the refresh token in an HTTP-only cookie with secure and SameSite flags",
        "C": "Store both tokens in cookies, but make them accessible to JavaScript to facilitate automatic refresh",
        "D": "Encrypt both tokens on the client side before storage to prevent XSS attacks"
      },
      "correct_answer": "B"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "What will be the output of this code demonstrating how to prevent memory leaks in event listeners?",
      "code_example": "const EventEmitter = require('events');\n\nclass DataProcessor extends EventEmitter {\n  constructor() {\n    super();\n    this.data = [];\n    this.processCount = 0;\n  }\n  \n  addListener() {\n    // Add a listener to self\n    this.on('process', this.handleProcess);\n  }\n  \n  handleProcess() {\n    this.processCount++;\n    console.log(`Processing data: ${this.processCount}`);\n  }\n  \n  cleanUp() {\n    this.removeListener('process', this.handleProcess);\n  }\n}\n\nconst processor = new DataProcessor();\nprocessor.addListener();\n\n// Trigger event multiple times\nprocessor.emit('process');\nprocessor.emit('process');\n\n// Try to clean up\nprocessor.cleanUp();\n\n// Emit again after cleanup\nprocessor.emit('process');\n\nconsole.log('Final process count:', processor.processCount);",
      "options": {
        "A": "Processing data: 1\nProcessing data: 2\nFinal process count: 2",
        "B": "TypeError: Cannot read property 'processCount' of undefined",
        "C": "Processing data: 1\nProcessing data: 2\nProcessing data: 3\nFinal process count: 3",
        "D": "Processing data: NaN\nProcessing data: NaN\nFinal process count: 0"
      },
      "correct_answer": "C"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "Which of the following `docker-compose.yml` configurations correctly sets up a Node.js application with MongoDB and Redis services?",
      "code_example": "version: '3'\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=development\n      - MONGO_URI=mongodb://mongodb:27017/myapp\n      - REDIS_HOST=redis\n      - REDIS_PORT=6379\n    volumes:\n      - ./:/app\n    depends_on:\n      - mongodb\n      - redis\n\n  mongodb:\n    image: mongo:latest\n    ports:\n      - \"27017:27017\"\n    volumes:\n      - mongo-data:/data/db\n\n  redis:\n    image: redis:alpine\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis-data:/data\n\nvolumes:\n  mongo-data:\n  redis-data:",
      "options": {
        "A": "The configuration is incorrect because it's missing the 'restart' policy for the services",
        "B": "The configuration is incorrect because it doesn't specify container names",
        "C": "The configuration is correct and follows Docker Compose best practices",
        "D": "The configuration is incorrect because 'depends_on' doesn't guarantee that the dependent services are fully initialized"
      },
      "correct_answer": "C"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "What is the correct way to configure security headers like Referrer-Policy, X-Frame-Options, and X-Content-Type-Options in a Node.js Express application?",
      "code_example": "const express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// Configure security headers\napp.use(helmet());\n\n// Custom security headers\napp.use((req, res, next) => {\n  res.setHeader('X-Frame-Options', 'DENY');\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.setHeader('Referrer-Policy', 'no-referrer-when-downgrade');\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.send('Secure application');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
      "options": {
        "A": "The code is correct and provides proper security headers",
        "B": "The code is incorrect because helmet() already sets these headers and the custom middleware will cause conflicts",
        "C": "The code is incorrect because security headers should be set on a per-route basis, not globally",
        "D": "The code is incorrect because Express doesn't support custom security headers without a specialized middleware"
      },
      "correct_answer": "B"
    }
  ]
}
