{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const numbers = [1, 2, 3, 4, 5];\nnumbers.splice(2, 1);\nconsole.log(numbers);",
      "options": {
        "A": "[1, 2, 4, 5]",
        "B": "[1, 2, 3, 4]",
        "C": "[1, 3, 4, 5]",
        "D": "[1, 2, 3, 5]"
      },
      "correct_answer": "A"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What is the primary purpose of the 'event.preventDefault()' method in JavaScript?",
      "options": {
        "A": "To stop event propagation to parent elements",
        "B": "To prevent the browser from executing the default action of an element",
        "C": "To remove all event listeners from an element",
        "D": "To delay the execution of an event handler"
      },
      "correct_answer": "B"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "for (let i = 0; i < 5; i++) {\n  if (i === 2) continue;\n  if (i === 4) break;\n  console.log(i);\n}",
      "options": {
        "A": "0 1 2 3",
        "B": "0 1 3",
        "C": "0 1 3 4",
        "D": "1 2 3"
      },
      "correct_answer": "B"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const arr = [10, 20, 30, 40, 50];\nlet sum = 0;\narr.forEach((num, index) => {\n  if (index % 2 === 0) sum += num;\n});\nconsole.log(sum);",
      "options": {
        "A": "60",
        "B": "90",
        "C": "150",
        "D": "30"
      },
      "correct_answer": "B"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "Which of the following correctly describes a key difference between Node.js and browser JavaScript?",
      "options": {
        "A": "Node.js can't handle asynchronous operations",
        "B": "Browser JavaScript can directly access the file system",
        "C": "Node.js has direct access to the file system through the fs module",
        "D": "Browser JavaScript supports more ES6 features than Node.js"
      },
      "correct_answer": "C"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const person = { name: 'John', age: 30 };\nconst { name, job = 'Developer' } = person;\nconsole.log(name, job);",
      "options": {
        "A": "John undefined",
        "B": "John Developer",
        "C": "undefined Developer",
        "D": "John {}"
      },
      "correct_answer": "B"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const multiply = (a, b) => a * b;\nconst double = a => multiply(a, 2);\nconsole.log(double(5));",
      "options": {
        "A": "7",
        "B": "10",
        "C": "5",
        "D": "25"
      },
      "correct_answer": "B"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function test() {\n  var x = 1;\n  if (true) {\n    var x = 2;\n    console.log(x);\n  }\n  console.log(x);\n}\ntest();",
      "options": {
        "A": "1 then 2",
        "B": "2 then 1",
        "C": "2 then 2",
        "D": "1 then 1"
      },
      "correct_answer": "C"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const a = 5;\nconst b = 3;\nconsole.log(a & b);",
      "options": {
        "A": "7",
        "B": "8",
        "C": "1",
        "D": "2"
      },
      "correct_answer": "C"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const value = 8;\nconsole.log(value >> 1);",
      "options": {
        "A": "16",
        "B": "4",
        "C": "0",
        "D": "1"
      },
      "correct_answer": "B"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "Which method would you use to select the first element with the class 'item' in the DOM?",
      "options": {
        "A": "document.getElementByClass('item')",
        "B": "document.getElementByClassName('item')",
        "C": "document.querySelector('.item')",
        "D": "document.getElementsByClassName('item')[0]"
      },
      "correct_answer": "C"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let greeting;\nswitch (new Date().getDay()) {\n  case 6:\n    greeting = 'Saturday';\n    break;\n  case 0:\n    greeting = 'Sunday';\n    break;\n  default:\n    greeting = 'Weekday';\n}\nconsole.log('Today is a ' + greeting);",
      "options": {
        "A": "Today is a Saturday",
        "B": "Today is a Sunday",
        "C": "Today is a Weekday",
        "D": "The output depends on the current day"
      },
      "correct_answer": "D"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "Which of the following best describes Node.js?",
      "options": {
        "A": "A JavaScript framework for building user interfaces",
        "B": "A runtime environment that executes JavaScript outside the browser",
        "C": "A JavaScript library for DOM manipulation",
        "D": "A programming language that compiles to JavaScript"
      },
      "correct_answer": "B"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const obj = { name: 'Alice', greet() { return `Hello, ${this.name}!`; } };\nconsole.log(obj.greet());",
      "options": {
        "A": "Hello, Alice!",
        "B": "Hello, undefined!",
        "C": "Hello, ${this.name}!",
        "D": "Error: this.name is not defined"
      },
      "correct_answer": "A"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "Which method would you use to prevent an event from triggering its parent elements' event handlers?",
      "options": {
        "A": "event.preventDefault()",
        "B": "event.stopPropagation()",
        "C": "event.stopImmediatePropagation()",
        "D": "event.cancelBubble = true"
      },
      "correct_answer": "B"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What is the minimum code required to create a basic HTTP server in Node.js that responds with 'Hello World' on port 3000?",
      "code_example": "const http = require('http');\n\nconst server = http.createServer((req, res) => {\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello World');\n});\n\nserver.listen(3000);",
      "options": {
        "A": "The code is complete and correct",
        "B": "The code needs to import the 'express' module",
        "C": "The code is missing error handling",
        "D": "The code is missing a response status code"
      },
      "correct_answer": "A"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const data = { user: { name: { first: 'John', last: 'Doe' } } };\nconst { user: { name: { first } } } = data;\nconsole.log(first);",
      "options": {
        "A": "{ first: 'John', last: 'Doe' }",
        "B": "John",
        "C": "undefined",
        "D": "Error: Cannot destructure property 'name' of 'data.user' as it is undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function outer() {\n  const x = 10;\n  return function inner() {\n    console.log(x);\n  };\n}\n\nconst closureFn = outer();\nconst x = 20;\nclosureFn();",
      "options": {
        "A": "10",
        "B": "20",
        "C": "undefined",
        "D": "Error: x is not defined"
      },
      "correct_answer": "A"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const numbers = [1, 2, 3, 4, 5];\nconst [first, ...rest] = numbers;\nconsole.log(rest);",
      "options": {
        "A": "[1]",
        "B": "[2, 3, 4, 5]",
        "C": "4",
        "D": "[1, 2, 3, 4, 5]"
      },
      "correct_answer": "B"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "Which of the following is a correct way to handle CORS in an Express application?",
      "code_example": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\n// Configure CORS\napp.use(cors({\n  origin: 'https://example.com',\n  methods: ['GET', 'POST'],\n  allowedHeaders: ['Content-Type', 'Authorization']\n}));",
      "options": {
        "A": "The code is incorrect; CORS should be handled on the client side",
        "B": "The code is incomplete; it needs to specify the 'Access-Control-Allow-Origin' header manually",
        "C": "The code is correct and will enable CORS for requests from example.com",
        "D": "The code is incorrect; it should use app.set() instead of app.use()"
      },
      "correct_answer": "C"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const obj = {\n  name: 'Example',\n  method() {\n    console.log(this.name);\n  }\n};\n\nconst { method } = obj;\nmethod();",
      "options": {
        "A": "Example",
        "B": "undefined",
        "C": "null",
        "D": "Error: Cannot read property 'name' of undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What will be the output of the following code regarding the JavaScript Event Loop?",
      "code_example": "console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise');\n});\n\nconsole.log('End');",
      "options": {
        "A": "Start, Timeout, Promise, End",
        "B": "Start, End, Timeout, Promise",
        "C": "Start, End, Promise, Timeout",
        "D": "Start, Promise, End, Timeout"
      },
      "correct_answer": "C"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "Which of the following is the correct approach to define a MongoDB schema with validation for a user model that requires a name and email?",
      "code_example": "const mongoose = require('mongoose');\n\nconst userSchema = new mongoose.Schema({\n  name: { \n    type: String, \n    required: true \n  },\n  email: { \n    type: String, \n    required: true, \n    unique: true,\n    match: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n  },\n  createdAt: {\n    type: Date,\n    default: Date.now\n  }\n});\n\nconst User = mongoose.model('User', userSchema);\nmodule.exports = User;",
      "options": {
        "A": "The schema is incorrect; Mongoose doesn't support the match property for validation",
        "B": "The schema is correct and includes proper validation for name and email",
        "C": "The schema is incomplete; it's missing the validator middleware",
        "D": "The schema is incorrect; unique is not a validation rule in Mongoose"
      },
      "correct_answer": "B"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What is the purpose of the morgan middleware in Express applications?",
      "options": {
        "A": "To handle file uploads",
        "B": "To parse JSON request bodies",
        "C": "To log HTTP requests",
        "D": "To implement authentication"
      },
      "correct_answer": "C"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function processData(data) {\n  return new Promise((resolve, reject) => {\n    if (data) {\n      resolve(`Processed: ${data}`);\n    } else {\n      reject('No data provided');\n    }\n  });\n}\n\nprocessData(null)\n  .then(result => console.log(result))\n  .catch(error => console.log(`Error: ${error}`));",
      "options": {
        "A": "Processed: null",
        "B": "Error: null",
        "C": "Error: No data provided",
        "D": "The Promise will remain pending"
      },
      "correct_answer": "C"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const readable = require('stream').Readable;\n\nconst rs = new readable();\nrs._read = () => {};\n\nrs.push('Hello ');\nrs.push('World!');\nrs.push(null);\n\nrs.on('data', chunk => {\n  console.log('Chunk received:', chunk.toString());\n});",
      "options": {
        "A": "Chunk received: Hello World!",
        "B": "Chunk received: Hello \nChunk received: World!",
        "C": "Error: _read is not implemented",
        "D": "Nothing will be logged"
      },
      "correct_answer": "B"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What is the correct Express middleware syntax for handling file uploads with multer?",
      "code_example": "const express = require('express');\nconst multer = require('multer');\n\nconst app = express();\nconst upload = multer({ dest: 'uploads/' });\n\napp.post('/upload', upload.single('avatar'), (req, res) => {\n  res.json({ file: req.file });\n});",
      "options": {
        "A": "The code is incorrect; multer.single() requires a file size parameter",
        "B": "The code is correct for handling single file uploads",
        "C": "The code is incorrect; 'avatar' should be the destination path",
        "D": "The code is incomplete; it's missing the file type validation"
      },
      "correct_answer": "B"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "How would you implement API versioning in an Express application?",
      "options": {
        "A": "Use different port numbers for each API version",
        "B": "Use URL path prefixes like /v1/resource or /v2/resource",
        "C": "Include version numbers in the HTTP headers only",
        "D": "Store version numbers in cookies"
      },
      "correct_answer": "B"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What's the primary difference between classical inheritance and JavaScript's prototypal inheritance?",
      "options": {
        "A": "JavaScript does not support inheritance at all",
        "B": "Classical inheritance uses the 'extends' keyword while JavaScript uses 'prototype'",
        "C": "In classical inheritance, instances inherit from classes, while in JavaScript, objects inherit directly from other objects",
        "D": "Classical inheritance is faster than JavaScript's prototypal inheritance"
      },
      "correct_answer": "C"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "Which HTTP status code would be most appropriate to return when a user tries to access a resource they don't have permission for?",
      "options": {
        "A": "401 Unauthorized",
        "B": "403 Forbidden",
        "C": "404 Not Found",
        "D": "400 Bad Request"
      },
      "correct_answer": "B"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const obj1 = { a: 1, b: 2 };\nconst obj2 = { b: 3, c: 4 };\nconst merged = { ...obj1, ...obj2 };\nconsole.log(merged);",
      "options": {
        "A": "{ a: 1, b: 2, c: 4 }",
        "B": "{ a: 1, b: 3, c: 4 }",
        "C": "{ a: 1, b: [2, 3], c: 4 }",
        "D": "{ a: 1, b: 2, b: 3, c: 4 }"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What is the main purpose of using Helmet.js in a Node.js Express application?",
      "options": {
        "A": "To provide authentication middleware",
        "B": "To validate user input",
        "C": "To set various HTTP security headers",
        "D": "To compress HTTP responses"
      },
      "correct_answer": "C"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What will be the output of the following code that uses WeakMap for memory-sensitive caching?",
      "options": {
        "A": "{ name: 'John' } and { name: 'Jane' }",
        "B": "{ name: 'John' }",
        "C": "{ name: 'Jane' }",
        "D": "null"
      },
      "correct_answer": "C",
      "code_example": "let cache = new WeakMap();\n\nlet userJohn = { name: 'John' };\nlet userJane = { name: 'Jane' };\n\ncache.set(userJohn, 'user data for John');\ncache.set(userJane, 'user data for Jane');\n\n// Simulate memory cleanup for userJohn\nuserJohn = null;\n\n// Force garbage collection (note: this is just to illustrate the concept)\n// In real scenarios, you can't force garbage collection\n// global.gc && global.gc();\n\n// Log the keys (for demonstration purposes)\nconsole.log(userJane);\n"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "When implementing password hashing with bcrypt, what is the correct approach for securing user passwords in a Node.js application?",
      "options": {
        "A": "Store the plaintext password and hash it every time a user logs in for comparison",
        "B": "Store both the plaintext password and its hash for faster verification",
        "C": "Store the hash and a randomly generated salt, then compare hashes during login",
        "D": "Store just the hash without a salt and use a high work factor for security"
      },
      "correct_answer": "C"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What will be logged to the console when executing the following code that handles an unhandled Promise rejection?",
      "options": {
        "A": "Caught rejection: Error: Failed to fetch data",
        "B": "UnhandledPromiseRejectionWarning: Error: Failed to fetch data",
        "C": "The application will crash with no log output",
        "D": "Nothing will be logged"
      },
      "correct_answer": "A",
      "code_example": "// Set up global handler for unhandled rejections\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.log(`Caught rejection: ${reason}`);\n});\n\n// Create a rejected promise\nconst failedPromise = new Promise((resolve, reject) => {\n  reject(new Error('Failed to fetch data'));\n});\n\n// Not attaching any .catch() handler\n"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "In a docker-compose.yml file, which of the following configurations correctly sets up a Node.js application with a MongoDB database and appropriate environment variables?",
      "options": {
        "A": "version: '3'\nservices:\n  web:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n      - MONGO_URI=mongodb://database:27017/app\n  database:\n    image: mongo:latest\n    volumes:\n      - db_data:/data/db\nvolumes:\n  db_data:",
        "B": "version: '3'\nservices:\n  web:\n    build: .\n    ports:\n      - \"3000:3000\"\n    links:\n      - database\n    environment:\n      - NODE_ENV=production\n      - MONGO_URI=mongodb://localhost:27017/app\n  database:\n    image: mongo:latest",
        "C": "version: '3'\nservices:\n  web:\n    build: .\n    ports:\n      - \"3000:3000\"\n  database:\n    image: mongo:latest\n    environment:\n      - MONGO_INITDB_ROOT_USERNAME=admin\n      - MONGO_INITDB_ROOT_PASSWORD=password",
        "D": "version: '3'\nservices:\n  web:\n    name: node-app\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n  database:\n    name: mongodb\n    volumes:\n      - db_data:/data/db"
      },
      "correct_answer": "A"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "What is the output of this code that attempts to use Winston for logging?",
      "options": {
        "A": "Nothing, the code will throw an error",
        "B": "{\"level\":\"error\",\"message\":\"Database connection failed\"}",
        "C": "error: Database connection failed",
        "D": "Database connection failed"
      },
      "correct_answer": "C",
      "code_example": "const winston = require('winston');\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.simple(),\n  transports: [\n    new winston.transports.Console()\n  ]\n});\n\nlogger.error('Database connection failed');\n"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "Which of the following correctly describes the implementation differences between WebSockets, REST, and GraphQL?",
      "options": {
        "A": "REST uses HTTP verbs but maintains persistent connections; GraphQL uses a schema-based approach with stateful connections; WebSockets provide full-duplex communication but require complex queries",
        "B": "REST is stateless and uses HTTP verbs; GraphQL uses a single endpoint with a query language; WebSockets maintain a persistent, full-duplex connection",
        "C": "REST requires WebSocket connections; GraphQL works only with GET and POST methods; WebSockets communicate using JSON-RPC format only",
        "D": "REST follows a publish-subscribe model; GraphQL requires HTTP/2; WebSockets are primarily for static content delivery"
      },
      "correct_answer": "B"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "What will be the output when executing this code that demonstrates Node.js clustering?",
      "options": {
        "A": "Worker 1 started\nWorker 2 started\nWorker 3 started\nWorker 4 started",
        "B": "Primary process is running\nWorker 1 started\nWorker 2 started\nWorker 3 started\nWorker 4 started",
        "C": "An error will be thrown because cluster.fork() is called incorrectly",
        "D": "Only 'Primary process is running' will be logged once"
      },
      "correct_answer": "B",
      "code_example": "const cluster = require('cluster');\nconst os = require('os');\n\nif (cluster.isPrimary) {\n  console.log('Primary process is running');\n  \n  // Fork workers equal to CPU cores\n  const numCPUs = os.cpus().length;\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n} else {\n  console.log(`Worker ${cluster.worker.id} started`);\n  // Worker processes would run the actual server here\n}\n"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "Which of the following correctly describes the process of preventing CORS vulnerabilities in a Node.js Express application?",
      "options": {
        "A": "Set Access-Control-Allow-Origin to * for all routes to ensure maximum compatibility",
        "B": "Implement proper Access-Control-Allow-Origin headers with specific origins, and handle preflight OPTIONS requests with appropriate headers like Access-Control-Allow-Methods and Access-Control-Allow-Headers",
        "C": "Disable CORS entirely by removing all Access-Control headers from responses",
        "D": "Use JSONP callbacks for all API responses to bypass CORS restrictions entirely"
      },
      "correct_answer": "B"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What will be logged to the console in this code that uses WeakSet for memory management?",
      "options": {
        "A": "WeakSet contains user1: true\nWeakSet contains user2: true\nWeakSet contains user3: true",
        "B": "WeakSet contains user1: true\nWeakSet contains user2: true\nWeakSet contains user3: false",
        "C": "WeakSet contains user1: true\nWeakSet contains user2: false\nUser2 has been garbage collected",
        "D": "The code will throw an error because WeakSet doesn't have a .has() method"
      },
      "correct_answer": "B",
      "code_example": "// Create a WeakSet to track active user objects\nconst activeUsers = new WeakSet();\n\n// Create user objects\nlet user1 = { id: 1, name: 'Alice' };\nlet user2 = { id: 2, name: 'Bob' };\nconst user3 = { id: 3, name: 'Charlie' };\n\n// Add users to the active set\nactiveUsers.add(user1);\nactiveUsers.add(user2);\n\n// Check which users are in the set\nconsole.log(`WeakSet contains user1: ${activeUsers.has(user1)}`);\nconsole.log(`WeakSet contains user2: ${activeUsers.has(user2)}`);\nconsole.log(`WeakSet contains user3: ${activeUsers.has(user3)}`);\n\n// Note: In a real application, when user1 and user2 variables are no longer\n// referenced elsewhere, they would be eligible for garbage collection\n// and would automatically be removed from the WeakSet\n"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "When implementing OAuth using the Authorization Code flow with PKCE in a Node.js application, what is the correct sequence of steps?",
      "options": {
        "A": "1. Generate authorization URL with client_id, redirect_uri, and response_type=token\n2. User authenticates and authorizes the application\n3. Redirect back to the application with an access token in the URL fragment\n4. Use the access token to make API requests",
        "B": "1. Generate a code_verifier and its code_challenge\n2. Redirect to authorization endpoint with client_id, redirect_uri, code_challenge, and response_type=code\n3. Receive authorization code via redirect\n4. Exchange code and code_verifier for tokens at token endpoint\n5. Use the access token for API requests",
        "C": "1. Generate a code_challenge\n2. Redirect to authorization endpoint with client_id and code_challenge\n3. Receive access token and refresh token directly\n4. Store tokens securely\n5. Use the refresh token to periodically get new access tokens",
        "D": "1. Call the token endpoint with client_id and client_secret\n2. Receive an authorization code\n3. Redirect user to authorization server with the code\n4. User authenticates and approves access\n5. Receive and use access token"
      },
      "correct_answer": "B"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What will be the output of this code that demonstrates how refresh tokens and access tokens work together?",
      "options": {
        "A": "Initial access token: xyz123\nNew access token after refresh: abc456",
        "B": "Initial access token: xyz123\nRefresh token: refresh789\nNew access token after refresh: abc456",
        "C": "Error: Access token expired",
        "D": "Initial access token: xyz123\nAccess token expired. Getting new one...\nNew access token: abc456"
      },
      "correct_answer": "D",
      "code_example": "// Simulated token storage and authentication service\nconst tokenStore = {\n  accessToken: 'xyz123',\n  refreshToken: 'refresh789',\n  accessTokenExpiry: Date.now() - 1000 // Already expired\n};\n\n// Simulated function to check if access token is valid\nfunction isAccessTokenValid() {\n  return Date.now() < tokenStore.accessTokenExpiry;\n}\n\n// Simulated function to refresh the access token\nasync function refreshAccessToken() {\n  console.log('Access token expired. Getting new one...');\n  // In a real app, this would make an HTTP request to the auth server\n  return new Promise(resolve => {\n    // Simulate network delay\n    setTimeout(() => {\n      tokenStore.accessToken = 'abc456';\n      tokenStore.accessTokenExpiry = Date.now() + 3600000; // 1 hour from now\n      resolve(tokenStore.accessToken);\n    }, 100);\n  });\n}\n\n// Get a valid access token (refreshing if necessary)\nasync function getValidAccessToken() {\n  console.log(`Initial access token: ${tokenStore.accessToken}`);\n  \n  if (!isAccessTokenValid()) {\n    const newToken = await refreshAccessToken();\n    console.log(`New access token: ${newToken}`);\n    return newToken;\n  }\n  \n  return tokenStore.accessToken;\n}\n\n// Execute the function\ngetValidAccessToken();\n"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "Which of the following is the most effective way to protect against Cross-Site Request Forgery (CSRF) attacks in a Node.js Express application?",
      "options": {
        "A": "Rely solely on using HTTPS for all requests to prevent man-in-the-middle attacks",
        "B": "Use the 'X-Requested-With' header to verify that requests come from the expected source",
        "C": "Implement a combination of CSRF tokens, SameSite cookies, and proper Content-Type checking for state-changing operations",
        "D": "Store session information exclusively in localStorage to prevent cross-domain cookie access"
      },
      "correct_answer": "C"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What is the output of this code that demonstrates encrypting sensitive data in Node.js?",
      "options": {
        "A": "Original: secret message\nEncrypted: <Buffer data>\nDecrypted: secret message",
        "B": "TypeError: crypto.createCipher is deprecated",
        "C": "Original: secret message\nEncrypted: 8f7e9a6b5c4d3e2f1a0b\nDecrypted: secret message",
        "D": "The code will run but produce inconsistent results due to missing initialization vector"
      },
      "correct_answer": "B",
      "code_example": "const crypto = require('crypto');\n\nfunction encryptData(data, secretKey) {\n  // Using deprecated method for demonstration\n  const cipher = crypto.createCipher('aes-256-cbc', secretKey);\n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return encrypted;\n}\n\nfunction decryptData(encryptedData, secretKey) {\n  // Using deprecated method for demonstration\n  const decipher = crypto.createDecipher('aes-256-cbc', secretKey);\n  let decrypted = decipher.update(encryptedData, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n}\n\nconst secretKey = 'my-secret-key-123';\nconst originalData = 'secret message';\n\nconsole.log(`Original: ${originalData}`);\nconst encrypted = encryptData(originalData, secretKey);\nconsole.log(`Encrypted: ${encrypted}`);\nconst decrypted = decryptData(encrypted, secretKey);\nconsole.log(`Decrypted: ${decrypted}`);\n"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "Which of the following is the correct Dockerfile for a production-ready Node.js application that follows security best practices?",
      "options": {
        "A": "FROM node:latest\nWORKDIR /app\nCOPY . .\nRUN npm install\nEXPOSE 3000\nCMD [\"node\", \"app.js\"]",
        "B": "FROM node:18-alpine\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\nCOPY . .\nUSER node\nEXPOSE 3000\nCMD [\"node\", \"app.js\"]",
        "C": "FROM node:18\nWORKDIR /app\nCOPY . .\nRUN npm install\nEXPOSE 3000\nCMD [\"npm\", \"start\"]",
        "D": "FROM ubuntu:latest\nRUN apt-get update && apt-get install -y nodejs npm\nWORKDIR /app\nCOPY . .\nRUN npm install\nEXPOSE 3000\nCMD node app.js"
      },
      "correct_answer": "B"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What will be the output of this code that attempts to use PM2 for load balancing?",
      "options": {
        "A": "The code will throw an error because PM2 can't be programmatically controlled this way",
        "B": "Starting server in cluster mode with 4 instances",
        "C": "Process 0 has been started in fork mode\nProcess 1 has been started in fork mode\nProcess 2 has been started in fork mode\nProcess 3 has been started in fork mode",
        "D": "PM2 started with 4 worker processes"
      },
      "correct_answer": "A",
      "code_example": "// Attempt to programmatically control PM2 (this is not how PM2 is typically used)\nconst pm2 = require('pm2');\nconst numCPUs = require('os').cpus().length;\n\n// Connect to PM2\npm2.connect((err) => {\n  if (err) {\n    console.error(err);\n    process.exit(2);\n  }\n  \n  // Start a new process with the current file\n  pm2.start({\n    script: 'server.js',\n    instances: numCPUs,\n    exec_mode: 'cluster'\n  }, (err, apps) => {\n    if (err) throw err;\n    console.log(`Starting server in cluster mode with ${numCPUs} instances`);\n    pm2.disconnect();\n  });\n});\n"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "When deploying a Node.js application, what is the key difference between Heroku, Vercel, and DigitalOcean approaches?",
      "options": {
        "A": "Heroku requires a Dockerfile for all deployments; Vercel only supports static websites; DigitalOcean can only deploy using Kubernetes",
        "B": "Heroku uses a git-based workflow with buildpacks and dynos; Vercel specializes in serverless deployments with focus on frontend frameworks; DigitalOcean provides virtual machines or Kubernetes clusters requiring more configuration",
        "C": "Heroku is only for Ruby applications; Vercel only supports Next.js; DigitalOcean is strictly for database hosting",
        "D": "All three platforms are identical in their deployment approach but differ only in pricing models"
      },
      "correct_answer": "B"
    }
  ]
}
