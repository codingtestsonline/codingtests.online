{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled);",
      "options": {
        "A": "[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]",
        "B": "[1, 4, 9, 16, 25]",
        "C": "[2, 4, 6, 8, 10]",
        "D": "[undefined, undefined, undefined, undefined, undefined]"
      },
      "correct_answer": "C"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "Which method would you use to select the first element with the class 'user-profile' in the document?",
      "options": {
        "A": "document.getElementByClass('user-profile')",
        "B": "document.querySelector('.user-profile')",
        "C": "document.getElementById('user-profile')",
        "D": "document.getElementsByClassName('user-profile')[0]"
      },
      "correct_answer": "B"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const age = 17;\nconst message = age >= 18 ? 'You can vote!' : 'Too young to vote.';\nconsole.log(message);",
      "options": {
        "A": "You can vote!",
        "B": "Too young to vote.",
        "C": "undefined",
        "D": "false"
      },
      "correct_answer": "B"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "Which of the following is NOT available in Node.js but is available in browser JavaScript?",
      "options": {
        "A": "setTimeout()",
        "B": "console.log()",
        "C": "document.querySelector()",
        "D": "JSON.parse()"
      },
      "correct_answer": "C"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What is the difference between textContent and innerHTML when changing content?",
      "options": {
        "A": "innerHTML parses HTML, textContent treats everything as plain text",
        "B": "textContent parses HTML, innerHTML treats everything as plain text",
        "C": "innerHTML is faster than textContent in all cases",
        "D": "There is no difference, they can be used interchangeably"
      },
      "correct_answer": "A"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code in a Node.js environment?",
      "code_example": "process.env.API_KEY = 'secret123';\nconsole.log(process.env.API_KEY);",
      "options": {
        "A": "undefined",
        "B": "null",
        "C": "secret123",
        "D": "Error: process is not defined"
      },
      "correct_answer": "C"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "var x = 1;\nlet y = 2;\nconst z = 3;\n\n{\n  var x = 10;\n  let y = 20;\n  const z = 30;\n}\n\nconsole.log(x, y, z);",
      "options": {
        "A": "1 2 3",
        "B": "10 2 3",
        "C": "10 20 30",
        "D": "1 20 30"
      },
      "correct_answer": "B"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function outer() {\n  var a = 10;\n  function inner() {\n    console.log(a);\n  }\n  inner();\n}\nouter();",
      "options": {
        "A": "undefined",
        "B": "null",
        "C": "10",
        "D": "ReferenceError: a is not defined"
      },
      "correct_answer": "C"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let num = 5;\nnum += 3;\nnum *= 2;\nconsole.log(num);",
      "options": {
        "A": "5",
        "B": "8",
        "C": "13",
        "D": "16"
      },
      "correct_answer": "D"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "Which of the following is NOT a primitive type in JavaScript?",
      "options": {
        "A": "string",
        "B": "object",
        "C": "bigint",
        "D": "symbol"
      },
      "correct_answer": "B"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function fetchData(callback) {\n  setTimeout(() => {\n    callback('Data received');\n  }, 1000);\n}\n\nfetchData(function(data) {\n  console.log(data);\n});\n\nconsole.log('Waiting for data...');",
      "options": {
        "A": "Data received Waiting for data...",
        "B": "Waiting for data... Data received",
        "C": "Waiting for data...",
        "D": "Data received"
      },
      "correct_answer": "B"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const fruits = ['apple', 'banana'];\nfruits.push('orange');\nfruits.unshift('grape');\nfruits.pop();\nconsole.log(fruits);",
      "options": {
        "A": "['apple', 'banana', 'orange']",
        "B": "['grape', 'apple', 'banana']",
        "C": "['grape', 'apple', 'banana', 'orange']",
        "D": "['grape', 'orange']"
      },
      "correct_answer": "B"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const person = { name: 'John', age: 30, city: 'New York' };\nconst { name, age } = person;\nconsole.log(name, age);",
      "options": {
        "A": "undefined undefined",
        "B": "John 30",
        "C": "{ name: 'John', age: 30 }",
        "D": "John New York"
      },
      "correct_answer": "B"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "In Node.js, which module is used to interact with the file system?",
      "options": {
        "A": "http",
        "B": "path",
        "C": "fs",
        "D": "file"
      },
      "correct_answer": "C"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "sayHello();\n\nfunction sayHello() {\n  console.log('Hello');\n}\n\nsayBye();\n\nvar sayBye = function() {\n  console.log('Bye');\n};",
      "options": {
        "A": "Hello Bye",
        "B": "Hello TypeError: sayBye is not a function",
        "C": "TypeError: sayHello is not a function TypeError: sayBye is not a function",
        "D": "undefined undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const car = {\n  brand: 'Toyota',\n  model: 'Corolla',\n  start: function() {\n    return `Starting ${this.brand} ${this.model}`;\n  }\n};\n\nconsole.log(car.start());",
      "options": {
        "A": "Starting Toyota Corolla",
        "B": "Starting undefined undefined",
        "C": "TypeError: this.brand is not defined",
        "D": "function() { return `Starting ${this.brand} ${this.model}`; }"
      },
      "correct_answer": "A"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const user = {\n  name: 'John',\n  address: null\n};\n\nconst city = user.address?.city;\nconsole.log(city);",
      "options": {
        "A": "null",
        "B": "undefined",
        "C": "TypeError: Cannot read property 'city' of null",
        "D": "''"
      },
      "correct_answer": "B"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "Which attribute would you use to implement lazy loading for an image in modern browsers?",
      "options": {
        "A": "data-src",
        "B": "lazy",
        "C": "loading='lazy'",
        "D": "defer"
      },
      "correct_answer": "C"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const id1 = Symbol('id');\nconst id2 = Symbol('id');\n\nconst obj = {\n  [id1]: 'value1',\n  [id2]: 'value2'\n};\n\nconsole.log(obj[id1] === obj[id2]);",
      "options": {
        "A": "true",
        "B": "false",
        "C": "TypeError",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "Which of the following causes the most DOM reflows?",
      "options": {
        "A": "Changing an element's color",
        "B": "Reading element.offsetHeight multiple times",
        "C": "Modifying classList on multiple elements individually",
        "D": "Using document.createDocumentFragment() for batch updates"
      },
      "correct_answer": "C"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "Which of the following helps prevent memory leaks in JavaScript?",
      "options": {
        "A": "Using var instead of let for all variables",
        "B": "Properly removing event listeners when components are destroyed",
        "C": "Avoiding asynchronous operations",
        "D": "Always using function declarations instead of arrow functions"
      },
      "correct_answer": "B"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "Which of the following is a best practice for securing JWT tokens in a Node.js application?",
      "options": {
        "A": "Store the token in localStorage for easy access",
        "B": "Use short expiration times and implement refresh token rotation",
        "C": "Store sensitive user data in the JWT payload",
        "D": "Use the same secret key for all of your applications"
      },
      "correct_answer": "B"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What is the best practice for API versioning in a RESTful Express application?",
      "options": {
        "A": "Include version in the URL path (e.g., /api/v1/users)",
        "B": "Use query parameters (e.g., /api/users?version=1)",
        "C": "Use custom HTTP headers (e.g., Accept-Version: 1.0)",
        "D": "All of the above are equally recommended approaches"
      },
      "correct_answer": "A"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What is the most efficient way to handle large file uploads in a Node.js application?",
      "code_example": "// Option A\napp.use(express.json({ limit: '50mb' }));\n\n// Option B\nconst multer = require('multer');\nconst upload = multer({ dest: 'uploads/' });\napp.post('/upload', upload.single('file'), (req, res) => {\n  // Handle file\n});\n\n// Option C\napp.post('/upload', (req, res) => {\n  let data = '';\n  req.on('data', chunk => { data += chunk });\n  req.on('end', () => {\n    // Process complete data\n  });\n});\n\n// Option D\napp.post('/upload', express.raw({ limit: '50mb' }), (req, res) => {\n  // Handle req.body as Buffer\n});",
      "options": {
        "A": "Option A: Use express.json with a high limit",
        "B": "Option B: Use multer to stream file to disk",
        "C": "Option C: Manually concatenate data in memory",
        "D": "Option D: Use express.raw with a high limit"
      },
      "correct_answer": "B"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "When using Helmet.js in an Express application, which security header is NOT set by default?",
      "options": {
        "A": "Content-Security-Policy",
        "B": "X-XSS-Protection",
        "C": "Strict-Transport-Security",
        "D": "X-Powered-By"
      },
      "correct_answer": "A"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What will be the output of the following authentication code?",
      "code_example": "const jwt = require('jsonwebtoken');\n\nfunction verifyToken(token, secret) {\n  try {\n    const decoded = jwt.verify(token, secret);\n    return { valid: true, data: decoded };\n  } catch (err) {\n    return { valid: false, error: err.message };\n  }\n}\n\nconst token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMywiaWF0IjoxNTE2MjM5MDIyfQ.invalid_signature';\nconst result = verifyToken(token, 'wrong_secret');\nconsole.log(result.valid, result.error);",
      "options": {
        "A": "true undefined",
        "B": "false 'jwt malformed'",
        "C": "false 'invalid signature'",
        "D": "TypeError: jwt.verify is not a function"
      },
      "correct_answer": "C"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will be the output of the following code demonstrating first-class functions?",
      "code_example": "function multiplier(factor) {\n  return function(number) {\n    return number * factor;\n  };\n}\n\nconst double = multiplier(2);\nconst triple = multiplier(3);\n\nconsole.log(double(5) + triple(5));",
      "options": {
        "A": "10",
        "B": "15",
        "C": "25",
        "D": "30"
      },
      "correct_answer": "C"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What will be the output of the following code using spread and rest operators?",
      "code_example": "function sum(...numbers) {\n  return numbers.reduce((total, num) => total + num, 0);\n}\n\nconst numbers = [1, 2, 3];\nconst moreNumbers = [4, 5];\n\nconsole.log(sum(...numbers, ...moreNumbers));",
      "options": {
        "A": "[1, 2, 3, 4, 5]",
        "B": "Error: Cannot spread non-iterable object",
        "C": "15",
        "D": "0"
      },
      "correct_answer": "C"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function greet(name, greeting = 'Hello', punctuation = '!') {\n  return `${greeting}, ${name}${punctuation}`;\n}\n\nconsole.log(greet('World'));\nconsole.log(greet('Friends', 'Welcome'));\nconsole.log(greet('Team', undefined, '?'));",
      "options": {
        "A": "Hello, World! Welcome, Friends! Hello, Team?",
        "B": "Hello, World! Welcome, Friends! undefined, Team?",
        "C": "undefined, World! Welcome, Friends! Hello, Team?",
        "D": "Hello, World! Welcome, Friends! Welcome, Team?"
      },
      "correct_answer": "A"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What will be the output when creating a simple Express server?",
      "code_example": "const express = require('express');\nconst app = express();\n\napp.get('/api/greeting', (req, res) => {\n  const name = req.query.name || 'Guest';\n  res.json({ message: `Hello, ${name}!` });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\n\n// What would be returned from GET /api/greeting?",
      "options": {
        "A": "Hello, Guest!",
        "B": "{ message: 'Hello, Guest!' }",
        "C": "{ \"message\": \"Hello, Guest!\" }",
        "D": "Error: No name parameter provided"
      },
      "correct_answer": "C"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What is the correct way to create a readable stream from a file in Node.js?",
      "code_example": "const fs = require('fs');\n\n// Option A\nconst readStream1 = fs.createReadStream('file.txt');\n\n// Option B\nconst readStream2 = new fs.ReadStream('file.txt');\n\n// Option C\nconst readStream3 = fs.readFile('file.txt', (err, data) => data);\n\n// Option D\nconst readStream4 = new Buffer(fs.readFileSync('file.txt'));",
      "options": {
        "A": "Option A",
        "B": "Option B",
        "C": "Option C",
        "D": "Option D"
      },
      "correct_answer": "A"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What will be the output of the following Express code handling form data?",
      "code_example": "const express = require('express');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/submit-form', (req, res) => {\n  console.log(typeof req.body);\n  console.log(req.body.username);\n});\n\n// Assuming a form with <input name=\"username\" value=\"john_doe\"> is submitted",
      "options": {
        "A": "string john_doe",
        "B": "object undefined",
        "C": "object john_doe",
        "D": "undefined undefined"
      },
      "correct_answer": "C"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What will be the result of running the following code which attempts to implement refresh token rotation?",
      "options": {
        "A": "The new refresh token will be ignored, creating a security vulnerability",
        "B": "A ReferenceError will be thrown because refreshTokens is not defined",
        "C": "The old refresh token will be securely invalidated, and only the new one will work",
        "D": "Both tokens will remain valid indefinitely, potentially causing a token leak"
      },
      "correct_answer": "A",
      "code_example": "async function handleTokenRefresh(req, res) {\n  const { refreshToken } = req.body;\n  \n  try {\n    // Verify the provided refresh token\n    const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);\n    \n    // Generate new tokens\n    const accessToken = generateAccessToken(decoded.userId);\n    const newRefreshToken = generateRefreshToken(decoded.userId);\n    \n    // Send new tokens to client\n    res.json({ accessToken, refreshToken: newRefreshToken });\n  } catch (error) {\n    res.status(401).json({ error: 'Invalid refresh token' });\n  }\n}"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "Which of the following is the MOST secure implementation of Cross-Site Scripting (XSS) prevention in a React application?",
      "options": {
        "A": "Using dangerouslySetInnerHTML with user input after sanitizing it with a custom regex",
        "B": "Using a library like DOMPurify to sanitize user input before rendering it with dangerouslySetInnerHTML",
        "C": "Encoding all special characters in user input using encodeURIComponent before rendering",
        "D": "Using React's built-in JSX escaping and avoiding dangerouslySetInnerHTML entirely for user-generated content"
      },
      "correct_answer": "D"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What will be the output of the following code that reads a large file using streams?",
      "options": {
        "A": "It will throw a memory error because the highWaterMark is too small",
        "B": "It will output the number of chunks processed and the total byte count",
        "C": "It will output only the first 1024 bytes of the file",
        "D": "It will throw an error because createReadStream requires an absolute path"
      },
      "correct_answer": "B",
      "code_example": "const fs = require('fs');\nconst path = require('path');\n\nfunction processLargeFile(filePath) {\n  const readStream = fs.createReadStream(filePath, { highWaterMark: 64 * 1024 });\n  let chunkCount = 0;\n  let totalBytes = 0;\n  \n  readStream.on('data', (chunk) => {\n    chunkCount++;\n    totalBytes += chunk.length;\n  });\n  \n  readStream.on('end', () => {\n    console.log(`Processed ${chunkCount} chunks for a total of ${totalBytes} bytes`);\n  });\n  \n  readStream.on('error', (err) => {\n    console.error('Error reading file:', err);\n  });\n}\n\nprocessLargeFile('./large-file.txt');"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "What is the expected behavior of the following clustering code on a system with 8 CPU cores?",
      "options": {
        "A": "It will create 7 worker processes, for a total of 8 processes including the master",
        "B": "It will create 8 worker processes, for a total of 9 processes including the master",
        "C": "It will create exactly 8 worker processes, regardless of CPU count",
        "D": "It will throw an error because the worker creation condition is never met"
      },
      "correct_answer": "A",
      "code_example": "const cluster = require('cluster');\nconst os = require('os');\nconst http = require('http');\n\nif (cluster.isMaster) {\n  const cpuCount = os.cpus().length;\n  \n  console.log(`Master process running on PID ${process.pid}`);\n  console.log(`Starting ${cpuCount - 1} workers...`);\n  \n  for (let i = 0; i < cpuCount - 1; i++) {\n    cluster.fork();\n  }\n  \n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died. Restarting...`);\n    cluster.fork();\n  });\n} else {\n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end('Hello from worker\\n');\n  }).listen(8000);\n  \n  console.log(`Worker ${process.pid} started`);\n}"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "What will be the output of this Transform stream that attempts to convert CSV data to JSON?",
      "options": {
        "A": "A JSON array with each object containing 'id' and 'value' properties",
        "B": "A parsing error because the header row isn't properly handled",
        "C": "An array of raw CSV strings because _transform doesn't modify the chunks",
        "D": "A JSON array with an extra empty object at the beginning"
      },
      "correct_answer": "D",
      "code_example": "const { Transform } = require('stream');\n\nclass CsvToJsonTransform extends Transform {\n  constructor(options) {\n    super({ ...options, objectMode: true });\n    this.headers = null;\n    this.buffer = '';\n  }\n  \n  _transform(chunk, encoding, callback) {\n    // Append chunk to buffer and split by newlines\n    this.buffer += chunk.toString();\n    const lines = this.buffer.split('\\n');\n    \n    // Keep the last partial line in the buffer\n    this.buffer = lines.pop();\n    \n    // Process lines\n    for (const line of lines) {\n      const values = line.split(',');\n      \n      if (!this.headers) {\n        this.headers = values;\n        this.push({});\n      } else {\n        const obj = {};\n        this.headers.forEach((header, index) => {\n          obj[header] = values[index];\n        });\n        this.push(obj);\n      }\n    }\n    \n    callback();\n  }\n  \n  _flush(callback) {\n    // Process any remaining data in buffer\n    if (this.buffer.length > 0) {\n      const values = this.buffer.split(',');\n      const obj = {};\n      this.headers.forEach((header, index) => {\n        obj[header] = values[index];\n      });\n      this.push(obj);\n    }\n    callback();\n  }\n}\n\n// Usage would be: readStream.pipe(new CsvToJsonTransform()).pipe(writeStream);"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "What is the critical limitation of the following rate limiter implementation?",
      "options": {
        "A": "It doesn't differentiate between users with different privilege levels",
        "B": "It will fail in a multi-server environment as the state is stored in memory",
        "C": "The error status code 429 should be 403 for rate limit errors",
        "D": "The windowMs value is too low for a production environment"
      },
      "correct_answer": "B",
      "code_example": "const rateLimit = require('express-rate-limit');\nconst express = require('express');\nconst app = express();\n\n// Create API limiter\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers\n  legacyHeaders: false, // Disable the `X-RateLimit-*` headers\n  message: {\n    status: 429,\n    message: 'Too many requests, please try again later.'\n  }\n});\n\n// Apply rate limiting to API routes\napp.use('/api/', apiLimiter);\n\n// Apply a stricter limit to authentication endpoints\nconst authLimiter = rateLimit({\n  windowMs: 60 * 60 * 1000, // 1 hour\n  max: 5, // 5 attempts per hour\n  message: {\n    status: 429,\n    message: 'Too many login attempts, please try again later.'\n  }\n});\n\napp.use('/api/auth/login', authLimiter);\napp.use('/api/auth/register', authLimiter);"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "Which of the following V8 engine optimizations would MOST significantly improve the performance of this function?",
      "options": {
        "A": "Using typed arrays instead of standard arrays",
        "B": "Avoiding the use of try-catch blocks for performance-critical paths",
        "C": "Ensuring the function is monomorphic by always passing objects with the same structure",
        "D": "Replacing anonymous functions with named function expressions"
      },
      "correct_answer": "C",
      "code_example": "function processData(items) {\n  let result = 0;\n  \n  for (let i = 0; i < items.length; i++) {\n    try {\n      // The property access pattern varies based on input\n      if (items[i].value) {\n        result += items[i].value;\n      } else if (items[i].data && items[i].data.value) {\n        result += items[i].data.value;\n      } else if (items[i].metadata && items[i].metadata.value) {\n        result += items[i].metadata.value;\n      }\n    } catch (err) {\n      console.error('Error processing item:', err);\n    }\n  }\n  \n  return result;\n}"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "What is the MOST significant advantage of the following PM2 ecosystem.config.js configuration for load balancing?",
      "options": {
        "A": "It reduces memory usage by sharing the same Node.js instance across all applications",
        "B": "It guarantees zero-downtime deployments with the reload strategy",
        "C": "It allows for targeted scaling of specific microservices based on their individual demand",
        "D": "It provides automatic database connection pooling through the instances configuration"
      },
      "correct_answer": "C",
      "code_example": "module.exports = {\n  apps: [\n    {\n      name: 'api-gateway',\n      script: './api-gateway/server.js',\n      instances: 2,\n      exec_mode: 'cluster',\n      watch: false,\n      max_memory_restart: '300M',\n      env: {\n        NODE_ENV: 'production',\n        PORT: 3000\n      }\n    },\n    {\n      name: 'auth-service',\n      script: './auth-service/index.js',\n      instances: 2,\n      exec_mode: 'cluster',\n      watch: false,\n      max_memory_restart: '200M',\n      env: {\n        NODE_ENV: 'production',\n        PORT: 3001\n      }\n    },\n    {\n      name: 'payment-processor',\n      script: './payment-service/app.js',\n      instances: 4,\n      exec_mode: 'cluster',\n      watch: false,\n      max_memory_restart: '500M',\n      env: {\n        NODE_ENV: 'production',\n        PORT: 3002\n      }\n    },\n    {\n      name: 'notification-service',\n      script: './notification-service/server.js',\n      instances: 1,\n      exec_mode: 'fork',\n      watch: false,\n      max_memory_restart: '150M',\n      env: {\n        NODE_ENV: 'production',\n        PORT: 3003\n      }\n    }\n  ]\n};"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What CORS vulnerability is still present in the following Express.js middleware configuration?",
      "options": {
        "A": "It doesn't use a whitelist for 'Access-Control-Allow-Origin' and allows any origin",
        "B": "It sets 'credentials: true' without restricting the list of allowed origins",
        "C": "It doesn't implement preflight request handling correctly",
        "D": "It allows all HTTP methods without restriction, which can lead to CSRF attacks"
      },
      "correct_answer": "B",
      "code_example": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\n// CORS middleware configuration\nconst corsOptions = {\n  origin: function (origin, callback) {\n    const allowedOrigins = [\n      'https://myapp.com',\n      'https://admin.myapp.com',\n      'https://api.myapp.com'\n    ];\n    \n    // Allow requests with no origin (like mobile apps or curl requests)\n    if (!origin) return callback(null, true);\n    \n    if (allowedOrigins.indexOf(origin) !== -1) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],\n  credentials: true,\n  maxAge: 86400 // 24 hours\n};\n\napp.use(cors(corsOptions));"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "What will be the primary issue with the following docker-compose.yml configuration when scaling the application?",
      "options": {
        "A": "The MongoDB container will become a bottleneck as it's not configured for replica sets",
        "B": "The Redis container lacks persistence configuration, risking data loss on container restart",
        "C": "The backend service has no health check defined, which may lead to failed deployments",
        "D": "Environment variables are hardcoded rather than using Docker secrets or environment files"
      },
      "correct_answer": "A"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What security vulnerability exists in the following implementation of data encryption?",
      "options": {
        "A": "The initialization vector (IV) is not randomly generated for each encryption operation",
        "B": "The AES-256-CBC mode is vulnerable to padding oracle attacks without proper HMAC validation",
        "C": "The key derivation process doesn't use a salt, making it vulnerable to rainbow table attacks",
        "D": "The encryption key is stored as an environment variable, which can be exposed in error logs"
      },
      "correct_answer": "C",
      "code_example": "const crypto = require('crypto');\n\nclass Encryptor {\n  constructor() {\n    // Generate encryption key from environment variable\n    this.key = crypto.scryptSync(process.env.ENCRYPTION_SECRET, '', 32);\n  }\n  \n  encrypt(data) {\n    // Generate random IV\n    const iv = crypto.randomBytes(16);\n    \n    // Create cipher\n    const cipher = crypto.createCipheriv('aes-256-cbc', this.key, iv);\n    \n    // Encrypt data\n    let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    // Return IV + encrypted data in hex format\n    return iv.toString('hex') + ':' + encrypted;\n  }\n  \n  decrypt(encryptedData) {\n    // Split IV and encrypted data\n    const parts = encryptedData.split(':');\n    const iv = Buffer.from(parts[0], 'hex');\n    const encrypted = parts[1];\n    \n    // Create decipher\n    const decipher = crypto.createDecipheriv('aes-256-cbc', this.key, iv);\n    \n    // Decrypt data\n    let decrypted = decipher.update(encrypted, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return JSON.parse(decrypted);\n  }\n}"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "What is the security vulnerability in this JWT implementation?",
      "options": {
        "A": "The access tokens have no expiration, allowing indefinite use if compromised",
        "B": "The JWT payload is encrypted with AES instead of being signed with HMAC or RSA",
        "C": "The 'none' algorithm is used for signing, which bypasses signature verification",
        "D": "The secret key is stored in the application code rather than secure environment variables"
      },
      "correct_answer": "D",
      "code_example": "const jwt = require('jsonwebtoken');\n\nclass JwtService {\n  constructor() {\n    // Hard-coded JWT secret\n    this.jwtSecret = 'my-super-secret-jwt-key-for-auth-service';\n  }\n  \n  generateAccessToken(user) {\n    return jwt.sign(\n      { \n        id: user.id,\n        email: user.email,\n        role: user.role\n      },\n      this.jwtSecret,\n      { expiresIn: '1h' }\n    );\n  }\n  \n  generateRefreshToken(user) {\n    return jwt.sign(\n      { id: user.id },\n      this.jwtSecret,\n      { expiresIn: '7d' }\n    );\n  }\n  \n  verifyToken(token) {\n    try {\n      return jwt.verify(token, this.jwtSecret);\n    } catch (error) {\n      return null;\n    }\n  }\n}"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What is the MOST significant issue with this logging configuration using Winston?",
      "options": {
        "A": "It doesn't implement log rotation, potentially causing disk space issues",
        "B": "It uses synchronous file operations which could block the event loop",
        "C": "It fails to sanitize user input in logs, exposing the application to log injection attacks",
        "D": "It logs all errors at the same level without differentiation by severity"
      },
      "correct_answer": "C",
      "code_example": "const winston = require('winston');\nconst path = require('path');\n\n// Define custom log format\nconst logFormat = winston.format.combine(\n  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),\n  winston.format.json()\n);\n\n// Create logger\nconst logger = winston.createLogger({\n  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',\n  format: logFormat,\n  transports: [\n    new winston.transports.Console({\n      format: winston.format.combine(\n        winston.format.colorize(),\n        winston.format.simple()\n      )\n    }),\n    new winston.transports.File({\n      filename: path.join(__dirname, '../logs/error.log'),\n      level: 'error',\n      maxsize: 5242880, // 5MB\n      maxFiles: 5\n    }),\n    new winston.transports.File({\n      filename: path.join(__dirname, '../logs/combined.log'),\n      maxsize: 5242880, // 5MB\n      maxFiles: 5\n    })\n  ]\n});\n\n// Middleware to log API requests\nfunction requestLogger(req, res, next) {\n  const start = Date.now();\n  \n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    logger.info(`${req.method} ${req.originalUrl} ${res.statusCode} ${duration}ms - ${req.ip} - ${req.headers['user-agent']} - User: ${req.body.username || 'anonymous'}`);\n  });\n  \n  next();\n}\n\nmodule.exports = { logger, requestLogger };"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "When deploying a Node.js application to Heroku, which of the following configuration approaches is MOST critical for proper scaling?",
      "options": {
        "A": "Setting a dynamic port with `const PORT = process.env.PORT || 3000`",
        "B": "Including all dependencies in package.json rather than using git submodules",
        "C": "Configuring the application to use PostgreSQL instead of MongoDB",
        "D": "Adding a Procfile that specifies process types and startup commands"
      },
      "correct_answer": "A"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What critical security configuration is missing in this Helmet.js implementation?",
      "options": {
        "A": "Cross-Origin-Opener-Policy (COOP) headers are not set",
        "B": "Content-Security-Policy doesn't include a nonce for inline scripts",
        "C": "X-Content-Type-Options is missing the 'nosniff' directive",
        "D": "Referrer-Policy doesn't restrict referrer information to same-origin requests"
      },
      "correct_answer": "B",
      "code_example": "const express = require('express');\nconst helmet = require('helmet');\nconst app = express();\n\n// Apply Helmet middleware with custom CSP\napp.use(\n  helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        scriptSrc: [\"'self'\", 'https://cdn.jsdelivr.net', 'https://ajax.googleapis.com'],\n        styleSrc: [\"'self'\", 'https://fonts.googleapis.com', \"'unsafe-inline'\"],\n        imgSrc: [\"'self'\", 'data:', 'https://storage.googleapis.com'],\n        connectSrc: [\"'self'\", 'https://api.example.com'],\n        fontSrc: [\"'self'\", 'https://fonts.gstatic.com'],\n        objectSrc: [\"'none'\"],\n        mediaSrc: [\"'self'\"],\n        frameSrc: [\"'none'\"],\n      },\n    },\n    xssFilter: true,\n    noSniff: true,\n    referrerPolicy: { policy: 'same-origin' },\n    hsts: {\n      maxAge: 15552000, // 180 days in seconds\n      includeSubDomains: true,\n      preload: true\n    },\n    frameguard: { action: 'deny' }\n  })\n);"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "What is the primary vulnerability that remains in this Cross-Site Request Forgery (CSRF) protection implementation?",
      "options": {
        "A": "The CSRF token is not bound to the user's session, allowing token reuse across sessions",
        "B": "The 'secure' flag is missing from the cookie settings, exposing tokens on HTTP connections",
        "C": "The token is validated using a timing-unsafe string comparison method",
        "D": "The implementation uses a synchronous crypto operation that could block the event loop"
      },
      "correct_answer": "A",
      "code_example": "const express = require('express');\nconst crypto = require('crypto');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(cookieParser());\n\n// Middleware to generate CSRF token\napp.use((req, res, next) => {\n  // Skip for GET, HEAD, OPTIONS requests\n  if (['GET', 'HEAD', 'OPTIONS'].includes(req.method)) {\n    return next();\n  }\n  \n  // Skip if already has valid token\n  if (req.cookies.csrf_token) {\n    return next();\n  }\n  \n  // Generate token\n  const token = crypto.randomBytes(32).toString('hex');\n  \n  // Set cookie\n  res.cookie('csrf_token', token, {\n    httpOnly: true,\n    sameSite: 'strict',\n    maxAge: 3600000 // 1 hour\n  });\n  \n  next();\n});\n\n// Middleware to validate CSRF token\napp.use((req, res, next) => {\n  // Skip for non-mutation methods\n  if (['GET', 'HEAD', 'OPTIONS'].includes(req.method)) {\n    return next();\n  }\n  \n  const cookieToken = req.cookies.csrf_token;\n  const headerToken = req.headers['x-csrf-token'];\n  \n  if (!cookieToken || !headerToken || cookieToken !== headerToken) {\n    return res.status(403).json({ error: 'CSRF token validation failed' });\n  }\n  \n  next();\n});"
    }
  ]
}
