{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What is the output of the following code?",
      "code_example": "console.log(typeof null);",
      "options": {
        "A": "null",
        "B": "undefined",
        "C": "object",
        "D": "string"
      },
      "correct_answer": "C"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "Which statement about environment variables in Node.js is correct?",
      "options": {
        "A": "Environment variables can only be set before the application starts",
        "B": "process.env values are always strings, even when they represent numbers",
        "C": "Environment variables can be modified but not deleted during runtime",
        "D": "process.env is only available in production environments"
      },
      "correct_answer": "B"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const arr = [1, 2, 3];\nconst obj = { a: 1, b: 2 };\nconsole.log(typeof arr, typeof obj);",
      "options": {
        "A": "array object",
        "B": "object object",
        "C": "Array Object",
        "D": "[object Array] [object Object]"
      },
      "correct_answer": "B"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What is the difference between innerHTML and textContent when modifying DOM elements?",
      "options": {
        "A": "innerHTML can only set text, while textContent can set HTML",
        "B": "innerHTML parses content as HTML, while textContent treats content as plain text",
        "C": "innerHTML is faster than textContent for all operations",
        "D": "There is no difference; they are interchangeable"
      },
      "correct_answer": "B"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function add(a, b) {\n  return a + b;\n}\n\nconsole.log(add('2', 3));",
      "options": {
        "A": "5",
        "B": "23",
        "C": "TypeError",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What's the key difference between require() and import() in Node.js?",
      "options": {
        "A": "require() is synchronous, while import() is asynchronous",
        "B": "require() is for CommonJS modules, while import() is for ES modules",
        "C": "require() can import JSON files, while import() cannot",
        "D": "require() can only be used at the top of a file, while import() can be used anywhere"
      },
      "correct_answer": "B"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "const person = { name: 'John', age: 30 };\nconsole.log(Object.values(person));",
      "options": {
        "A": "{ name: 'John', age: 30 }",
        "B": "['name', 'age']",
        "C": "['John', 30]",
        "D": "{ 'John', 30 }"
      },
      "correct_answer": "C"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "sayHello();\n\nfunction sayHello() {\n  console.log('Hello!');\n}\n\nsayHi();\n\nconst sayHi = function() {\n  console.log('Hi!');\n};",
      "options": {
        "A": "Hello! Hi!",
        "B": "Hello! ReferenceError",
        "C": "ReferenceError",
        "D": "undefined undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "Which of the following best describes Node.js?",
      "options": {
        "A": "A JavaScript framework for building web applications",
        "B": "A runtime environment that executes JavaScript code outside a web browser",
        "C": "A JavaScript library for DOM manipulation",
        "D": "A programming language based on JavaScript"
      },
      "correct_answer": "B"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "const { name, age = 25 } = { name: 'Alice' };\nconsole.log(name, age);",
      "options": {
        "A": "Alice undefined",
        "B": "Alice 25",
        "C": "undefined undefined",
        "D": "Alice null"
      },
      "correct_answer": "B"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "Which of the following is NOT a primitive type in JavaScript?",
      "options": {
        "A": "boolean",
        "B": "bigint",
        "C": "array",
        "D": "symbol"
      },
      "correct_answer": "C"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log('5' == 5);\nconsole.log('5' === 5);",
      "options": {
        "A": "true true",
        "B": "false false",
        "C": "true false",
        "D": "false true"
      },
      "correct_answer": "C"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "function sum() {\n  let total = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}\n\nconsole.log(sum(1, 2, 3));",
      "options": {
        "A": "1",
        "B": "6",
        "C": "undefined",
        "D": "Error: arguments is not defined"
      },
      "correct_answer": "B"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "const value = 42;\n\nswitch (value) {\n  case '42':\n    console.log('String');\n    break;\n  case 42:\n    console.log('Number');\n    break;\n  default:\n    console.log('Unknown');\n}",
      "options": {
        "A": "String",
        "B": "Number",
        "C": "Unknown",
        "D": "No output"
      },
      "correct_answer": "B"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What is the result of the following code?",
      "code_example": "console.log(Number('123'));\nconsole.log(parseInt('123.45'));\nconsole.log(parseFloat('123.45'));",
      "options": {
        "A": "123 123 123.45",
        "B": "123 123.45 123.45",
        "C": "'123' '123' '123.45'",
        "D": "123 123.45 123"
      },
      "correct_answer": "A"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What is one key difference between Node.js and browser JavaScript?",
      "options": {
        "A": "Node.js supports Object-Oriented Programming while browser JavaScript does not",
        "B": "Browser JavaScript can directly access the file system while Node.js cannot",
        "C": "Node.js has direct access to the file system while browser JavaScript does not",
        "D": "Node.js does not support asynchronous operations while browser JavaScript does"
      },
      "correct_answer": "C"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const user = {\n  name: 'John',\n  address: null\n};\n\nconsole.log(user.address?.street);",
      "options": {
        "A": "null",
        "B": "undefined",
        "C": "TypeError",
        "D": "''"
      },
      "correct_answer": "B"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "What will the following code output?",
      "code_example": "const obj = { name: 'Alice' };\n\nfunction greet() {\n  console.log(`Hello, ${this.name}!`);\n}\n\ngreet.call(obj);",
      "options": {
        "A": "Hello, undefined!",
        "B": "Hello, Alice!",
        "C": "TypeError: this.name is not defined",
        "D": "Hello, !"
      },
      "correct_answer": "B"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What's the difference between CommonJS and ES Modules?",
      "options": {
        "A": "CommonJS loads modules synchronously, while ES Modules load asynchronously",
        "B": "ES Modules can only be used in browsers, while CommonJS can only be used in Node.js",
        "C": "CommonJS uses require() and module.exports, while ES Modules use import and export",
        "D": "ES Modules provide better performance but CommonJS provides better compatibility"
      },
      "correct_answer": "C"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "What will the following code output?",
      "code_example": "function multiply(a, b = 2) {\n  return a * b;\n}\n\nconsole.log(multiply(5));\nconsole.log(multiply(5, undefined));\nconsole.log(multiply(5, null));",
      "options": {
        "A": "10 10 0",
        "B": "10 10 null",
        "C": "10 undefined 0",
        "D": "10 10 5"
      },
      "correct_answer": "A"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function outer() {\n  let count = 0;\n  \n  function middle() {\n    let count = 10;\n    \n    function inner() {\n      count += 1;\n      return count;\n    }\n    \n    return inner();\n  }\n  \n  return middle();\n}\n\nconsole.log(outer());",
      "options": {
        "A": "1",
        "B": "0",
        "C": "11",
        "D": "10"
      },
      "correct_answer": "C"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "Which Helmet.js middleware would you use to prevent clickjacking attacks?",
      "options": {
        "A": "helmet.noSniff()",
        "B": "helmet.xssFilter()",
        "C": "helmet.frameguard()",
        "D": "helmet.hsts()"
      },
      "correct_answer": "C"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What's the most efficient way to read a large file in Node.js?",
      "options": {
        "A": "Use fs.readFile() with a large buffer size",
        "B": "Use fs.readFileSync() for better performance",
        "C": "Use streams with fs.createReadStream()",
        "D": "Split the file into smaller chunks and read them sequentially"
      },
      "correct_answer": "C"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "Which Express.js middleware would you use to parse JSON request bodies?",
      "options": {
        "A": "express.json()",
        "B": "express.bodyParser()",
        "C": "express.parseJSON()",
        "D": "app.use(JSON.parse)"
      },
      "correct_answer": "A"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const person = {\n  name: 'Alice',\n  greet() {\n    return `Hello, ${this.name}`;\n  }\n};\n\nconst greetFn = person.greet;\nconsole.log(greetFn());",
      "options": {
        "A": "Hello, Alice",
        "B": "Hello, undefined",
        "C": "TypeError",
        "D": "Hello, "
      },
      "correct_answer": "B"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "Which approach would help reduce redundant database queries in a Node.js application?",
      "options": {
        "A": "Always use synchronous database operations",
        "B": "Implement caching for frequently accessed, relatively static data",
        "C": "Create more database connections",
        "D": "Use raw SQL queries instead of an ORM"
      },
      "correct_answer": "B"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What is the best practice for implementing API versioning in a RESTful API?",
      "options": {
        "A": "Use different port numbers for different API versions",
        "B": "Include the version in the URL path (e.g., /api/v1/resource)",
        "C": "Use query parameters (e.g., /api/resource?version=1)",
        "D": "Create separate applications for each API version"
      },
      "correct_answer": "B"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What will the following code output?",
      "code_example": "const fs = require('fs');\nconst readable = fs.createReadStream('./file.txt');\n\nreadable.on('data', (chunk) => {\n  console.log(typeof chunk);\n});",
      "options": {
        "A": "string",
        "B": "buffer",
        "C": "stream",
        "D": "object"
      },
      "correct_answer": "B"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "When using Sequelize with PostgreSQL, which of the following is true?",
      "options": {
        "A": "Sequelize automatically creates database tables without the need for migrations",
        "B": "PostgreSQL-specific data types like JSONB are not supported by Sequelize",
        "C": "Sequelize supports both raw SQL queries and ORM methods",
        "D": "Transactions are not supported in Sequelize when working with PostgreSQL"
      },
      "correct_answer": "C"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "Which HTTP method is idempotent but not safe according to HTTP specifications?",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "PATCH"
      },
      "correct_answer": "C"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will the following code output when executed in Node.js?",
      "code_example": "const rateLimit = require('express-rate-limit');\n\nconst limiter = rateLimit({\n  windowMs: 60 * 1000,\n  max: 5\n});\n\nconsole.log(typeof limiter);",
      "options": {
        "A": "object",
        "B": "function",
        "C": "middleware",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What will the following code output?",
      "code_example": "function modifyArray(arr) {\n  arr.push(4);\n  arr = [5, 6, 7];\n  return arr;\n}\n\nconst myArray = [1, 2, 3];\nconst result = modifyArray(myArray);\n\nconsole.log(myArray);\nconsole.log(result);",
      "options": {
        "A": "[1, 2, 3] [5, 6, 7]",
        "B": "[1, 2, 3, 4] [5, 6, 7]",
        "C": "[5, 6, 7] [5, 6, 7]",
        "D": "[1, 2, 3, 4] [1, 2, 3, 4]"
      },
      "correct_answer": "B"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What is the most efficient way to optimize this code for V8 Engine performance?",
      "options": {
        "A": "Convert the array to a Set and use Set.has() instead",
        "B": "Use Array.includes() with a binary search algorithm",
        "C": "Use Array.indexOf() instead of Array.includes()",
        "D": "Pre-allocate the array size using Array(1000).fill()"
      },
      "correct_answer": "A",
      "code_example": "function containsValue(arr, value) {\n  return arr.includes(value);\n}\n\nconst largeArray = [];\nfor (let i = 0; i < 10000; i++) {\n  largeArray.push(i);\n}\n\n// Function called thousands of times in a loop\nfor (let j = 0; j < 5000; j++) {\n  containsValue(largeArray, Math.floor(Math.random() * 20000));\n}"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "Which of the following is the safest way to store JWT secrets in a Node.js application?",
      "options": {
        "A": "Store them as environment variables in a .env file committed to the repository",
        "B": "Store them as environment variables loaded through process.env from a file not committed to the repository",
        "C": "Store them in a configuration JSON file with restricted permissions",
        "D": "Hardcode them in the application code but obfuscate the values"
      },
      "correct_answer": "B"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What will happen when this code runs?",
      "options": {
        "A": "It will output 'Processed 1000 items' and exit normally",
        "B": "It will eventually crash with a heap out of memory error",
        "C": "It will create exactly 1000 timers that never execute",
        "D": "It will run indefinitely, continuously processing new items"
      },
      "correct_answer": "B",
      "code_example": "function processData() {\n  const items = [];\n  \n  function loadItems() {\n    for (let i = 0; i < 1000; i++) {\n      items.push({\n        id: i,\n        data: new Array(10000).fill('x')\n      });\n    }\n    return items;\n  }\n  \n  function processItem(item) {\n    // Process the item\n    console.log(`Processing item ${item.id}`);\n    \n    // Schedule processing of next batch\n    setTimeout(() => {\n      const newItems = loadItems();\n      newItems.forEach(processItem);\n    }, 100);\n  }\n  \n  // Start processing\n  const initialItems = loadItems();\n  initialItems.forEach(processItem);\n}\n\nprocessData();"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "Which of the following approaches correctly encrypts sensitive user data before storing it in a database?",
      "options": {
        "A": "Using Math.random() to generate an encryption key stored alongside the data",
        "B": "Using crypto.createCipher() with a password derived from user information",
        "C": "Using crypto.createCipheriv() with a secure key and initialization vector",
        "D": "Using Base64 encoding to mask the data before storage"
      },
      "correct_answer": "C",
      "code_example": "const crypto = require('crypto');\n\nfunction encryptUserData(userData, secretKey) {\n  // Generate a random initialization vector\n  const iv = crypto.randomBytes(16);\n  \n  // Create cipher with key and iv\n  const cipher = crypto.createCipheriv('aes-256-gcm', secretKey, iv);\n  \n  // Encrypt the data\n  let encrypted = cipher.update(JSON.stringify(userData), 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  \n  // Get the authentication tag\n  const authTag = cipher.getAuthTag().toString('hex');\n  \n  // Return the encrypted data, iv, and auth tag\n  return {\n    data: encrypted,\n    iv: iv.toString('hex'),\n    tag: authTag\n  };\n}"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "Which of the following Dockerfile configurations is most appropriate for a production Node.js application?",
      "options": {
        "A": "FROM node:latest\nWORKDIR /app\nCOPY . .\nRUN npm install\nCMD [\"npm\", \"start\"]",
        "B": "FROM node:alpine\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install --production\nCOPY . .\nUSER node\nCMD [\"node\", \"index.js\"]",
        "C": "FROM ubuntu:latest\nRUN apt-get update && apt-get install -y nodejs npm\nWORKDIR /app\nCOPY . .\nRUN npm install\nEXPOSE 3000\nCMD [\"npm\", \"start\"]",
        "D": "FROM node:14\nWORKDIR /app\nCOPY . .\nRUN npm install && npm cache clean --force\nEXPOSE 3000\nCMD [\"npm\", \"start\"]"
      },
      "correct_answer": "B"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "What will be the output of the following EventEmitter code?",
      "options": {
        "A": "First listener\nSecond listener\nNew event triggered",
        "B": "First listener\nSecond listener\nNew event triggered\nFirst listener\nSecond listener",
        "C": "First listener\nSecond listener",
        "D": "Error: Maximum call stack size exceeded"
      },
      "correct_answer": "C",
      "code_example": "const EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n\n// First listener\nmyEmitter.once('event', () => {\n  console.log('First listener');\n});\n\n// Second listener\nmyEmitter.once('event', () => {\n  console.log('Second listener');\n});\n\nmyEmitter.emit('event');\nmyEmitter.emit('event');\n\nconsole.log('New event triggered');"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "Which code snippet correctly prevents memory leaks when using event listeners in long-running applications?",
      "options": {
        "A": "function addHandlers(element) {\n  element.addEventListener('click', onClick);\n  element.addEventListener('mouseover', onMouseOver);\n}\n\nfunction removeHandlers() {\n  document.querySelectorAll('*').forEach(el => {\n    el.removeEventListener('click', () => {});\n    el.removeEventListener('mouseover', () => {});\n  });\n}",
        "B": "let handlers = [];\nfunction addHandlers(element) {\n  const clickHandler = () => handleClick(element);\n  const mouseOverHandler = () => handleMouseOver(element);\n  \n  element.addEventListener('click', clickHandler);\n  element.addEventListener('mouseover', mouseOverHandler);\n  \n  handlers.push({\n    element,\n    clickHandler,\n    mouseOverHandler\n  });\n}",
        "C": "function addHandlers(element) {\n  element.onclick = handleClick;\n  element.onmouseover = handleMouseOver;\n  // When done\n  element.onclick = null;\n  element.onmouseover = null;\n}",
        "D": "function addHandlers(element) {\n  const clickHandler = () => handleClick(element);\n  const mouseOverHandler = () => handleMouseOver(element);\n  \n  element.addEventListener('click', clickHandler);\n  element.addEventListener('mouseover', mouseOverHandler);\n  \n  return function cleanup() {\n    element.removeEventListener('click', clickHandler);\n    element.removeEventListener('mouseover', mouseOverHandler);\n  };\n}"
      },
      "correct_answer": "D"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "When debugging a Node.js application using node --inspect, which of the following statements is true?",
      "options": {
        "A": "The debugger will automatically pause execution at the first line of code",
        "B": "The inspector protocol is accessible only from the local machine for security reasons",
        "C": "You must use Chrome DevTools to connect to the inspector protocol",
        "D": "The default inspector port 9229 can be changed using the --inspect=port parameter"
      },
      "correct_answer": "D"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What will be the output of this code after it runs for several minutes?",
      "options": {
        "A": "Memory leak detected",
        "B": "Error: Callback was already called",
        "C": "The program will crash with a 'JavaScript heap out of memory' error",
        "D": "The program will run normally without any issues"
      },
      "correct_answer": "C",
      "code_example": "const http = require('http');\nconst server = http.createServer();\n\nconst requestCache = [];\n\nserver.on('request', (req, res) => {\n  // Store the full request data in cache for later analysis\n  requestCache.push({\n    url: req.url,\n    headers: req.headers,\n    timestamp: Date.now(),\n    // Create a large object to simulate memory usage\n    rawData: Buffer.alloc(10000).fill('x')\n  });\n  \n  // Process request and send response\n  res.writeHead(200);\n  res.end('OK');\n  \n  // Attempt to find similar previous requests\n  const similarRequests = requestCache.filter(cachedReq => \n    cachedReq.url === req.url\n  );\n  \n  console.log(`Found ${similarRequests.length} similar requests`);\n});\n\nserver.listen(3000);"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "Which deployment platform is most appropriate for a Node.js application that requires scheduled tasks, a MongoDB database, and websocket support?",
      "options": {
        "A": "GitHub Pages",
        "B": "Vercel",
        "C": "DigitalOcean Droplet",
        "D": "Heroku Free Tier"
      },
      "correct_answer": "C"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "Which code snippet correctly implements CORS protection for a sensitive API endpoint?",
      "options": {
        "A": "app.use(cors());",
        "B": "app.use(cors({ origin: '*' }));",
        "C": "app.use(cors({\n  origin: function(origin, callback) {\n    const allowedOrigins = ['https://trusted-app.com', 'https://admin.trusted-app.com'];\n    if (!origin || allowedOrigins.includes(origin)) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  methods: ['GET', 'POST'],\n  credentials: true,\n  optionsSuccessStatus: 204\n}));",
        "D": "app.use(function(req, res, next) {\n  res.header('Access-Control-Allow-Origin', req.headers.origin);\n  res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');\n  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  next();\n});"
      },
      "correct_answer": "C",
      "code_example": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\n// CORS middleware configuration\napp.use(cors({\n  origin: function(origin, callback) {\n    const allowedOrigins = ['https://trusted-app.com', 'https://admin.trusted-app.com'];\n    if (!origin || allowedOrigins.includes(origin)) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  methods: ['GET', 'POST'],\n  credentials: true,\n  optionsSuccessStatus: 204\n}));\n\n// Sensitive API endpoint\napp.get('/api/user-data', (req, res) => {\n  // Verify authentication here\n  res.json({ sensitive: 'data' });\n});\n\napp.listen(3000);"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "What will the following code output when the API receives multiple successive requests from the same IP?",
      "options": {
        "A": "It will always respond with the user data for all requests",
        "B": "After 100 requests in 15 minutes, it will respond with a 429 Too Many Requests error",
        "C": "After 5 requests in 15 minutes, it will respond with a 429 Too Many Requests error",
        "D": "It will randomly reject requests based on server load"
      },
      "correct_answer": "B",
      "code_example": "const express = require('express');\nconst rateLimit = require('express-rate-limit');\n\nconst app = express();\n\n// Configure rate limiter\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers\n  legacyHeaders: false, // Disable the `X-RateLimit-*` headers\n  message: 'Too many requests from this IP, please try again after 15 minutes'\n});\n\n// Apply rate limiter to all requests\napp.use('/api/', apiLimiter);\n\napp.get('/api/user/:id', (req, res) => {\n  const userId = req.params.id;\n  // Fetch user data from database\n  res.json({ id: userId, name: 'Test User' });\n});\n\napp.listen(3000);"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What will be the result of comparing these two passwords?",
      "options": {
        "A": "They will match, returning true",
        "B": "They won't match, returning false",
        "C": "The comparison will throw an error due to different salt values",
        "D": "The comparison will be inconsistent, sometimes matching and sometimes not"
      },
      "correct_answer": "A",
      "code_example": "const bcrypt = require('bcrypt');\n\nasync function testPasswordHashing() {\n  const password = 'secure_password123';\n  \n  // Hash the password with a salt round of 10\n  const hashedPassword = await bcrypt.hash(password, 10);\n  console.log('Hashed password:', hashedPassword);\n  \n  // Compare the original password with the hashed one\n  const match = await bcrypt.compare(password, hashedPassword);\n  console.log('Password match:', match);\n  \n  // Compare with a different password\n  const noMatch = await bcrypt.compare('wrong_password', hashedPassword);\n  console.log('Wrong password match:', noMatch);\n  \n  return match;\n}\n\ntestPasswordHashing();"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "Which of the following winston logger configurations is most appropriate for a production environment?",
      "options": {
        "A": "const logger = winston.createLogger({\n  level: 'debug',\n  format: winston.format.simple(),\n  transports: [\n    new winston.transports.Console()\n  ]\n});",
        "B": "const logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  transports: [\n    new winston.transports.File({ filename: 'error.log', level: 'error' }),\n    new winston.transports.File({ filename: 'combined.log' })\n  ],\n  exceptionHandlers: [\n    new winston.transports.File({ filename: 'exceptions.log' })\n  ]\n});",
        "C": "const logger = winston.createLogger({\n  level: 'verbose',\n  format: winston.format.printf(info => `${info.message}`),\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: 'app.log' })\n  ]\n});",
        "D": "const logger = winston.createLogger({\n  transports: [\n    new winston.transports.Console({ level: 'debug' }),\n    new winston.transports.File({ filename: 'app.log', level: 'error' })\n  ]\n});"
      },
      "correct_answer": "B"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What will happen when this code runs?",
      "options": {
        "A": "Objects with IDs 1, 2, and 3 will be garbage collected, but object with ID 4 will remain in memory",
        "B": "Objects with IDs 1 and 2 will be garbage collected, but objects 3 and 4 will remain in memory",
        "C": "All objects will be garbage collected when their references are removed",
        "D": "No objects will be garbage collected because the cache is still referenced"
      },
      "correct_answer": "A",
      "code_example": "function testWeakMap() {\n  let cache = new WeakMap();\n  \n  let obj1 = { id: 1 };\n  let obj2 = { id: 2 };\n  let obj3 = { id: 3 };\n  let obj4 = { id: 4 };\n  \n  // Store some data in the cache\n  cache.set(obj1, 'Data for object 1');\n  cache.set(obj2, 'Data for object 2');\n  cache.set(obj3, 'Data for object 3');\n  cache.set(obj4, 'Data for object 4');\n  \n  // Remove reference to obj1, obj2, and obj3\n  obj1 = null;\n  obj2 = null;\n  obj3 = null;\n  \n  // Force garbage collection (this is just for illustration)\n  // In real environments, you can't force garbage collection\n  // global.gc && global.gc();\n  \n  // Check if objects are still in cache\n  console.log('obj4 in cache:', cache.has(obj4));\n  return cache;\n}\n\ntestWeakMap();"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "Which Helmet.js configuration best protects a Node.js application from common web vulnerabilities?",
      "options": {
        "A": "app.use(helmet());",
        "B": "app.use(helmet.contentSecurityPolicy());\napp.use(helmet.xssFilter());",
        "C": "app.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\", \"'https://trusted-cdn.com'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", \"data:\"],\n      connectSrc: [\"'self'\", \"https://api.trusted-service.com\"],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"],\n    },\n  },\n  xssFilter: true,\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  },\n  frameguard: {\n    action: 'deny'\n  },\n  noSniff: true\n}));",
        "D": "// No configuration needed - Express has built-in security"
      },
      "correct_answer": "C",
      "code_example": "const express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\", \"'https://trusted-cdn.com'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", \"data:\"],\n      connectSrc: [\"'self'\", \"https://api.trusted-service.com\"],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"],\n    },\n  },\n  xssFilter: true,\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  },\n  frameguard: {\n    action: 'deny'\n  },\n  noSniff: true\n}));\n\napp.get('/', (req, res) => {\n  res.send('Secure application');\n});\n\napp.listen(3000);"
    }
  ]
}
