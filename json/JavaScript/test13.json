{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let num = 5;\nlet result = (num > 3) ? 'Greater' : 'Lesser';\nconsole.log(result);",
      "options": {
        "A": "5",
        "B": "Greater",
        "C": "Lesser",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What's the difference between let and const in JavaScript?",
      "options": {
        "A": "let is block-scoped, const is function-scoped",
        "B": "let variables can be reassigned, const variables cannot be reassigned",
        "C": "const variables must be initialized with a value, let variables don't need initial values",
        "D": "const creates immutable objects, let creates mutable objects"
      },
      "correct_answer": "B"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const person = { name: 'John', age: 30 };\nconst { name, job = 'Developer' } = person;\nconsole.log(job);",
      "options": {
        "A": "undefined",
        "B": "null",
        "C": "Developer",
        "D": "Error: job is not defined"
      },
      "correct_answer": "C"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function greet(name = 'Guest') {\n  return `Hello, ${name}!`;\n}\nconsole.log(greet());",
      "options": {
        "A": "Hello, undefined!",
        "B": "Hello, null!",
        "C": "Hello, Guest!",
        "D": "Hello, !"
      },
      "correct_answer": "C"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const num = '42';\nconsole.log(parseInt(num) + 8);",
      "options": {
        "A": "428",
        "B": "50",
        "C": "NaN",
        "D": "42"
      },
      "correct_answer": "B"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "Which method is used to attach an event handler to an element in JavaScript?",
      "options": {
        "A": "element.attachEvent()",
        "B": "element.addEventListener()",
        "C": "element.addHandler()",
        "D": "element.eventListener()"
      },
      "correct_answer": "B"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function calculate(a, b, c) {\n  switch(c) {\n    case 'add':\n      return a + b;\n    case 'subtract':\n      return a - b;\n    default:\n      return a * b;\n  }\n}\nconsole.log(calculate(5, 3, 'multiply'));",
      "options": {
        "A": "8",
        "B": "2",
        "C": "15",
        "D": "undefined"
      },
      "correct_answer": "C"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What is the correct way to export a function in Node.js?",
      "options": {
        "A": "export function myFunction() {}",
        "B": "exports = { myFunction: function() {} }",
        "C": "module.exports.myFunction = function() {}",
        "D": "export default function myFunction() {}"
      },
      "correct_answer": "C"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const numbers = [1, 2, 3, 4];\nconst [first, , third] = numbers;\nconsole.log(third);",
      "options": {
        "A": "2",
        "B": "3",
        "C": "undefined",
        "D": "4"
      },
      "correct_answer": "B"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const result = 5 ** 2 % 3;\nconsole.log(result);",
      "options": {
        "A": "1",
        "B": "2",
        "C": "4",
        "D": "7"
      },
      "correct_answer": "B"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What's the main difference between function declarations and function expressions?",
      "options": {
        "A": "Function declarations support recursion, function expressions don't",
        "B": "Function expressions can't be used as callbacks",
        "C": "Function declarations are hoisted, function expressions are not",
        "D": "Function expressions can't accept parameters"
      },
      "correct_answer": "C"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function counter() {\n  let count = 0;\n  \n  function increment() {\n    count++;\n    console.log(count);\n  }\n  \n  increment();\n  increment();\n}\n\ncounter();",
      "options": {
        "A": "0, 0",
        "B": "0, 1",
        "C": "1, 1",
        "D": "1, 2"
      },
      "correct_answer": "D"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const car = {\n  brand: 'Toyota',\n  details: {\n    color: 'red',\n    year: 2020\n  }\n};\n\nconst { details: { color, year } } = car;\nconsole.log(color);",
      "options": {
        "A": "Toyota",
        "B": "red",
        "C": "details",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "Which Node.js method is used to read the contents of a file synchronously?",
      "options": {
        "A": "fs.readFile()",
        "B": "fs.read()",
        "C": "fs.readFileSync()",
        "D": "fs.fileRead()"
      },
      "correct_answer": "C"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function processData(callback) {\n  const data = 'Processed';\n  callback(data);\n}\n\nprocessData(function(info) {\n  console.log('Data: ' + info);\n});",
      "options": {
        "A": "Data: null",
        "B": "Data: undefined",
        "C": "Data: Processed",
        "D": "Function: callback"
      },
      "correct_answer": "C"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const element = document.getElementById('test');\nelement.textContent = 'Hello';\nelement.innerHTML = '<strong>World</strong>';\nconsole.log(element.textContent);",
      "options": {
        "A": "Hello",
        "B": "World",
        "C": "<strong>World</strong>",
        "D": "HelloWorld"
      },
      "correct_answer": "B"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const value = null;\nconst result = value ?? 'Default';\nconsole.log(result);",
      "options": {
        "A": "null",
        "B": "Default",
        "C": "undefined",
        "D": "false"
      },
      "correct_answer": "B"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "What's the main difference between prototypal inheritance in JavaScript and classical inheritance?",
      "options": {
        "A": "JavaScript doesn't support inheritance at all",
        "B": "In prototypal inheritance, objects inherit directly from other objects, not from classes",
        "C": "Classical inheritance is more performant than prototypal inheritance",
        "D": "Prototypal inheritance only works with ES6 and later"
      },
      "correct_answer": "B"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const calculate = (a, b) => {\n  try {\n    if (b === 0) throw new Error('Division by zero');\n    return a / b;\n  } catch (error) {\n    return error.message;\n  }\n};\n\nconsole.log(calculate(10, 0));",
      "options": {
        "A": "Infinity",
        "B": "Error: Division by zero",
        "C": "Division by zero",
        "D": "NaN"
      },
      "correct_answer": "C"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "What's the main advantage of using streams in Node.js when handling large files?",
      "options": {
        "A": "Streams are always faster than other methods",
        "B": "Streams can handle any file type, unlike other methods",
        "C": "Streams process data piece by piece, reducing memory usage",
        "D": "Streams automatically compress data during transfer"
      },
      "correct_answer": "C"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const calculator = {\n  value: 0,\n  add: function(n) {\n    this.value += n;\n    return this;\n  },\n  multiply: function(n) {\n    this.value *= n;\n    return this;\n  },\n  getValue: function() {\n    return this.value;\n  }\n};\n\nconst result = calculator.add(5).multiply(2).getValue();\nconsole.log(result);",
      "options": {
        "A": "5",
        "B": "7",
        "C": "10",
        "D": "15"
      },
      "correct_answer": "C"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What is a 'pure function' in JavaScript?",
      "options": {
        "A": "A function that only uses arrow syntax",
        "B": "A function that doesn't modify variables outside its scope and always returns the same output for the same input",
        "C": "A function that doesn't use any external libraries",
        "D": "A function that can handle multiple data types"
      },
      "correct_answer": "B"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const person = {\n  name: 'John',\n  greet: function() {\n    return `Hello, my name is ${this.name}`;\n  },\n  greetArrow: () => {\n    return `Hello, my name is ${this.name}`;\n  }\n};\n\nconsole.log(person.greetArrow());",
      "options": {
        "A": "Hello, my name is John",
        "B": "Hello, my name is undefined",
        "C": "Hello, my name is [object Object]",
        "D": "TypeError: this.name is not defined"
      },
      "correct_answer": "B"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "In Express.js, which middleware is used to parse URL-encoded form data?",
      "options": {
        "A": "express.json()",
        "B": "express.urlencoded()",
        "C": "express.form()",
        "D": "express.parser()"
      },
      "correct_answer": "B"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function countdown(n) {\n  if (n <= 0) {\n    return 'Done!';\n  }\n  console.log(n);\n  return countdown(n - 1);\n}\n\nconsole.log(countdown(3));",
      "options": {
        "A": "3 2 1 Done!",
        "B": "3 2 1",
        "C": "Done!",
        "D": "Maximum call stack size exceeded"
      },
      "correct_answer": "C"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "In MongoDB, what is the primary purpose of a Schema in Mongoose?",
      "options": {
        "A": "To improve query performance",
        "B": "To create database backups",
        "C": "To define the structure and validation rules for documents",
        "D": "To establish connections to the database"
      },
      "correct_answer": "C"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function loadData(callback) {\n  setTimeout(() => {\n    callback('Data loaded');\n  }, 1000);\n}\n\nfunction processData(data, callback) {\n  setTimeout(() => {\n    callback(`${data} and processed`);\n  }, 1000);\n}\n\nfunction displayData(data, callback) {\n  setTimeout(() => {\n    callback(`${data} and displayed`);\n  }, 1000);\n}\n\nloadData((loadResult) => {\n  processData(loadResult, (processResult) => {\n    displayData(processResult, (displayResult) => {\n      console.log(displayResult);\n    });\n  });\n});",
      "options": {
        "A": "Data loaded",
        "B": "Data loaded and processed",
        "C": "Data loaded and processed and displayed",
        "D": "Callback Hell detected"
      },
      "correct_answer": "C"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "Which Express.js method is used to send a JSON response to the client?",
      "options": {
        "A": "res.send()",
        "B": "res.json()",
        "C": "res.writeJSON()",
        "D": "res.sendJSON()"
      },
      "correct_answer": "B"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const checkAge = async (age) => {\n  if (age < 18) {\n    throw new Error('Too young');\n  }\n  return 'Access granted';\n};\n\nconst verifyUser = async () => {\n  try {\n    const result = await checkAge(15);\n    return result;\n  } catch (error) {\n    return `Access denied: ${error.message}`;\n  }\n};\n\nverifyUser().then(console.log);",
      "options": {
        "A": "Access granted",
        "B": "Access denied: Too young",
        "C": "Error: Too young",
        "D": "Promise { <rejected> Error: Too young }"
      },
      "correct_answer": "B"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What's the primary way to prevent NoSQL injection in MongoDB?",
      "options": {
        "A": "Use async/await with all MongoDB operations",
        "B": "Run MongoDB in secure mode only",
        "C": "Sanitize and validate all user input before using it in queries",
        "D": "Use MongoDB Atlas instead of self-hosted MongoDB"
      },
      "correct_answer": "C"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const app = require('express')();\n\napp.get('/users/:id', (req, res) => {\n  console.log(req.params.id);\n  console.log(req.query.filter);\n  res.send('Response sent');\n});\n\n// If a request is made to: /users/42?filter=active",
      "options": {
        "A": "undefined, undefined",
        "B": "42, undefined",
        "C": "undefined, active",
        "D": "42, active"
      },
      "correct_answer": "D"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What memory management mechanism does JavaScript use?",
      "options": {
        "A": "Manual memory allocation and deallocation",
        "B": "Reference counting only",
        "C": "Automatic garbage collection using mark-and-sweep algorithm",
        "D": "Stack-based memory management"
      },
      "correct_answer": "C"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What will be the output of the following Transform stream code?",
      "options": {
        "A": "HELLO WORLD",
        "B": "hello world",
        "C": "[object Object]",
        "D": "TypeError: Cannot read property 'push' of undefined"
      },
      "correct_answer": "A",
      "code_example": "const { Transform } = require('stream');\nconst { Readable } = require('stream');\n\nconst upperCaseTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    const upperCaseData = chunk.toString().toUpperCase();\n    this.push(upperCaseData);\n    callback();\n  }\n});\n\nconst source = Readable.from(['hello world']);\n\nlet result = '';\nupperCaseTransform.on('data', (chunk) => {\n  result += chunk.toString();\n});\n\nupperCaseTransform.on('end', () => {\n  console.log(result);\n});\n\nsource.pipe(upperCaseTransform);"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "Which of the following is NOT a valid approach to prevent CORS vulnerabilities in a Node.js application?",
      "options": {
        "A": "Using the cors package with specific origin restrictions",
        "B": "Implementing proper validation of all incoming data",
        "C": "Setting Access-Control-Allow-Origin to '*' in all responses",
        "D": "Using a whitelist of allowed domains for cross-origin requests"
      },
      "correct_answer": "C",
      "code_example": null
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates a closure potentially causing a memory leak?",
      "options": {
        "A": "Nothing, the code will run without any output",
        "B": "Error: Maximum call stack size exceeded",
        "C": "[1, 2, 3, 4, 5]",
        "D": "The process will consume increasing memory until it crashes"
      },
      "correct_answer": "D",
      "code_example": "function createLeak() {\n  const largeData = new Array(1000000).fill('potentially leaky data');\n  const smallData = [1, 2, 3, 4, 5];\n  \n  setInterval(() => {\n    // This function forms a closure over largeData,\n    // preventing it from being garbage collected\n    console.log(smallData.length);\n  }, 1000);\n}\n\n// Create multiple instances of the leak\nfor (let i = 0; i < 100; i++) {\n  createLeak();\n}\n\n// In a real-world scenario, this would eventually\n// cause the application to run out of memory"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "When implementing refresh tokens and access tokens in a Node.js application, which of the following is the MOST secure approach?",
      "options": {
        "A": "Store both refresh and access tokens in localStorage for easy access",
        "B": "Store the refresh token in an HttpOnly cookie and keep the access token in memory",
        "C": "Store both tokens in sessionStorage to prevent XSS attacks",
        "D": "Store the access token in a cookie and the refresh token in localStorage"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates rate limiting with express-rate-limit?",
      "options": {
        "A": "{ success: true, message: 'Rate limit applied' }",
        "B": "Error: Too many requests, please try again later.",
        "C": "{ message: 'Hello World!' } for the first 5 requests, then status code 429 for subsequent requests",
        "D": "RateLimitExceeded: Maximum request count exceeded"
      },
      "correct_answer": "C",
      "code_example": "const express = require('express');\nconst rateLimit = require('express-rate-limit');\n\nconst app = express();\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // limit each IP to 5 requests per windowMs\n  message: 'Too many requests, please try again later.'\n});\n\napp.use(limiter);\n\napp.get('/', (req, res) => {\n  res.json({ message: 'Hello World!' });\n});\n\n// When this server is running:\n// First 5 requests from same IP within 15 minutes: status 200 with message\n// Subsequent requests within that window: status 429 with rate limit message"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "What is the primary purpose of the X-Content-Type-Options security header?",
      "options": {
        "A": "To prevent browsers from rendering the page in an iframe",
        "B": "To restrict which domains can load resources from your site",
        "C": "To prevent browsers from MIME-type sniffing",
        "D": "To specify which HTTP methods are allowed on the resource"
      },
      "correct_answer": "C",
      "code_example": null
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates memory leak identification using the Node.js heap snapshot?",
      "options": {
        "A": "0, 1000, 2000, 3000, 4000 (increasing memory usage)",
        "B": "0, 0, 0, 0, 0 (constant memory usage)",
        "C": "TypeError: heapUsed is not a function",
        "D": "0, 1000, 1000, 1000, 1000 (initial increase then stable memory usage)"
      },
      "correct_answer": "A",
      "code_example": "const memoryUsage = [];\n\nfunction leakyFunction() {\n  const previousCallData = [];\n  \n  return function(data) {\n    // This creates a leak by always keeping reference to previous data\n    previousCallData.push(data);\n    return previousCallData.length;\n  };\n}\n\nconst leakyData = leakyFunction();\n\n// Check memory usage before leak\nconst initialMemory = process.memoryUsage().heapUsed;\nmemoryUsage.push(0); // baseline\n\n// Create memory leak by repeatedly calling with new large data\nfor (let i = 0; i < 4; i++) {\n  const newData = new Array(1000).fill('x').join('');\n  leakyData(newData);\n  \n  // Check and log memory difference\n  const currentMemory = process.memoryUsage().heapUsed;\n  const diff = currentMemory - initialMemory;\n  memoryUsage.push(Math.round(diff / 1000) * 1000); // rounded to nearest 1000\n}\n\nconsole.log(memoryUsage); // Shows increasing memory usage pattern"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "What is the most secure way to store JWT secrets in a Node.js application?",
      "options": {
        "A": "Hardcoding the secret in the application code",
        "B": "Storing the secret in a .env file committed to version control",
        "C": "Using environment variables managed through a secure service like AWS Secrets Manager",
        "D": "Storing the secret in browser localStorage for easy access"
      },
      "correct_answer": "C",
      "code_example": null
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates a memory leak in event listeners?",
      "options": {
        "A": "All listeners removed",
        "B": "Memory leak: 3 listeners",
        "C": "Memory leak: 10 listeners",
        "D": "EventEmitter memory leak detected. 11 listeners added."
      },
      "correct_answer": "D",
      "code_example": "const EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n\n// Set the maximum number of listeners to 10\n// Default is 10, but explicitly setting it here for clarity\nmyEmitter.setMaxListeners(10);\n\nfunction addListeners() {\n  for (let i = 0; i < 11; i++) {\n    // Adding event listeners without removing them\n    myEmitter.on('event', () => {\n      console.log('Event fired');\n    });\n  }\n  \n  // Trigger the event\n  myEmitter.emit('event');\n}\n\naddListeners();\n// This will cause Node.js to emit a warning about potential memory leak"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "Which deployment platform is MOST suitable for a Node.js application that requires dynamic scaling based on CPU usage and has specific requirements for custom build packs?",
      "options": {
        "A": "Vercel",
        "B": "DigitalOcean App Platform",
        "C": "Heroku",
        "D": "GitHub Pages"
      },
      "correct_answer": "C",
      "code_example": null
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What will be the output of the following code that sets up winston for logging?",
      "options": {
        "A": "{ level: 'info', message: 'Hello distributed log files!' }",
        "B": "Error: winston transport not initialized",
        "C": "info: Hello distributed log files!",
        "D": "2023-05-15T12:34:56Z - info: Hello distributed log files!"
      },
      "correct_answer": "C",
      "code_example": "const winston = require('winston');\n\n// Create a logger instance\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.simple(),\n  transports: [\n    new winston.transports.Console()\n  ]\n});\n\n// Log a message\nlogger.info('Hello distributed log files!');"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "In the context of the OAuth flow, what is the purpose of PKCE (Proof Key for Code Exchange)?",
      "options": {
        "A": "To encrypt the access token during transmission",
        "B": "To prevent authorization code interception attacks in public clients",
        "C": "To verify the identity of the authorization server",
        "D": "To enhance the performance of token validation"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates handling real-time data with streams?",
      "options": {
        "A": "Chunk received: data chunk 1, Chunk received: data chunk 2, All data received",
        "B": "Buffer data chunk 1, Buffer data chunk 2, Stream ended",
        "C": "Error: Stream not readable",
        "D": "data chunk 1data chunk 2"
      },
      "correct_answer": "A",
      "code_example": "const { Readable } = require('stream');\n\n// Create a custom readable stream\nclass MyDataStream extends Readable {\n  constructor(data) {\n    super();\n    this.data = data;\n    this.index = 0;\n  }\n  \n  _read() {\n    if (this.index < this.data.length) {\n      // Push data chunk with a slight delay to simulate real-time data\n      const chunk = this.data[this.index++];\n      setTimeout(() => {\n        this.push(chunk);\n      }, 10);\n    } else {\n      // Signal the end of the stream\n      this.push(null);\n    }\n  }\n}\n\n// Sample data chunks\nconst dataChunks = ['data chunk 1', 'data chunk 2'];\n\n// Create an instance of our custom stream\nconst dataStream = new MyDataStream(dataChunks);\n\n// Handle the data as it comes in real-time\ndataStream.on('data', (chunk) => {\n  console.log(`Chunk received: ${chunk}`);\n});\n\ndataStream.on('end', () => {\n  console.log('All data received');\n});"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "How does JavaScript's JIT (Just-In-Time) compilation impact the performance of code like the following?",
      "options": {
        "A": "It always compiles the entire function regardless of execution patterns",
        "B": "It first interprets the code, then incrementally compiles frequently executed parts (hot paths)",
        "C": "It pre-compiles all possible execution paths before any code runs",
        "D": "It has no impact as JavaScript is always interpreted"
      },
      "correct_answer": "B",
      "code_example": "function processData(items, condition) {\n  let result = 0;\n  \n  // This loop gets executed many times with similar patterns\n  for (let i = 0; i < items.length; i++) {\n    if (condition) {\n      // Hot path - frequently executed\n      result += items[i] * 2;\n    } else {\n      // Cold path - rarely executed\n      result += Math.sin(items[i]);\n    }\n  }\n  \n  return result;\n}\n\n// Call the function repeatedly with the same condition\nconst data = new Array(10000).fill(1);\nfor (let i = 0; i < 1000; i++) {\n  processData(data, true);\n}"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates how JavaScript allocates memory?",
      "options": {
        "A": "Global object: 1, Function execution: 2, Closure: 3, Collection: 3,4,5",
        "B": "Global object: undefined, Function execution: 2, Closure: 3, Collection: 3,4,5",
        "C": "Global object: 1, Function execution: 2, Closure: undefined, Collection: 3,4,5",
        "D": "Global object: 1, Function execution: 2, Closure: 3, Collection: [object Object]"
      },
      "correct_answer": "A",
      "code_example": "// Global variable allocation (stored in global object)\nlet globalVar = 1;\n\nfunction demonstrateMemoryAllocation() {\n  // Function execution context allocation\n  let functionVar = 2;\n  \n  // Closure allocation (retains memory even after function execution)\n  function closure() {\n    let closureVar = 3;\n    console.log(`Closure: ${closureVar}`);\n  }\n  \n  // Collection allocation (array of objects)\n  let collection = [\n    { id: 3 },\n    { id: 4 },\n    { id: 5 }\n  ];\n  \n  console.log(`Global object: ${globalVar}`);\n  console.log(`Function execution: ${functionVar}`);\n  closure();\n  console.log(`Collection: ${collection.map(item => item.id)}`);\n}\n\ndemonstrateMemoryAllocation();"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "When managing containers for a Node.js application, which approach provides the MOST efficient way to handle container lifecycle?",
      "options": {
        "A": "Running multiple Node.js instances inside a single container",
        "B": "Using Docker Compose with health checks and restart policies",
        "C": "Deploying containers manually through SSH connections",
        "D": "Storing application data in the container's filesystem"
      },
      "correct_answer": "B",
      "code_example": null
    }
  ]
}
