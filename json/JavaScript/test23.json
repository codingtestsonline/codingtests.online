{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(parseInt('42px'));",
      "options": {
        "A": "42px",
        "B": "42",
        "C": "NaN",
        "D": "Error"
      },
      "correct_answer": "B"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What is the result of the following comparison?",
      "code_example": "console.log('5' === 5);",
      "options": {
        "A": "true",
        "B": "false",
        "C": "TypeError",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be logged to the console?",
      "code_example": "sayHello();\nfunction sayHello() {\n  console.log('Hello!');\n}",
      "options": {
        "A": "ReferenceError: sayHello is not defined",
        "B": "undefined",
        "C": "Hello!",
        "D": "Nothing will be logged"
      },
      "correct_answer": "C"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What is Node.js?",
      "options": {
        "A": "A front-end JavaScript framework",
        "B": "A JavaScript runtime built on Chrome's V8 JavaScript engine",
        "C": "A JavaScript preprocessor",
        "D": "A package manager for JavaScript"
      },
      "correct_answer": "B"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What will be the output of this code using default parameters?",
      "code_example": "function greet(name = 'Guest') {\n  return `Hello, ${name}!`;\n}\nconsole.log(greet());",
      "options": {
        "A": "Hello, undefined!",
        "B": "Hello, null!",
        "C": "Hello, Guest!",
        "D": "Hello, !"
      },
      "correct_answer": "C"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What is the difference between function declarations and function expressions?",
      "options": {
        "A": "There is no difference",
        "B": "Function declarations are hoisted while function expressions are not",
        "C": "Function expressions can be anonymous while declarations cannot",
        "D": "Both B and C"
      },
      "correct_answer": "D"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function processData(data, callback) {\n  callback(data.toUpperCase());\n}\n\nprocessData('hello', function(result) {\n  console.log(result);\n});",
      "options": {
        "A": "hello",
        "B": "HELLO",
        "C": "undefined",
        "D": "Error"
      },
      "correct_answer": "B"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be logged to the console?",
      "code_example": "const name = 'John';\nconst age = 30;\nconsole.log(`${name} is ${age} years old.`);",
      "options": {
        "A": "${name} is ${age} years old.",
        "B": "name is age years old.",
        "C": "John is 30 years old.",
        "D": "Error: Template literal syntax is incorrect"
      },
      "correct_answer": "C"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will be the output of the following arrow function?",
      "code_example": "const add = (a, b) => a + b;\nconsole.log(add(2, 3));",
      "options": {
        "A": "undefined",
        "B": "Error",
        "C": "5",
        "D": "Function definition"
      },
      "correct_answer": "C"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What will be the output of this async/await code?",
      "code_example": "async function fetchData() {\n  return 'Data';\n}\n\nasync function logData() {\n  const data = await fetchData();\n  console.log(data);\n}\n\nlogData();",
      "options": {
        "A": "Promise { <pending> }",
        "B": "Data",
        "C": "undefined",
        "D": "Error"
      },
      "correct_answer": "B"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const user = {\n  name: 'John',\n  age: 30\n};\nconsole.log(user.name);",
      "options": {
        "A": "John",
        "B": "30",
        "C": "undefined",
        "D": "{name: 'John', age: 30}"
      },
      "correct_answer": "A"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "How would you access an environment variable named 'PORT' in a Node.js application?",
      "options": {
        "A": "environment.PORT",
        "B": "process.environment.PORT",
        "C": "process.env.PORT",
        "D": "env.PORT"
      },
      "correct_answer": "C"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What is the primary purpose of the package.json file in a Node.js project?",
      "options": {
        "A": "It contains the actual JavaScript code of the application",
        "B": "It's used to configure system-wide Node.js settings",
        "C": "It defines the project dependencies and metadata",
        "D": "It's used to create database schemas"
      },
      "correct_answer": "C"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What is a key difference between require() and import statements?",
      "options": {
        "A": "require() is used in CommonJS modules while import is used in ES modules",
        "B": "There is no difference, they are interchangeable",
        "C": "import can only import built-in modules",
        "D": "require() can only be used in browser JavaScript"
      },
      "correct_answer": "A"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "for (let i = 0; i < 5; i++) {\n  if (i === 2) {\n    continue;\n  }\n  console.log(i);\n  if (i === 3) {\n    break;\n  }\n}",
      "options": {
        "A": "0 1 3",
        "B": "0 1 2 3",
        "C": "0 1 2 3 4",
        "D": "0 1 3 4"
      },
      "correct_answer": "A"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What will be the output of the following code using the spread operator?",
      "code_example": "const arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = [...arr1, ...arr2];\nconsole.log(combined);",
      "options": {
        "A": "[1, 2, 3, 4, 5, 6]",
        "B": "[[1, 2, 3], [4, 5, 6]]",
        "C": "Error: Spread operator not defined",
        "D": "[...arr1, ...arr2]"
      },
      "correct_answer": "A"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What is the correct way to establish a connection to MongoDB using Mongoose?",
      "code_example": "const mongoose = require('mongoose');\n\nmongoose.connect('mongodb://localhost:27017/myapp')\n  .then(() => console.log('Connected to MongoDB'))\n  .catch(err => console.error('Could not connect to MongoDB', err));",
      "options": {
        "A": "The code is incorrect, mongoose.createConnection should be used instead",
        "B": "The code is incorrect, a callback function should be used instead of promises",
        "C": "The code is correct for establishing a MongoDB connection using Mongoose",
        "D": "The code is incorrect, the MongoDB URI format is wrong"
      },
      "correct_answer": "C"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "Which of the following is the best practice to prevent SQL injection in a Node.js application using a SQL database?",
      "code_example": "// Option A\ndb.query(`SELECT * FROM users WHERE username = '${username}'`);\n\n// Option B\ndb.query('SELECT * FROM users WHERE username = ?', [username]);\n\n// Option C\ndb.query(`SELECT * FROM users WHERE username = ${JSON.stringify(username)}`);\n\n// Option D\nconst safeUsername = username.replace(/[^a-zA-Z0-9]/g, '');\ndb.query(`SELECT * FROM users WHERE username = '${safeUsername}'`);",
      "options": {
        "A": "Option A",
        "B": "Option B",
        "C": "Option C",
        "D": "Option D"
      },
      "correct_answer": "B"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What is the correct implementation of a basic Express.js REST API endpoint that returns a JSON response?",
      "code_example": "const express = require('express');\nconst app = express();\n\napp.get('/api/users', (req, res) => {\n  const users = [{id: 1, name: 'John'}, {id: 2, name: 'Jane'}];\n  res.status(200).json(users);\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
      "options": {
        "A": "The code is incorrect, Express doesn't have a .json() method",
        "B": "The code is incorrect, status code should be set separately with res.status()",
        "C": "The code is correct for creating a basic REST API endpoint",
        "D": "The code is incorrect, app.get() cannot handle API requests"
      },
      "correct_answer": "C"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "What will be the output of the following code involving Symbols?",
      "code_example": "const id = Symbol('id');\nconst user = {\n  name: 'John',\n  [id]: 123\n};\n\nconsole.log(user[id]);\nconsole.log(Object.keys(user));",
      "options": {
        "A": "123 ['name', Symbol(id)]",
        "B": "123 ['name']",
        "C": "undefined ['name']",
        "D": "123 ['name', 'id']"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What is the correct order of execution in the following JavaScript Event Loop example?",
      "code_example": "console.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise');\n});\n\nconsole.log('End');",
      "options": {
        "A": "Start, End, Timeout, Promise",
        "B": "Start, End, Promise, Timeout",
        "C": "Start, Promise, End, Timeout",
        "D": "Start, Timeout, Promise, End"
      },
      "correct_answer": "B"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "Which code correctly implements the Event Emitter pattern in Node.js?",
      "code_example": "const EventEmitter = require('events');\n\nclass Logger extends EventEmitter {\n  log(message) {\n    this.emit('log', { message, timestamp: new Date() });\n  }\n}\n\nconst logger = new Logger();\n\nlogger.on('log', data => {\n  console.log(`${data.timestamp}: ${data.message}`);\n});\n\nlogger.log('User logged in');",
      "options": {
        "A": "The code is incorrect, EventEmitter should be instantiated not extended",
        "B": "The code is incorrect, the on() method should be called before emitting events",
        "C": "The code is correct for implementing the Event Emitter pattern",
        "D": "The code is incorrect, emit() should be called on EventEmitter not this"
      },
      "correct_answer": "C"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What is the correct way to define a model and query a PostgreSQL database using Sequelize?",
      "code_example": "const { Sequelize, DataTypes } = require('sequelize');\nconst sequelize = new Sequelize('postgres://user:pass@localhost:5432/dbname');\n\nconst User = sequelize.define('User', {\n  username: {\n    type: DataTypes.STRING,\n    allowNull: false\n  },\n  email: {\n    type: DataTypes.STRING,\n    unique: true\n  }\n});\n\nasync function findUsers() {\n  const users = await User.findAll({\n    where: {\n      email: {\n        [Op.like]: '%@example.com'\n      }\n    }\n  });\n  return users;\n}",
      "options": {
        "A": "The code is correct for defining and querying with Sequelize",
        "B": "The code is incorrect, Op needs to be imported from sequelize",
        "C": "The code is incorrect, findAll() is not a valid Sequelize method",
        "D": "The code is incorrect, models should be defined using sequelize.model() not sequelize.define()"
      },
      "correct_answer": "B"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What will be the result of the following file streaming code?",
      "code_example": "const fs = require('fs');\nconst readStream = fs.createReadStream('large-file.txt');\nconst writeStream = fs.createWriteStream('copy-file.txt');\n\nreadStream.on('data', chunk => {\n  writeStream.write(chunk);\n});\n\nreadStream.on('end', () => {\n  console.log('File copy completed');\n  writeStream.end();\n});",
      "options": {
        "A": "The code will throw an error because streams cannot be used this way",
        "B": "The code will copy the file asynchronously using streams",
        "C": "The code will create empty files because no data is being processed",
        "D": "The code will only copy part of the file due to missing error handling"
      },
      "correct_answer": "B"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What is the output of this function composition example?",
      "code_example": "const add5 = x => x + 5;\nconst multiply2 = x => x * 2;\nconst subtract3 = x => x - 3;\n\nconst compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);\nconst compute = compose(subtract3, multiply2, add5);\n\nconsole.log(compute(10));",
      "options": {
        "A": "17",
        "B": "27",
        "C": "30",
        "D": "24"
      },
      "correct_answer": "B"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What will be logged to the console in this prototype chain example?",
      "code_example": "function Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.speak = function() {\n  return `${this.name} makes a sound`;\n};\n\nfunction Dog(name) {\n  Animal.call(this, name);\n}\n\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n\nDog.prototype.speak = function() {\n  return `${this.name} barks`;\n};\n\nconst dog = new Dog('Rex');\nconsole.log(dog.speak());",
      "options": {
        "A": "undefined makes a sound",
        "B": "Rex makes a sound",
        "C": "Rex barks",
        "D": "TypeError: dog.speak is not a function"
      },
      "correct_answer": "C"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will be the result of the following code with default parameters?",
      "code_example": "function multiply(a, b = 1) {\n  return a * b;\n}\n\nconsole.log(multiply(5));\nconsole.log(multiply(5, undefined));\nconsole.log(multiply(5, null));\nconsole.log(multiply(5, 2));",
      "options": {
        "A": "5, 5, 5, 10",
        "B": "5, 5, 0, 10",
        "C": "5, undefined, null, 10",
        "D": "NaN, NaN, 0, 10"
      },
      "correct_answer": "B"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "Which HTTP status code is most appropriate for a successful API request that returns no content?",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "304 Not Modified"
      },
      "correct_answer": "C"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "Which of the following statements about JavaScript memory management is correct?",
      "options": {
        "A": "JavaScript has manual memory management similar to C++",
        "B": "Circular references between objects are automatically handled by the garbage collector",
        "C": "The garbage collector runs synchronously during code execution",
        "D": "JavaScript has no memory leaks because everything is automatically garbage collected"
      },
      "correct_answer": "B"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What is the correct way to use the compression middleware in an Express application?",
      "code_example": "const express = require('express');\nconst compression = require('compression');\nconst app = express();\n\napp.use(compression());\napp.use(express.json());\n\napp.get('/api/data', (req, res) => {\n  res.send({ message: 'This response will be compressed' });\n});\n\napp.listen(3000);",
      "options": {
        "A": "The code is incorrect, compression() should be applied to specific routes only",
        "B": "The code is incorrect, compression should be applied after parsing middleware",
        "C": "The code is incorrect, compression requires additional configuration parameters",
        "D": "The code is correct for applying compression to all responses"
      },
      "correct_answer": "D"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will be the result of this first-class function example?",
      "code_example": "function createMultiplier(factor) {\n  return function(number) {\n    return number * factor;\n  };\n}\n\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\nconsole.log(double(5) + triple(10));",
      "options": {
        "A": "10",
        "B": "15",
        "C": "40",
        "D": "50"
      },
      "correct_answer": "C"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What is the best practice for API versioning in a RESTful Express.js application?",
      "options": {
        "A": "Include the version in the URL path (e.g., /api/v1/users)",
        "B": "Use a query parameter (e.g., /api/users?version=1)",
        "C": "Use a custom HTTP header (e.g., 'Accept-Version: 1.0')",
        "D": "All of the above are acceptable approaches depending on requirements"
      },
      "correct_answer": "D"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "Which of the following statements about Just-In-Time (JIT) compilation in JavaScript engines like V8 is correct?",
      "options": {
        "A": "JIT compilation converts JavaScript directly to machine code without any intermediate representation",
        "B": "JIT compilation in V8 happens only once when the JavaScript file is first loaded",
        "C": "The V8 JIT compiler uses profiling data to optimize hot code paths at runtime",
        "D": "JIT compilation eliminates the need for garbage collection in JavaScript"
      },
      "correct_answer": "C"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates V8 Engine optimizations?",
      "options": {
        "A": "Slow: 54ms, Fast: 2ms",
        "B": "Slow: 54ms, Fast: 54ms",
        "C": "Both times will be approximately the same",
        "D": "The output will vary significantly on each run"
      },
      "correct_answer": "A",
      "code_example": "function measurePerformance() {\n  // Unoptimized function with dynamic property access\n  function slowSum(arr) {\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n      sum += arr[i].value;\n    }\n    return sum;\n  }\n\n  // Optimized function with predictable types\n  function fastSum(arr) {\n    let sum = 0;\n    // Using local variable to avoid property lookup in loop\n    const len = arr.length;\n    for (let i = 0; i < len; i++) {\n      // Direct access without changing types\n      sum += arr[i];\n    }\n    return sum;\n  }\n\n  // Prepare test data\n  const slowData = Array(1000000).fill().map(() => ({ value: 1 }));\n  const fastData = Array(1000000).fill(1);\n\n  // Measure slow function\n  const slowStart = performance.now();\n  slowSum(slowData);\n  const slowEnd = performance.now();\n  const slowTime = Math.round(slowEnd - slowStart);\n\n  // Measure fast function\n  const fastStart = performance.now();\n  fastSum(fastData);\n  const fastEnd = performance.now();\n  const fastTime = Math.round(fastEnd - fastStart);\n\n  console.log(`Slow: ${slowTime}ms, Fast: ${fastTime}ms`);\n}\n\nmeasurePerformance();"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "Which configuration in a docker-compose.yml file correctly sets up a Node.js application with MongoDB, ensuring proper networking and volume persistence?",
      "options": {
        "A": "version: '3'\nservices:\n  app:\n    build: .\n    ports:\n      - '3000:3000'\n  mongodb:\n    image: mongo:latest\n    environment:\n      - MONGO_INITDB_ROOT_USERNAME=admin\n      - MONGO_INITDB_ROOT_PASSWORD=password",
        "B": "version: '3'\nservices:\n  app:\n    build: .\n    ports:\n      - '3000:3000'\n    depends_on:\n      - mongodb\n    environment:\n      - MONGODB_URI=mongodb://mongodb:27017/myapp\n  mongodb:\n    image: mongo:latest\n    ports:\n      - '27017:27017'\n    volumes:\n      - mongodb_data:/data/db\nvolumes:\n  mongodb_data:",
        "C": "version: '3'\nservices:\n  app:\n    build: .\n    networks:\n      - backend\n  mongodb:\n    image: mongo:latest\n    networks:\n      - frontend\nnetworks:\n  frontend:\n  backend:",
        "D": "version: '3'\nservices:\n  app:\n    image: node:latest\n    command: npm start\n  mongodb:\n    image: mongo:latest\n    command: mongod"
      },
      "correct_answer": "B"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "What will be the result of running this code that demonstrates a memory leak caused by event listeners?",
      "options": {
        "A": "The program will crash after approximately 10 seconds with 'Maximum call stack size exceeded'",
        "B": "The program will continue running indefinitely, with memory usage steadily increasing",
        "C": "The garbage collector will automatically clean up all listeners after each createButton call",
        "D": "The program will stop after printing 'Memory leak detected' to the console"
      },
      "correct_answer": "B",
      "code_example": "function createMemoryLeakExample() {\n  const parentElement = document.createElement('div');\n  document.body.appendChild(parentElement);\n  \n  function createButton() {\n    // Create a button element\n    const button = document.createElement('button');\n    button.innerText = 'Click me';\n    \n    // Create a large object that will be referenced in the closure\n    const largeData = new Array(100000).fill('data');\n    \n    // Add event listener with a closure that captures largeData\n    button.addEventListener('click', function() {\n      console.log('Button clicked, data length:', largeData.length);\n    });\n    \n    // Add to parent element\n    parentElement.appendChild(button);\n    \n    // Remove immediately (but event listener remains!)\n    parentElement.removeChild(button);\n  }\n  \n  // Create thousands of buttons (and listeners) over time\n  setInterval(createButton, 10);\n  \n  return 'Creating buttons with memory leak...';\n}\n\ncreateMemoryLeakExample();"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "Which of the following Nginx configurations correctly sets up a reverse proxy for a Node.js application running on port 3000, with proper HTTP headers and caching?",
      "options": {
        "A": "server {\n  listen 80;\n  server_name example.com;\n  \n  location / {\n    proxy_pass http://localhost:3000;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header X-Forwarded-Proto $scheme;\n  }\n}",
        "B": "server {\n  listen 80;\n  root /var/www/html;\n  index index.html;\n  \n  location / {\n    try_files $uri $uri/ =404;\n  }\n}",
        "C": "server {\n  listen 80;\n  server_name example.com;\n  \n  location / {\n    fastcgi_pass localhost:3000;\n    include fastcgi_params;\n  }\n}",
        "D": "server {\n  listen 80;\n  server_name example.com;\n  \n  location ~ \\.php$ {\n    proxy_pass http://localhost:3000;\n  }\n}"
      },
      "correct_answer": "A"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "Which combination of HTTP security headers provides the strongest protection against clickjacking, MIME-type sniffing, and referrer leakage?",
      "options": {
        "A": "X-XSS-Protection: 1; mode=block\nContent-Security-Policy: default-src 'self'\nX-Powered-By: Express",
        "B": "X-Frame-Options: DENY\nX-Content-Type-Options: nosniff\nReferrer-Policy: no-referrer-when-downgrade",
        "C": "X-Frame-Options: SAMEORIGIN\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin",
        "D": "Content-Security-Policy: frame-ancestors 'none'\nX-Content-Type-Options: nosniff\nReferrer-Policy: no-referrer"
      },
      "correct_answer": "D"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "What will be the output of this code demonstrating the Node.js crypto module for secure password handling?",
      "options": {
        "A": "Password verification successful!",
        "B": "Password verification failed!",
        "C": "Error: Illegal key length",
        "D": "Error: Invalid salt length"
      },
      "correct_answer": "A",
      "code_example": "const crypto = require('crypto');\n\nfunction securePasswordDemo() {\n  // Store these values in a database in a real application\n  let storedSalt;\n  let storedHash;\n  \n  // Function to hash a password\n  function hashPassword(password) {\n    // Generate a random salt\n    const salt = crypto.randomBytes(16).toString('hex');\n    \n    // Hash the password with the salt using PBKDF2\n    const hash = crypto.pbkdf2Sync(\n      password,\n      salt,\n      1000,  // iterations\n      64,    // key length\n      'sha512'\n    ).toString('hex');\n    \n    return { salt, hash };\n  }\n  \n  // Function to verify a password\n  function verifyPassword(password, salt, storedHash) {\n    // Hash the password attempt with the same salt\n    const hash = crypto.pbkdf2Sync(\n      password,\n      salt,\n      1000,  // must use same parameters as original\n      64,    // must use same parameters as original\n      'sha512'\n    ).toString('hex');\n    \n    // Compare the hashes\n    return hash === storedHash;\n  }\n  \n  // Simulating user registration\n  const userPassword = 'S3cureP@ssw0rd';\n  const { salt, hash } = hashPassword(userPassword);\n  \n  // Save these values\n  storedSalt = salt;\n  storedHash = hash;\n  \n  // Later: user login attempt with correct password\n  const loginAttempt = 'S3cureP@ssw0rd';\n  const isValid = verifyPassword(loginAttempt, storedSalt, storedHash);\n  \n  if (isValid) {\n    return 'Password verification successful!';\n  } else {\n    return 'Password verification failed!';\n  }\n}\n\nconsole.log(securePasswordDemo());"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "What will be the output of this code showcasing cluster module functionality in Node.js?",
      "options": {
        "A": "Only 'Master process is running' will be logged once",
        "B": "Both 'Master process is running' and 'Worker started' will be logged exactly once",
        "C": "'Master process is running' will be logged once, followed by multiple 'Worker started' logs (one for each CPU core)",
        "D": "The program will throw an error because the cluster API is being used incorrectly"
      },
      "correct_answer": "C",
      "code_example": "const cluster = require('cluster');\nconst os = require('os');\n\nfunction clusterExample() {\n  if (cluster.isMaster) {\n    console.log('Master process is running');\n    \n    // Get the number of available CPU cores\n    const numCPUs = os.cpus().length;\n    \n    // Fork workers equal to the number of CPUs\n    for (let i = 0; i < numCPUs; i++) {\n      cluster.fork();\n    }\n    \n    cluster.on('exit', (worker, code, signal) => {\n      console.log(`Worker ${worker.process.pid} died`);\n    });\n  } else {\n    // This code will be executed by worker processes\n    console.log('Worker started');\n    \n    // In a real application, this is where you would start your server\n    // Example: http.createServer(...).listen(3000);\n  }\n}\n\nclusterExample();"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What is the primary advantage of using worker_threads in Node.js compared to the cluster module?",
      "options": {
        "A": "worker_threads always provide better performance than cluster for all types of applications",
        "B": "worker_threads allow sharing memory between threads, while cluster processes have completely separate memory spaces",
        "C": "worker_threads automatically distribute incoming network connections, while cluster requires manual implementation",
        "D": "worker_threads can run on multiple machines, while cluster is limited to a single machine"
      },
      "correct_answer": "B"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates WeakMap for memory-sensitive caching?",
      "options": {
        "A": "Before cleanup: Has data for obj1: true, Has data for obj2: true\nAfter cleanup: Has data for obj1: false, Has data for obj2: true",
        "B": "Before cleanup: Has data for obj1: true, Has data for obj2: true\nAfter cleanup: Has data for obj1: true, Has data for obj2: true",
        "C": "Before cleanup: Has data for obj1: true, Has data for obj2: true\nAfter cleanup: Has data for obj1: true, Has data for obj2: true\nError: Maximum call stack size exceeded",
        "D": "Before cleanup: Has data for obj1: false, Has data for obj2: false\nAfter cleanup: Has data for obj1: false, Has data for obj2: false"
      },
      "correct_answer": "A",
      "code_example": "function weakMapDemo() {\n  // Create a WeakMap to store expensive computation results\n  const cache = new WeakMap();\n  \n  // Function that performs expensive computation\n  function getExpensiveData(obj) {\n    // Check if we have cached result\n    if (cache.has(obj)) {\n      return cache.get(obj);\n    }\n    \n    // Perform \"expensive\" computation\n    const result = {\n      data: `Processed data for ${obj.id}`,\n      timestamp: Date.now()\n    };\n    \n    // Cache the result\n    cache.set(obj, result);\n    return result;\n  }\n  \n  // Create objects to use as keys\n  let obj1 = { id: 'object-1' };\n  const obj2 = { id: 'object-2' };\n  \n  // Process both objects\n  getExpensiveData(obj1);\n  getExpensiveData(obj2);\n  \n  // Check cache status\n  console.log(\n    `Before cleanup: Has data for obj1: ${cache.has(obj1)}, ` +\n    `Has data for obj2: ${cache.has(obj2)}`\n  );\n  \n  // Remove reference to obj1, allowing garbage collection\n  obj1 = null;\n  \n  // Force garbage collection (for demonstration purposes)\n  // Note: In real environments, you can't reliably force GC like this\n  if (global.gc) {\n    global.gc();\n  }\n  \n  // We'll simulate GC effect for this example\n  setTimeout(() => {\n    // Check cache status after cleanup\n    // In a real environment, obj1's entry would be gone after GC runs\n    obj1 = { id: 'object-1' }; // This is a new object with the same id\n    \n    console.log(\n      `After cleanup: Has data for obj1: ${cache.has(obj1)}, ` +\n      `Has data for obj2: ${cache.has(obj2)}`\n    );\n  }, 100);\n  \n  return 'WeakMap demo running...';\n}\n\nweakMapDemo();"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "Which of the following most accurately describes a secure approach to storing JWT secrets in a Node.js application?",
      "options": {
        "A": "Store the JWT secret directly in the application code for maximum performance",
        "B": "Store the JWT secret in version control with the application to ensure consistency across deployments",
        "C": "Store the JWT secret in environment variables loaded at runtime and never log the value",
        "D": "Store the JWT secret in a database table that the application can access at startup"
      },
      "correct_answer": "C"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "What will be the output of this code that encrypts and decrypts sensitive data using Node.js's crypto module?",
      "options": {
        "A": "Original: sensitive data\nEncrypted: (encrypted buffer)\nDecrypted: corrupted data",
        "B": "Original: sensitive data\nEncrypted: (encrypted buffer)\nDecrypted: sensitive data",
        "C": "Error: Invalid IV length",
        "D": "Error: crypto.createCipheriv is not a function"
      },
      "correct_answer": "B",
      "code_example": "const crypto = require('crypto');\n\nfunction encryptionDemo() {\n  const sensitiveData = 'sensitive data';\n  console.log('Original:', sensitiveData);\n  \n  // Generate a secure encryption key (32 bytes for AES-256)\n  const key = crypto.randomBytes(32);\n  \n  // Generate a random initialization vector\n  const iv = crypto.randomBytes(16);\n  \n  // Encrypt the data\n  function encrypt(text) {\n    // Create cipher with AES-256-CBC algorithm\n    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n    \n    // Update cipher with data and finalize\n    let encrypted = cipher.update(text, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    // Return both the IV and encrypted data (both needed for decryption)\n    return {\n      iv: iv.toString('hex'),\n      encryptedData: encrypted\n    };\n  }\n  \n  // Decrypt the data\n  function decrypt(encryptedObj) {\n    // Convert hex strings back to buffers\n    const ivBuffer = Buffer.from(encryptedObj.iv, 'hex');\n    \n    // Create decipher\n    const decipher = crypto.createDecipheriv('aes-256-cbc', key, ivBuffer);\n    \n    // Update decipher with encrypted data and finalize\n    let decrypted = decipher.update(encryptedObj.encryptedData, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  }\n  \n  // Encrypt the sensitive data\n  const encrypted = encrypt(sensitiveData);\n  console.log('Encrypted:', encrypted);\n  \n  // Decrypt the data\n  const decrypted = decrypt(encrypted);\n  console.log('Decrypted:', decrypted);\n  \n  return decrypted === sensitiveData ? \n    'Original data successfully recovered' : \n    'Decryption failed';\n}\n\nencryptionDemo();"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "Which statement accurately describes a key difference between WebSockets, REST, and GraphQL?",
      "options": {
        "A": "REST supports real-time bidirectional communication, while WebSockets and GraphQL are request-response based",
        "B": "WebSockets maintain a persistent connection allowing real-time bidirectional communication, while REST and GraphQL are primarily request-response based",
        "C": "GraphQL requires WebSockets for operation, while REST can work with standard HTTP",
        "D": "REST and GraphQL both require persistent connections, while WebSockets work over standard HTTP requests"
      },
      "correct_answer": "B"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "What will be the output of this code implementing a basic WebSocket server with socket.io?",
      "options": {
        "A": "Error: Cannot set socket.io listeners after app is initialized",
        "B": "Error: socket.io requires WebSocket protocol support",
        "C": "Server listening on *:3000\nUser connected\nMessage: Hello Server\nUser disconnected",
        "D": "The server will start but clients will not be able to connect due to missing CORS configuration"
      },
      "correct_answer": "C",
      "code_example": "const express = require('express');\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nfunction socketIODemo() {\n  const app = express();\n  const server = http.createServer(app);\n  const io = new Server(server);\n  \n  // Serve a simple HTML page\n  app.get('/', (req, res) => {\n    res.send(`\n      <!DOCTYPE html>\n      <html>\n        <head>\n          <title>Socket.IO Demo</title>\n        </head>\n        <body>\n          <h1>Socket.IO Demo</h1>\n          <script src=\"/socket.io/socket.io.js\"></script>\n          <script>\n            const socket = io();\n            \n            // Connect to the server\n            socket.on('connect', () => {\n              console.log('Connected to server');\n              \n              // Send a message to the server\n              socket.emit('chat message', 'Hello Server');\n              \n              // Disconnect after a short delay\n              setTimeout(() => socket.disconnect(), 1000);\n            });\n            \n            // Listen for messages from the server\n            socket.on('chat message', (msg) => {\n              console.log('Message from server:', msg);\n            });\n          </script>\n        </body>\n      </html>\n    `);\n  });\n  \n  // Set up Socket.IO event handlers\n  io.on('connection', (socket) => {\n    console.log('User connected');\n    \n    // Handle chat messages\n    socket.on('chat message', (msg) => {\n      console.log('Message:', msg);\n      \n      // Echo the message back to the client\n      socket.emit('chat message', 'Server received: ' + msg);\n    });\n    \n    // Handle disconnect\n    socket.on('disconnect', () => {\n      console.log('User disconnected');\n    });\n  });\n  \n  // Start the server\n  server.listen(3000, () => {\n    console.log('Server listening on *:3000');\n  });\n  \n  // In a real implementation, we would expose a function to close the server\n  // For this example, we'll let the server run until the process exits\n  \n  return 'Socket.IO server demo running...';\n}\n\n// Note: For this test, we're simulating the output rather than running a real server\nconsole.log('Server listening on *:3000');\nconsole.log('User connected');\nconsole.log('Message: Hello Server');\nconsole.log('User disconnected');"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "Which of the following is the most effective approach to preventing CORS vulnerabilities in a Node.js API?",
      "options": {
        "A": "Set Access-Control-Allow-Origin to '*' to ensure compatibility with all clients",
        "B": "Implement specific origin whitelisting, credential policies, and limit exposed headers based on security requirements",
        "C": "Disable CORS entirely to prevent any cross-origin requests",
        "D": "Use a VPN to secure all API communications instead of relying on CORS"
      },
      "correct_answer": "B"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "Which CI/CD pipeline configuration for a Node.js application implements best practices for security and reliability?",
      "options": {
        "A": "Run tests locally before pushing to production; manually deploy when tests pass",
        "B": "Automatically deploy to production on each commit to the main branch without running tests",
        "C": "Run automated tests, security scans, and dependency checks in a staging environment, then deploy to production after manual approval",
        "D": "Deploy directly to production and run tests afterward to verify the deployment succeeded"
      },
      "correct_answer": "C"
    }
  ]
}
