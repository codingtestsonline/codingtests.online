{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled);",
      "options": {
        "A": "[1, 2, 3, 4, 5]",
        "B": "[2, 4, 6, 8, 10]",
        "C": "[1, 4, 9, 16, 25]",
        "D": "TypeError: numbers.map is not a function"
      },
      "correct_answer": "B"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What will the following code log to the console?",
      "code_example": "let x = 10;\nlet y = 5;\n\nif (x > y && y > 0) {\n  console.log('Both conditions met');\n} else {\n  console.log('At least one condition failed');\n}",
      "options": {
        "A": "Both conditions met",
        "B": "At least one condition failed",
        "C": "Nothing will be logged",
        "D": "SyntaxError: Unexpected token &&"
      },
      "correct_answer": "A"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "Which method is used to select a single HTML element by its ID?",
      "options": {
        "A": "document.querySelector('#elementId')",
        "B": "document.getElementByName('elementId')",
        "C": "document.getElementById('elementId')",
        "D": "document.selectElement('#elementId')"
      },
      "correct_answer": "C"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be logged to the console?",
      "code_example": "function greet(name = 'Guest') {\n  return `Hello, ${name}!`;\n}\n\nconsole.log(greet());",
      "options": {
        "A": "Hello, undefined!",
        "B": "Hello, !",
        "C": "Hello, Guest!",
        "D": "TypeError: Cannot read property 'name' of undefined"
      },
      "correct_answer": "C"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What is the output of this code using destructuring assignment?",
      "code_example": "const person = { name: 'Alice', age: 25, job: 'Developer' };\nconst { name, role = 'Employee' } = person;\n\nconsole.log(`${name} is a ${role}`);",
      "options": {
        "A": "Alice is a undefined",
        "B": "Alice is a Developer",
        "C": "Alice is a Employee",
        "D": "TypeError: Cannot destructure property 'role' of 'person' as it is undefined"
      },
      "correct_answer": "C"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code using async/await?",
      "code_example": "async function fetchData() {\n  return 'Data received';\n}\n\nasync function processData() {\n  const data = await fetchData();\n  console.log(data);\n}\n\nprocessData();",
      "options": {
        "A": "Promise { 'Data received' }",
        "B": "Data received",
        "C": "undefined",
        "D": "Error: await is only valid in async functions"
      },
      "correct_answer": "B"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What is the value of result after executing this code?",
      "code_example": "let count = 10;\nlet result = 0;\n\ncount += 5;\nresult = count;",
      "options": {
        "A": "10",
        "B": "5",
        "C": "15",
        "D": "undefined"
      },
      "correct_answer": "C"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "Which of the following correctly exports a function in Node.js using CommonJS?",
      "options": {
        "A": "export default function myFunction() {}",
        "B": "exports = { myFunction: function() {} }",
        "C": "module.exports = function myFunction() {}",
        "D": "exports.default = myFunction()"
      },
      "correct_answer": "C"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will be the output of this code using array filter?",
      "code_example": "const numbers = [1, 2, 3, 4, 5, 6];\nconst evenNumbers = numbers.filter(num => num % 2 === 0);\nconsole.log(evenNumbers);",
      "options": {
        "A": "[1, 3, 5]",
        "B": "[2, 4, 6]",
        "C": "[false, true, false, true, false, true]",
        "D": "[]"
      },
      "correct_answer": "B"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What will be logged to the console?",
      "code_example": "let x = 10;\n\nfunction test() {\n  let x = 20;\n  console.log(x);\n}\n\ntest();",
      "options": {
        "A": "10",
        "B": "20",
        "C": "undefined",
        "D": "ReferenceError: x is not defined"
      },
      "correct_answer": "B"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What is the final value of total after this code executes?",
      "code_example": "const numbers = [1, 2, 3, 4];\nconst total = numbers.reduce((sum, num) => sum + num, 0);",
      "options": {
        "A": "0",
        "B": "10",
        "C": "[1, 2, 3, 4]",
        "D": "24"
      },
      "correct_answer": "B"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "Which statement about arrow functions is correct?",
      "options": {
        "A": "Arrow functions have their own 'this' binding",
        "B": "Arrow functions cannot be used as constructors",
        "C": "Arrow functions always require parentheses around parameters",
        "D": "Arrow functions cannot access variables from their parent scope"
      },
      "correct_answer": "B"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will this code using the spread operator output?",
      "code_example": "const parts = ['shoulders', 'knees'];\nconst body = ['head', ...parts, 'toes'];\nconsole.log(body);",
      "options": {
        "A": "['head', ['shoulders', 'knees'], 'toes']",
        "B": "['head', 'shoulders', 'knees', 'toes']",
        "C": "TypeError: parts is not iterable",
        "D": "['head', 'shoulders,knees', 'toes']"
      },
      "correct_answer": "B"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "How would you correctly handle a rejected Promise using .catch()?",
      "code_example": "function fetchData() {\n  return new Promise((resolve, reject) => {\n    reject(new Error('Data not available'));\n  });\n}\n\nfetchData()\n  .then(data => console.log(data))\n  .catch(error => console.log(error.message));",
      "options": {
        "A": "undefined",
        "B": "Error object will be printed",
        "C": "Data not available",
        "D": "Nothing will be logged"
      },
      "correct_answer": "C"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What does the following code using Object destructuring log?",
      "code_example": "const settings = { theme: 'dark', fontSize: 14 };\nconst { theme, fontSize, animation = 'fade' } = settings;\n\nconsole.log(animation);",
      "options": {
        "A": "undefined",
        "B": "null",
        "C": "fade",
        "D": "ReferenceError: animation is not defined"
      },
      "correct_answer": "C"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "Which method prevents an event from propagating up the DOM tree?",
      "options": {
        "A": "event.stopBubbling()",
        "B": "event.cancelPropagation()",
        "C": "event.preventDefault()",
        "D": "event.stopPropagation()"
      },
      "correct_answer": "D"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What is the output of this code using optional chaining?",
      "code_example": "const user = {\n  profile: {\n    name: 'Alex'\n  }\n};\n\nconst admin = {\n  profile: null\n};\n\nconsole.log(user.profile?.name);\nconsole.log(admin.profile?.name);",
      "options": {
        "A": "Alex, TypeError",
        "B": "Alex, undefined",
        "C": "Alex, null",
        "D": "undefined, undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "What will be the result of the following code using implicit binding?",
      "code_example": "const person = {\n  name: 'John',\n  greet() {\n    return `Hello, ${this.name}`;\n  }\n};\n\nconst greetFunction = person.greet;\nconsole.log(greetFunction());",
      "options": {
        "A": "Hello, John",
        "B": "Hello, undefined",
        "C": "TypeError: Cannot read property 'name' of undefined",
        "D": "Hello, null"
      },
      "correct_answer": "B"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "Which HTTP status code should be returned when a requested resource is not found?",
      "options": {
        "A": "400",
        "B": "401",
        "C": "403",
        "D": "404"
      },
      "correct_answer": "D"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "What is the correct way to send a JSON response in Express.js?",
      "code_example": "app.get('/api/users', (req, res) => {\n  const users = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];\n  // Which line correctly sends the users as JSON?\n})",
      "options": {
        "A": "res.send(JSON.stringify(users))",
        "B": "res.json(users)",
        "C": "res.end(users)",
        "D": "res.writeJSON(users)"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "How would you handle a large file efficiently in Node.js?",
      "options": {
        "A": "Use fs.readFile to load the entire file into memory",
        "B": "Use streams to process the file in chunks",
        "C": "Load the file into a database first, then query it",
        "D": "Use synchronous file methods for guaranteed completion"
      },
      "correct_answer": "B"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What will be the output of this code using spread/rest operators?",
      "code_example": "function sum(...numbers) {\n  return numbers.reduce((total, num) => total + num, 0);\n}\n\nconst values = [1, 2, 3];\nconsole.log(sum(...values, 4));",
      "options": {
        "A": "6",
        "B": "10",
        "C": "[1, 2, 3, 4]",
        "D": "TypeError: numbers.reduce is not a function"
      },
      "correct_answer": "B"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What's wrong with the following authentication code?",
      "code_example": "const jwt = require('jsonwebtoken');\n\nfunction generateToken(user) {\n  return jwt.sign({ id: user.id }, 'mysecretkey');\n}",
      "options": {
        "A": "The secret key should not be hardcoded in the source code",
        "B": "The token doesn't have an expiration time",
        "C": "The jwt.sign method is being used incorrectly",
        "D": "Both A and B"
      },
      "correct_answer": "D"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "Which HTTP method is idempotent but not safe according to HTTP specifications?",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "OPTIONS"
      },
      "correct_answer": "C"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What is the output of this code using Object.create()?",
      "code_example": "const personProto = {\n  greet() {\n    return `Hello, ${this.name}`;\n  }\n};\n\nconst person = Object.create(personProto);\nperson.name = 'Alice';\n\nconsole.log(person.greet());",
      "options": {
        "A": "Hello, undefined",
        "B": "TypeError: person.greet is not a function",
        "C": "Hello, Alice",
        "D": "Hello, [object Object]"
      },
      "correct_answer": "C"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What's the issue with this input validation in Express.js?",
      "code_example": "app.post('/api/users', (req, res) => {\n  if (req.body.username && req.body.email) {\n    // Create user\n  } else {\n    res.status(400).json({ error: 'Missing required fields' });\n  }\n});",
      "options": {
        "A": "It doesn't validate the format of the email",
        "B": "It doesn't check for SQL injection attacks",
        "C": "It doesn't use middleware for validation",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will be logged to the console in this code using Event Emitter?",
      "code_example": "const EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\nemitter.on('message', (msg) => {\n  console.log(`Received: ${msg}`);\n});\n\nemitter.emit('message', 'Hello');",
      "options": {
        "A": "Received: Hello",
        "B": "undefined",
        "C": "Received: [object Object]",
        "D": "Nothing will be logged"
      },
      "correct_answer": "A"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What's the most efficient way to check if at least one element in an array meets a condition?",
      "code_example": "const numbers = [1, 2, 3, 4, 5];\n\n// Which is most efficient for checking if any number is greater than 4?",
      "options": {
        "A": "numbers.filter(n => n > 4).length > 0",
        "B": "numbers.find(n => n > 4) !== undefined",
        "C": "numbers.some(n => n > 4)",
        "D": "numbers.forEach(n => { if (n > 4) return true; })"
      },
      "correct_answer": "C"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What does the compression middleware do in Express.js?",
      "options": {
        "A": "Encrypts request and response data",
        "B": "Compresses response bodies for all request that traverse through the middleware",
        "C": "Reduces the size of files stored on the server",
        "D": "Minifies JavaScript and CSS files"
      },
      "correct_answer": "B"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "Which statement about Streams and Buffers in Node.js is correct?",
      "options": {
        "A": "Buffers work with unicode strings only",
        "B": "Streams inherit from the Buffer class",
        "C": "Streams process data in chunks, reducing memory usage",
        "D": "Buffers are only used for network operations"
      },
      "correct_answer": "C"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will this code log?",
      "code_example": "const obj = {\n  async method() {\n    return 'result';\n  }\n};\n\nasync function run() {\n  const result = await obj.method();\n  console.log(result);\n}\n\nrun();",
      "options": {
        "A": "Promise { 'result' }",
        "B": "result",
        "C": "undefined",
        "D": "TypeError: obj.method is not a function"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "Which is NOT a valid way to prevent NoSQL injection in MongoDB?",
      "options": {
        "A": "Using schema validation with Mongoose",
        "B": "Using the sanitize-html package",
        "C": "Using parameterized queries with placeholders",
        "D": "Converting all input to lowercase using toLowerCase()"
      },
      "correct_answer": "D"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "Which of the following Referrer-Policy header values prevents the browser from sending any referrer information when navigating from HTTPS to HTTP?",
      "options": {
        "A": "no-referrer-when-downgrade",
        "B": "strict-origin",
        "C": "same-origin",
        "D": "no-referrer"
      },
      "correct_answer": "D"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates a common memory leak pattern?",
      "options": {
        "A": "The memory usage will remain stable",
        "B": "The memory usage will increase until the process crashes",
        "C": "Error: Maximum call stack size exceeded",
        "D": "The memory will be garbage collected properly"
      },
      "correct_answer": "B",
      "code_example": "const createMemoryLeak = () => {\n  const leakyArray = [];\n  const interval = setInterval(() => {\n    const largeObject = new Array(100000).fill('x');\n    leakyArray.push(largeObject);\n    console.log(`Memory usage: ${process.memoryUsage().heapUsed / 1024 / 1024} MB`);\n  }, 100);\n  \n  // Missing: clearInterval(interval);\n};\n\ncreateMemoryLeak();"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What will be the output of the following bcrypt comparison code?",
      "options": {
        "A": "true",
        "B": "false",
        "C": "Error: Invalid salt version",
        "D": "Error: Data and hash arguments required"
      },
      "correct_answer": "A",
      "code_example": "const bcrypt = require('bcrypt');\n\nasync function comparePasswords() {\n  const password = 'secure123';\n  const hash = '$2b$10$X4kv7j5MUUfJvDL.5WHyzOzqpQLRURQjwYDHZJ1zR6G4g66.O06FW';\n  \n  try {\n    const result = await bcrypt.compare(password, hash);\n    console.log(result);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\ncomparePasswords();"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "In the context of OAuth 2.0, which flow should be used for a single-page JavaScript application that needs to access a protected API on behalf of the user?",
      "options": {
        "A": "Authorization Code flow with PKCE",
        "B": "Client Credentials flow",
        "C": "Resource Owner Password Credentials flow",
        "D": "Device Code flow"
      },
      "correct_answer": "A"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "What will be the output of the following code that uses worker threads?",
      "options": {
        "A": "Main thread: 1, 2, 3, 4, 5 followed by Worker: 1, 2, 3, 4, 5",
        "B": "Worker: 1, 2, 3, 4, 5 followed by Main thread: 1, 2, 3, 4, 5",
        "C": "Interleaved output from both threads",
        "D": "Error: Worker is not defined"
      },
      "correct_answer": "C",
      "code_example": "const { Worker, isMainThread, parentPort } = require('worker_threads');\n\nif (isMainThread) {\n  const worker = new Worker(__filename);\n  \n  for (let i = 1; i <= 5; i++) {\n    console.log(`Main thread: ${i}`);\n    // Simulate some processing time\n    for (let j = 0; j < 1000000; j++) {}\n  }\n  \n  worker.on('message', (msg) => {\n    console.log(msg);\n  });\n} else {\n  for (let i = 1; i <= 5; i++) {\n    parentPort.postMessage(`Worker: ${i}`);\n    // Simulate some processing time\n    for (let j = 0; j < 1000000; j++) {}\n  }\n}"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "What is the most secure way to store JWT secrets in a Node.js application?",
      "options": {
        "A": "In a constants.js file within the project",
        "B": "In environment variables loaded from a .env file that is included in version control",
        "C": "In environment variables loaded from a secure external service like AWS Secrets Manager",
        "D": "Hard-coded in the application's main entry point file"
      },
      "correct_answer": "C"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates a transform stream?",
      "options": {
        "A": "HELLO WORLD",
        "B": "hello world",
        "C": "Error: stream.Transform is not a constructor",
        "D": "h-e-l-l-o- -w-o-r-l-d"
      },
      "correct_answer": "A",
      "code_example": "const { Transform } = require('stream');\n\nconst upperCaseTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    callback(null, chunk.toString().toUpperCase());\n  }\n});\n\nconst inputString = 'hello world';\nconst inputBuffer = Buffer.from(inputString);\n\nupperCaseTransform.on('data', (chunk) => {\n  console.log(chunk.toString());\n});\n\nupperCaseTransform.write(inputBuffer);\nupperCaseTransform.end();"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates XSS vulnerability prevention?",
      "options": {
        "A": "<script>alert('XSS')</script>",
        "B": "alert('XSS')",
        "C": "&lt;script&gt;alert('XSS')&lt;/script&gt;",
        "D": "Error: escapeHtml is not defined"
      },
      "correct_answer": "C",
      "code_example": "function escapeHtml(unsafeText) {\n  return unsafeText\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n}\n\nconst userInput = \"<script>alert('XSS')</script>\";\nconst safeOutput = escapeHtml(userInput);\nconsole.log(safeOutput);"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "Which of the following is NOT a valid configuration for winston logger in Node.js?",
      "options": {
        "A": "Setting up multiple transports for different log levels",
        "B": "Using custom formatters for log messages",
        "C": "Configuring log rotation based on file size",
        "D": "Using winston.intercept() to capture all console.log statements"
      },
      "correct_answer": "D",
      "code_example": "const winston = require('winston');\nconst { format, transports } = winston;\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: format.combine(\n    format.timestamp(),\n    format.json()\n  ),\n  defaultMeta: { service: 'user-service' },\n  transports: [\n    new transports.File({ filename: 'error.log', level: 'error' }),\n    new transports.File({ filename: 'combined.log' }),\n    new transports.Console({\n      format: format.combine(\n        format.colorize(),\n        format.simple()\n      )\n    })\n  ]\n});\n\n// This is valid\nlogger.info('Hello, winston!');\n\n// This would be invalid - winston.intercept() doesn't exist\n// winston.intercept(console.log);"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "What will be the output of the following code using express-rate-limit?",
      "options": {
        "A": "All requests will return 'Success' because the rate limit wasn't reached",
        "B": "The first 5 requests return 'Success', then all subsequent requests return 'Too many requests'",
        "C": "The first 3 requests return 'Success', then all subsequent requests return 'Too many requests'",
        "D": "Error: limiter is not a function"
      },
      "correct_answer": "B",
      "code_example": "const express = require('express');\nconst rateLimit = require('express-rate-limit');\n\nconst app = express();\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // limit each IP to 5 requests per windowMs\n  message: 'Too many requests'\n});\n\napp.use(limiter);\n\napp.get('/', (req, res) => {\n  res.send('Success');\n});\n\n// Simulating requests from same IP\nconst axios = require('axios');\n\nasync function makeRequests() {\n  for (let i = 1; i <= 10; i++) {\n    try {\n      const response = await axios.get('http://localhost:3000/');\n      console.log(`Request ${i}: ${response.data}`);\n    } catch (error) {\n      console.log(`Request ${i}: ${error.response.data}`);\n    }\n  }\n}\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n  makeRequests();\n});"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What is the primary difference between horizontal and vertical scaling in a Node.js application?",
      "options": {
        "A": "Horizontal scaling means adding more CPU cores to a single server, while vertical scaling means adding more servers",
        "B": "Horizontal scaling means adding more servers to distribute load, while vertical scaling means adding more resources (CPU, RAM) to existing servers",
        "C": "Horizontal scaling refers to using the cluster module, while vertical scaling uses worker threads",
        "D": "Horizontal scaling refers to increasing disk capacity, while vertical scaling refers to increasing memory capacity"
      },
      "correct_answer": "B"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "What will be the output of the following code that creates a cluster of workers?",
      "options": {
        "A": "Worker 1 started, Worker 2 started, Worker 3 started, Worker 4 started",
        "B": "Master started, Worker 1 started, Worker 2 started, Worker 3 started, Worker 4 started",
        "C": "Error: cluster.fork is not a function",
        "D": "The actual number of workers started will vary based on the number of CPU cores"
      },
      "correct_answer": "D",
      "code_example": "const cluster = require('cluster');\nconst os = require('os');\n\nif (cluster.isMaster) {\n  console.log('Master started');\n  \n  // Count the CPUs\n  const numCPUs = os.cpus().length;\n  \n  // Create a worker for each CPU\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  \n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n  });\n} else {\n  console.log(`Worker ${process.pid} started`);\n  \n  // Workers can share any TCP connection\n  // In this case it's an HTTP server\n  require('http').createServer((req, res) => {\n    res.writeHead(200);\n    res.end('Hello World\\n');\n  }).listen(8000);\n}"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates a closure-based memory leak prevention?",
      "options": {
        "A": "Event listener removed",
        "B": "Button clicked!",
        "C": "Uncaught ReferenceError: document is not defined",
        "D": "Error: Maximum call stack size exceeded"
      },
      "correct_answer": "A",
      "code_example": "// Mock DOM environment for Node.js\nclass Element {\n  constructor(type) {\n    this.type = type;\n    this.events = {};\n  }\n  \n  addEventListener(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(callback);\n    return callback; // Return for later removal\n  }\n  \n  removeEventListener(event, callback) {\n    if (this.events[event]) {\n      this.events[event] = this.events[event].filter(cb => cb !== callback);\n      return true;\n    }\n    return false;\n  }\n  \n  click() {\n    if (this.events['click']) {\n      this.events['click'].forEach(cb => cb());\n    }\n  }\n}\n\n// Create mock document and button\nconst document = {};\ndocument.createElement = (type) => new Element(type);\nconst button = document.createElement('button');\n\n// Create a component that properly cleans up\nfunction createComponent() {\n  let count = 0;\n  \n  // Store reference to the event listener for cleanup\n  const handleClick = () => {\n    count++;\n    console.log('Button clicked!');\n  };\n  \n  // Add event listener\n  const listener = button.addEventListener('click', handleClick);\n  \n  // Cleanup function\n  return function cleanup() {\n    button.removeEventListener('click', listener);\n    console.log('Event listener removed');\n  };\n}\n\n// Use the component and clean up\nconst cleanup = createComponent();\ncleanup();"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "Which X-Content-Type-Options header value prevents MIME type sniffing and ensures the declared Content-Type is followed?",
      "options": {
        "A": "strict",
        "B": "nosniff",
        "C": "follow-declared",
        "D": "prevent-mime-sniff"
      },
      "correct_answer": "B"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What is the correct YAML configuration for creating a Kubernetes Pod that runs a Node.js application?",
      "options": {
        "A": "apiVersion: v1\nkind: Pod\nspec:\n  containers:\n  - name: nodejs-app\n    image: my-nodejs-app:latest",
        "B": "apiVersion: v1\nkind: Pod\nmetadata:\n  name: nodejs-app-pod\nspec:\n  containers:\n  - name: nodejs-app\n    image: my-nodejs-app:latest\n    ports:\n    - containerPort: 3000",
        "C": "apiVersion: apps/v1\nkind: Pod\nmetadata:\n  name: nodejs-app-pod\nspec:\n  replicas: 3\n  containers:\n  - name: nodejs-app\n    image: my-nodejs-app:latest",
        "D": "apiVersion: v1\nkind: Deployment\nmetadata:\n  name: nodejs-app\nspec:\n  containers:\n  - name: nodejs-app\n    image: my-nodejs-app:latest"
      },
      "correct_answer": "B"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "What will be the output of the following code demonstrating real-time data handling with streams?",
      "options": {
        "A": "data: 10, data: 20, data: 30, data: 40, data: 50, end",
        "B": "stream start, data: 10, data: 20, data: 30, data: 40, data: 50, stream end",
        "C": "Received: 10, Received: 20, Received: 30, Received: 40, Received: 50, Stream complete",
        "D": "Error: Invalid non-string/buffer chunk"
      },
      "correct_answer": "C",
      "code_example": "const { Readable, Writable } = require('stream');\n\n// Create a custom Readable stream that emits numbers\nclass NumberSource extends Readable {\n  constructor(options) {\n    super(options);\n    this.numbers = [10, 20, 30, 40, 50];\n    this.index = 0;\n  }\n  \n  _read() {\n    const timer = setTimeout(() => {\n      if (this.index < this.numbers.length) {\n        // Push the next number as a Buffer\n        this.push(Buffer.from(this.numbers[this.index].toString()));\n        this.index++;\n      } else {\n        // No more numbers, end the stream\n        this.push(null);\n        clearTimeout(timer);\n      }\n    }, 100);\n  }\n}\n\n// Create a custom Writable stream that processes the data\nclass NumberProcessor extends Writable {\n  constructor(options) {\n    super(options);\n  }\n  \n  _write(chunk, encoding, callback) {\n    const number = chunk.toString();\n    console.log(`Received: ${number}`);\n    callback();\n  }\n  \n  _final(callback) {\n    console.log('Stream complete');\n    callback();\n  }\n}\n\n// Create and connect the streams\nconst numberSource = new NumberSource();\nconst numberProcessor = new NumberProcessor();\n\nnumberSource.pipe(numberProcessor);"
    }
  ]
}
