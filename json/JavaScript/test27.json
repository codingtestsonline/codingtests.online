{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(5 & 3);",
      "options": {
        "A": "8",
        "B": "1",
        "C": "2",
        "D": "15"
      },
      "correct_answer": "B"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What will the following code log to the console?",
      "code_example": "const arr = [1, 2, 3, 4, 5];\nconst [first, ...rest] = arr;\nconsole.log(rest);",
      "options": {
        "A": "[1]",
        "B": "[2, 3, 4, 5]",
        "C": "[1, 2, 3, 4]",
        "D": "ReferenceError"
      },
      "correct_answer": "B"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "Which statement correctly exports a function in a Node.js module?",
      "options": {
        "A": "exports = myFunction;",
        "B": "export default myFunction;",
        "C": "module.exports = myFunction;",
        "D": "export.module = myFunction;"
      },
      "correct_answer": "C"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let x = 5;\nlet result = x > 10 ? 'Greater' : 'Lesser';\nconsole.log(result);",
      "options": {
        "A": "5",
        "B": "Greater",
        "C": "Lesser",
        "D": "undefined"
      },
      "correct_answer": "C"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "const nums = [10, 20, 30];\nnums.push(40);\nnums.shift();\nconsole.log(nums);",
      "options": {
        "A": "[10, 20, 30, 40]",
        "B": "[10, 20, 30]",
        "C": "[20, 30, 40]",
        "D": "[40, 10, 20, 30]"
      },
      "correct_answer": "C"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What does the following code log to the console?",
      "code_example": "const person = { name: 'John', age: 30 };\nconst { name, job = 'Developer' } = person;\nconsole.log(job);",
      "options": {
        "A": "undefined",
        "B": "null",
        "C": "Developer",
        "D": "ReferenceError"
      },
      "correct_answer": "C"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(5 | 3);",
      "options": {
        "A": "7",
        "B": "2",
        "C": "15",
        "D": "8"
      },
      "correct_answer": "A"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "Which of the following is NOT a primitive type in JavaScript?",
      "options": {
        "A": "string",
        "B": "symbol",
        "C": "object",
        "D": "bigint"
      },
      "correct_answer": "C"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "(function() {\n  console.log('Hello World');\n})();",
      "options": {
        "A": "Function definition",
        "B": "Nothing, it will throw an error",
        "C": "Hello World",
        "D": "undefined"
      },
      "correct_answer": "C"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What will be the result of the following expression?",
      "code_example": "console.log(true && false || true);",
      "options": {
        "A": "false",
        "B": "true",
        "C": "undefined",
        "D": "Error"
      },
      "correct_answer": "B"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "Which method of the http module is used to create a server in Node.js?",
      "options": {
        "A": "http.makeServer()",
        "B": "http.createServer()",
        "C": "http.newServer()",
        "D": "http.startServer()"
      },
      "correct_answer": "B"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will the following code log to the console?",
      "code_example": "const numbers = [1, 2, 3, 4];\nconst sliced = numbers.slice(1, 3);\nconsole.log(sliced);",
      "options": {
        "A": "[1, 2]",
        "B": "[2, 3]",
        "C": "[1, 2, 3]",
        "D": "[2, 3, 4]"
      },
      "correct_answer": "B"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What is the difference between require() and import() in JavaScript?",
      "options": {
        "A": "require() is synchronous while import() is asynchronous",
        "B": "require() works only in the browser while import() works only in Node.js",
        "C": "require() can be used conditionally while import() cannot",
        "D": "There is no difference, they are interchangeable"
      },
      "correct_answer": "A"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "let num = 5;\nnum <<= 2;\nconsole.log(num);",
      "options": {
        "A": "7",
        "B": "10",
        "C": "20",
        "D": "2"
      },
      "correct_answer": "C"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "Which of the following is the correct way to add an event listener to a button element with id 'myButton'?",
      "options": {
        "A": "document.getElementById('myButton').addEventListener('click', handleClick);",
        "B": "document.getElementById('myButton').addEvent('click', handleClick);",
        "C": "document.getElementById('myButton').onclick(handleClick);",
        "D": "document.addEvent('click', 'myButton', handleClick);"
      },
      "correct_answer": "A"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What will the following code output?",
      "code_example": "function greeting() {\n  return 'Hello';\n}\n\nconst sayHello = function() {\n  return 'Hi';\n};\n\nconsole.log(typeof greeting, typeof sayHello);",
      "options": {
        "A": "'function' 'object'",
        "B": "'object' 'function'",
        "C": "'function' 'function'",
        "D": "'object' 'object'"
      },
      "correct_answer": "C"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What will the following code output after 2 seconds?",
      "code_example": "let counter = 0;\nconst interval = setInterval(() => {\n  counter++;\n  if (counter === 2) {\n    clearInterval(interval);\n    console.log(counter);\n  }\n}, 1000);",
      "options": {
        "A": "1",
        "B": "2",
        "C": "undefined",
        "D": "The code will run indefinitely"
      },
      "correct_answer": "B"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "What will be the result of the following code?",
      "code_example": "function createCounter() {\n  let count = 0;\n  return function() {\n    return ++count;\n  };\n}\n\nconst counter1 = createCounter();\nconst counter2 = createCounter();\n\nconsole.log(counter1(), counter1(), counter2());",
      "options": {
        "A": "1 1 1",
        "B": "1 2 1",
        "C": "1 2 3",
        "D": "0 1 0"
      },
      "correct_answer": "B"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What is the correct way to validate that a request parameter 'id' is a numeric value using express-validator?",
      "options": {
        "A": "req.checkParams('id').isNumeric();",
        "B": "check('id').isNumeric();",
        "C": "req.validate('id').isNumeric();",
        "D": "validator.check('id').isNumeric();"
      },
      "correct_answer": "B"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "What will the following code output?",
      "code_example": "const user = {\n  name: 'John',\n  address: null\n};\n\nconsole.log(user?.address?.street);",
      "options": {
        "A": "null",
        "B": "undefined",
        "C": "TypeError",
        "D": "''"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "Which method would you use to read a large file efficiently without loading the entire file into memory?",
      "options": {
        "A": "fs.readFile()",
        "B": "fs.readFileSync()",
        "C": "fs.createReadStream()",
        "D": "fs.readChunk()"
      },
      "correct_answer": "C"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What will the following code output?",
      "code_example": "function greet(name, greeting = 'Hello') {\n  return `${greeting}, ${name}!`;\n}\n\nconsole.log(greet('John', undefined));",
      "options": {
        "A": "undefined, John!",
        "B": "Hello, John!",
        "C": "Hello, undefined!",
        "D": "undefined, undefined!"
      },
      "correct_answer": "B"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What is the best way to prevent NoSQL injection in a MongoDB query?",
      "options": {
        "A": "Use parameterized queries",
        "B": "Sanitize user input with a library like sanitize-html",
        "C": "Only allow numeric inputs",
        "D": "Disable user input"
      },
      "correct_answer": "B"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const person = {\n  name: 'John',\n  sayHello: function() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n};\n\nconst greet = person.sayHello;\ngreet();",
      "options": {
        "A": "Hello, my name is John",
        "B": "Hello, my name is undefined",
        "C": "TypeError",
        "D": "Hello, my name is null"
      },
      "correct_answer": "B"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What is the correct way to set up API versioning in an Express application?",
      "options": {
        "A": "Use different port numbers for each API version",
        "B": "Include the version in the URL path (e.g., /api/v1/users)",
        "C": "Use a versioning query parameter (e.g., ?version=1)",
        "D": "All of the above are acceptable approaches"
      },
      "correct_answer": "D"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const numbers = [1, 2, 3];\nfunction sum(...args) {\n  return args.reduce((total, num) => total + num, 0);\n}\nconsole.log(sum(...numbers));",
      "options": {
        "A": "Error",
        "B": "6",
        "C": "3",
        "D": "[1, 2, 3]"
      },
      "correct_answer": "B"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "Which approach is correct for handling form data in Express?",
      "options": {
        "A": "app.use(express.bodyParser())",
        "B": "app.use(express.urlencoded({ extended: true }))",
        "C": "app.use(express.formData())",
        "D": "app.use(express.form())"
      },
      "correct_answer": "B"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What will the following code output?",
      "code_example": "function appendFile() {\n  const fs = require('fs');\n  try {\n    fs.appendFileSync('test.txt', 'New content');\n    return 'Success';\n  } catch(err) {\n    return 'Error';\n  }\n}\n\nconsole.log(appendFile());",
      "options": {
        "A": "undefined",
        "B": "'New content'",
        "C": "'Success'",
        "D": "'Error'"
      },
      "correct_answer": "C"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What's the correct way to define a Sequelize model for a 'users' table with 'name' and 'email' fields?",
      "options": {
        "A": "const User = sequelize.define('user', { name: Sequelize.STRING, email: Sequelize.STRING });",
        "B": "const User = Sequelize.model('user', { name: String, email: String });",
        "C": "const User = new Sequelize.Model('user', { name: 'STRING', email: 'STRING' });",
        "D": "const User = Sequelize.createModel('user', { name: Sequelize.TEXT, email: Sequelize.TEXT });"
      },
      "correct_answer": "A"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What will the following code output?",
      "code_example": "let animationId;\n\nfunction animate(timestamp) {\n  console.log('Animation frame');\n  animationId = requestAnimationFrame(animate);\n}\n\nanimationId = requestAnimationFrame(animate);\nsetTimeout(() => {\n  cancelAnimationFrame(animationId);\n  console.log('Animation stopped');\n}, 0);\n\nconsole.log('Script end');",
      "options": {
        "A": "'Script end' followed by 'Animation stopped'",
        "B": "'Script end' followed by 'Animation frame' followed by 'Animation stopped'",
        "C": "'Animation frame' followed by 'Script end' followed by 'Animation stopped'",
        "D": "'Script end' followed by multiple 'Animation frame' logs followed by 'Animation stopped'"
      },
      "correct_answer": "A"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const promise1 = Promise.resolve('First');\nconst promise2 = new Promise((resolve) => setTimeout(() => resolve('Second'), 100));\n\nPromise.all([promise1, promise2])\n  .then(results => console.log(results));",
      "options": {
        "A": "['First']",
        "B": "['Second']",
        "C": "['First', 'Second']",
        "D": "['Second', 'First']"
      },
      "correct_answer": "C"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What is the best implementation for lazy loading images in a web application?",
      "options": {
        "A": "Using the 'loading=\"lazy\"' attribute on img tags",
        "B": "Implementing an Intersection Observer to detect when images enter the viewport",
        "C": "Loading all images on page load using preload headers",
        "D": "Both A and B are correct approaches"
      },
      "correct_answer": "D"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "Which of the following is a valid use case for WeakMap that properly leverages its memory management capabilities?",
      "options": {
        "A": "Using WeakMap as a simple key-value store for string keys",
        "B": "Storing DOM element references as keys with associated metadata that should be garbage collected when the element is removed",
        "C": "Creating a permanent cache that should persist throughout the application lifecycle",
        "D": "Storing primitive values that need to be accessible globally"
      },
      "correct_answer": "B",
      "code_example": "// Example of proper WeakMap usage for DOM-related caching\nconst elementMetadata = new WeakMap();\n\nfunction processElement(element) {\n  // Only store metadata for elements we haven't processed\n  if (!elementMetadata.has(element)) {\n    elementMetadata.set(element, {\n      processedAt: Date.now(),\n      originalContent: element.innerHTML\n    });\n  }\n  \n  // Do something with the element...\n  return elementMetadata.get(element);\n}\n\n// Later, when element is removed from DOM and has no references:\n// the WeakMap entry is automatically garbage collected\n// without needing manual cleanup"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "What is the output of the following Transform stream code?",
      "options": {
        "A": "HELLO\\nWORLD",
        "B": "hello\\nworld",
        "C": "hello\\nWORLD",
        "D": "HELLO WORLD"
      },
      "correct_answer": "A",
      "code_example": "const { Transform } = require('stream');\nconst { pipeline } = require('stream/promises');\nconst fs = require('fs');\n\nconst upperCaseTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    callback(null, chunk.toString().toUpperCase());\n  }\n});\n\n// Sample input file content: 'hello\\nworld'\n// This would run in an async function:\nasync function processStream() {\n  const readStream = fs.createReadStream('input.txt');\n  const writeStream = fs.createWriteStream('output.txt');\n  \n  await pipeline(readStream, upperCaseTransform, writeStream);\n  console.log(fs.readFileSync('output.txt', 'utf8'));\n}\n\n// Output would be:"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "Which of the following code patterns is MOST likely to cause a memory leak in a Node.js application?",
      "options": {
        "A": "Using global variables for configuration settings",
        "B": "Adding event listeners to DOM elements in a server-side environment",
        "C": "Creating closures that capture large objects and adding them to event emitters without proper removal",
        "D": "Using async/await pattern for handling promises"
      },
      "correct_answer": "C",
      "code_example": "const EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\nfunction createProcessingHandler(data) {\n  // data is a large object with many properties\n  const processedData = [...Array(10000)].map(() => ({ item: Math.random() }));\n  \n  // This function captures processedData in its closure\n  return function handler() {\n    console.log('Processing', data.id);\n    // Do something with processedData...\n  };\n}\n\nfunction setupHandlers() {\n  for (let i = 0; i < 1000; i++) {\n    const largeData = {\n      id: i,\n      content: Buffer.alloc(1024 * 1024) // 1MB buffer\n    };\n    \n    // Adding handler without storing reference to remove it later\n    emitter.on('process', createProcessingHandler(largeData));\n  }\n}\n\nsetupHandlers();\n// These handlers and their captured data remain in memory \n// even if they're never used again"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "When configuring Winston for logging in a production Node.js application, which of the following approaches provides the BEST balance of performance and useful diagnostic information?",
      "options": {
        "A": "Using Console transport with debug level for all environments",
        "B": "Using File transport with error level only and no request context",
        "C": "Using multiple transports with different log levels, including a performance-optimized JSON format for production with request IDs and contextual metadata",
        "D": "Disabling logging in production to maximize performance"
      },
      "correct_answer": "C",
      "code_example": "const winston = require('winston');\nconst { format, transports } = winston;\nconst expressWinston = require('express-winston');\n\n// Setup request ID middleware\napp.use((req, res, next) => {\n  req.requestId = crypto.randomUUID();\n  next();\n});\n\nconst logger = winston.createLogger({\n  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',\n  format: format.combine(\n    format.timestamp(),\n    format.errors({ stack: true }),\n    format.metadata(),\n    process.env.NODE_ENV === 'production'\n      ? format.json()\n      : format.prettyPrint()\n  ),\n  defaultMeta: { service: 'user-service' },\n  transports: [\n    // Console output for development\n    process.env.NODE_ENV !== 'production' && \n      new transports.Console(),\n      \n    // File transport for errors (all environments)\n    new transports.File({ \n      filename: 'error.log', \n      level: 'error',\n      maxsize: 10485760, // 10MB\n      maxFiles: 5\n    }),\n      \n    // Production file transport with rotation\n    process.env.NODE_ENV === 'production' &&\n      new transports.File({ \n        filename: 'combined.log',\n        maxsize: 10485760, // 10MB\n        maxFiles: 5\n      })\n  ].filter(Boolean)\n});\n\n// Express winston logger with request context\napp.use(expressWinston.logger({\n  winstonInstance: logger,\n  meta: true,\n  msg: 'HTTP {{req.method}} {{req.url}}',\n  expressFormat: true,\n  dynamicMeta: (req, res) => {\n    return {\n      requestId: req.requestId,\n      userId: req.user?.id\n    };\n  }\n}));"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "Which of the following code snippets correctly implements secure password hashing using Node.js crypto module?",
      "options": {
        "A": "const hash = crypto.createHash('md5').update(password).digest('hex');",
        "B": "const hash = crypto.createHash('sha256').update(password).digest('hex');",
        "C": "const hash = crypto.createHash('sha512').update(password + 'salt').digest('hex');",
        "D": "const hash = crypto.pbkdf2Sync(password, crypto.randomBytes(16), 1000, 64, 'sha512').toString('hex');"
      },
      "correct_answer": "D",
      "code_example": "const crypto = require('crypto');\n\n// Securely store a password\nfunction hashPassword(password) {\n  // Generate a random salt\n  const salt = crypto.randomBytes(16).toString('hex');\n  \n  // Hash the password with the salt using PBKDF2\n  const hash = crypto.pbkdf2Sync(password, salt, 1000, 64, 'sha512').toString('hex');\n  \n  // Return both salt and hash for storage\n  return { salt, hash };\n}\n\n// Verify a password against stored hash\nfunction verifyPassword(password, storedSalt, storedHash) {\n  // Hash the provided password with the same salt\n  const hash = crypto.pbkdf2Sync(password, storedSalt, 1000, 64, 'sha512').toString('hex');\n  \n  // Compare the generated hash with the stored hash\n  return hash === storedHash;\n}\n\n// Example usage\nconst storeUserPassword = (user, password) => {\n  const { salt, hash } = hashPassword(password);\n  // Store user with salt and hash in database\n  // db.saveUser({ ...user, passwordSalt: salt, passwordHash: hash });\n};\n\nconst authenticateUser = (username, password) => {\n  // Get user from database with username\n  // const user = db.getUserByUsername(username);\n  // if (!user) return false;\n  // return verifyPassword(password, user.passwordSalt, user.passwordHash);\n};"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "When configuring Helmet.js for a Node.js Express application, which of the following Content Security Policy (CSP) directives provides the STRONGEST protection against XSS attacks while still allowing necessary functionality?",
      "options": {
        "A": "Disabling CSP entirely to ensure application compatibility",
        "B": "Using default-src 'self' with no other directives",
        "C": "Using default-src 'none'; script-src 'self'; connect-src 'self'; img-src 'self'; style-src 'self'; base-uri 'self'; form-action 'self'",
        "D": "Using default-src 'self' 'unsafe-inline' 'unsafe-eval' *"
      },
      "correct_answer": "C"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "What will be the console output of the following Socket.io code when a client connects, sends a message, and disconnects?",
      "options": {
        "A": "New connection\\nMessage: Hello\\nClient disconnected",
        "B": "socket connected\\nmessage received: Hello\\nsocket disconnect",
        "C": "Connection established\\nServer received: Hello\\nConnection terminated",
        "D": "connect event\\nHello\\ndisconnect event"
      },
      "correct_answer": "B",
      "code_example": "// Server-side code\nconst express = require('express');\nconst app = express();\nconst http = require('http').createServer(app);\nconst io = require('socket.io')(http);\n\nio.on('connection', (socket) => {\n  console.log('socket connected');\n  \n  socket.on('chat message', (msg) => {\n    console.log('message received:', msg);\n    // Echo the message back to the client\n    socket.emit('chat message', `Server: ${msg}`);\n  });\n  \n  socket.on('disconnect', () => {\n    console.log('socket disconnect');\n  });\n});\n\nhttp.listen(3000, () => {\n  console.log('listening on *:3000');\n});\n\n// Client-side code (for reference)\n/*\nconst socket = io();\n// Connect automatically when instantiated\n// Then send a message\nsocket.emit('chat message', 'Hello');\n// Later, when closing the connection\nsocket.disconnect();\n*/\n\n// Console output when connecting, sending 'Hello', and disconnecting:"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "Which statement about hidden classes and inline caching in JavaScript engines like V8 is TRUE?",
      "options": {
        "A": "Hidden classes are only used for ES6 classes, not for objects created with object literals",
        "B": "Adding properties to objects in the same order is irrelevant to the JavaScript engine's optimization",
        "C": "Hidden classes are used by JavaScript engines to optimize property access by maintaining a consistent shape for similar objects",
        "D": "Inline caching always improves performance regardless of how objects are created and modified"
      },
      "correct_answer": "C",
      "code_example": "// Example demonstrating hidden class optimizations\n\n// Good for optimization: consistent property order\nfunction createOptimizedPoint(x, y) {\n  const point = {};\n  point.x = x;  // First property added is always 'x'\n  point.y = y;  // Second property added is always 'y'\n  return point;\n}\n\n// Bad for optimization: inconsistent property order\nfunction createUnoptimizedPoint(x, y) {\n  if (x > 0) {\n    const point = {};\n    point.x = x;\n    point.y = y;\n    return point;\n  } else {\n    const point = {};\n    point.y = y;  // First property is 'y' in this branch\n    point.x = x;  // Second property is 'x' in this branch\n    return point;\n  }\n}\n\n// This function has predictable behavior for V8 to optimize\nfunction distanceFromOrigin(point) {\n  return Math.sqrt(point.x * point.x + point.y * point.y);\n}\n\n// Creating points with the same hidden class\nconst points = [];\nfor (let i = 0; i < 1000; i++) {\n  points.push(createOptimizedPoint(i, i * 2));\n}\n\n// V8 can inline cache the property accesses in distanceFromOrigin\n// because all points share the same hidden class\npoints.forEach(point => distanceFromOrigin(point));"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "Which of the following docker-compose.yml configurations BEST implements a secure, production-ready Node.js application with proper environment isolation, named volumes, and resource constraints?",
      "options": {
        "A": "A single-service configuration with the environment variables directly embedded in the file",
        "B": "A multi-service configuration using named volumes, environment files, resource limits, healthchecks, and proper networking isolation",
        "C": "A configuration that mounts the entire project directory into the container and runs with root privileges for maximum flexibility",
        "D": "A basic configuration that only defines the image and port mapping without volumes or environment configuration"
      },
      "correct_answer": "B",
      "code_example": "version: '3.8'\n\nservices:\n  node-app:\n    build:\n      context: ./\n      dockerfile: Dockerfile\n    image: my-node-app:${TAG:-latest}\n    container_name: node-app\n    restart: unless-stopped\n    env_file: .env.production\n    environment:\n      - NODE_ENV=production\n    volumes:\n      - node_modules:/app/node_modules\n      - uploads:/app/uploads\n      - logs:/app/logs\n    ports:\n      - \"3000:3000\"\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 30s\n    deploy:\n      resources:\n        limits:\n          cpus: '0.5'\n          memory: 1G\n        reservations:\n          cpus: '0.25'\n          memory: 512M\n    networks:\n      - app-network\n    depends_on:\n      - mongodb\n      - redis\n      \n  mongodb:\n    image: mongo:5.0\n    container_name: mongodb\n    restart: unless-stopped\n    env_file: .env.production\n    volumes:\n      - mongodb_data:/data/db\n    networks:\n      - app-network\n    command: [\"--auth\"]\n    healthcheck:\n      test: echo 'db.runCommand(\"ping\").ok' | mongo localhost:27017/test --quiet\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 30s\n      \n  redis:\n    image: redis:alpine\n    container_name: redis\n    restart: unless-stopped\n    volumes:\n      - redis_data:/data\n    networks:\n      - app-network\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\nvolumes:\n  node_modules:\n  uploads:\n  logs:\n  mongodb_data:\n  redis_data:\n\nnetworks:\n  app-network:\n    driver: bridge"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "Which CI/CD pipeline configuration for a Node.js application provides the MOST comprehensive quality assurance and security checks before deployment?",
      "options": {
        "A": "A pipeline that only runs tests on the main branch before deployment",
        "B": "A pipeline that runs linting, testing, security scanning, and deployment with proper staging environments and approval gates",
        "C": "A pipeline that automates deployment directly to production on every commit",
        "D": "A pipeline that only performs code review without automated testing"
      },
      "correct_answer": "B"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "When deploying a Node.js application, which platform offers the BEST combination of scalability, observability, and DevOps automation capabilities?",
      "options": {
        "A": "Heroku, with its simple Git-based deployments but limited customization",
        "B": "Vercel, with its focus on frontend and serverless applications",
        "C": "DigitalOcean Kubernetes, providing full container orchestration with custom configurations and monitoring integration",
        "D": "A shared hosting provider with cPanel access"
      },
      "correct_answer": "C"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "What is the correct combination of security headers to protect against clickjacking, MIME-type sniffing, and information leakage in a Node.js Express application?",
      "options": {
        "A": "X-Frame-Options: SAMEORIGIN; X-Content-Type-Options: nosniff; Referrer-Policy: no-referrer-when-downgrade",
        "B": "X-Frame-Options: DENY; X-Content-Type-Options: nosniff; Referrer-Policy: strict-origin-when-cross-origin",
        "C": "X-Frame-Options: ALLOW; Content-Security-Policy: default-src 'self'; Referrer-Policy: unsafe-url",
        "D": "Content-Security-Policy: frame-ancestors 'none'; X-Content-Options: safe; Referrer: strict-origin"
      },
      "correct_answer": "B",
      "code_example": "const express = require('express');\nconst app = express();\n\n// Setting security headers manually\napp.use((req, res, next) => {\n  // Prevent site from being embedded in iframes on other domains (clickjacking protection)\n  res.setHeader('X-Frame-Options', 'DENY');\n  \n  // Prevent browsers from interpreting files as a different MIME type\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  \n  // Control how much referrer information is included with requests\n  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');\n  \n  // Additional security headers that would be good to include\n  res.setHeader('Content-Security-Policy', \"default-src 'self'; script-src 'self'\");\n  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');\n  res.setHeader('Permissions-Policy', 'camera=(), microphone=(), geolocation=()'); \n  \n  next();\n});\n\n// Alternatively, using helmet which sets these automatically:\n/*\nconst helmet = require('helmet');\napp.use(helmet({\n  frameguard: { action: 'deny' },\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\"]\n    }\n  },\n  referrerPolicy: { policy: 'strict-origin-when-cross-origin' }\n}));\n*/\n\napp.get('/', (req, res) => {\n  res.send('Hello, secure world!');\n});"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What will be the console output of the following Node.js code for handling unhandled promise rejections?",
      "options": {
        "A": "Starting...\\nUnhandled promise rejection: Database connection failed",
        "B": "Starting...\\nError: Database connection failed",
        "C": "Starting...\\nError: Database connection failed\\nProcess exiting...",
        "D": "Starting...\\n[UnhandledPromiseRejection: Database connection failed]\\nProcess exiting..."
      },
      "correct_answer": "C",
      "code_example": "// Configuring global handler for unhandled promise rejections\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Error:', reason);\n  console.log('Process exiting...');\n  // In a real application, you might want to do cleanup before exiting\n  process.exit(1);\n});\n\nconsole.log('Starting...');\n\n// Simulating a database connection function that returns a promise\nfunction connectToDatabase() {\n  return new Promise((resolve, reject) => {\n    // Simulating a connection failure\n    setTimeout(() => {\n      reject(new Error('Database connection failed'));\n    }, 100);\n  });\n}\n\n// Using the promise without proper error handling\nconnectToDatabase();\n\n// Note: We're intentionally not using .catch() or try/catch with await\n// to demonstrate the unhandledRejection handler\n\n// Output:"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "What is the expected result of the following Node.js clustering code on a quad-core machine?",
      "options": {
        "A": "The server will run on a single process using only one CPU core",
        "B": "The server will automatically distribute requests across 4 worker processes, one for each CPU core",
        "C": "The code will fail because it's missing the required cluster initialization",
        "D": "The server will create an unlimited number of worker processes that could overwhelm the system"
      },
      "correct_answer": "B",
      "code_example": "const cluster = require('cluster');\nconst http = require('http');\nconst os = require('os');\n\nconst numCPUs = os.cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`Master process ${process.pid} is running`);\n\n  // Fork workers equal to number of CPUs\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died with code: ${code} and signal: ${signal}`);\n    console.log('Starting a new worker...');\n    cluster.fork();\n  });\n} else {\n  // Workers share the same server port\n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end(`Worker ${process.pid} handled the request\\n`);\n  }).listen(8000);\n\n  console.log(`Worker ${process.pid} started`);\n}\n\n// On a quad-core machine, this would result in:"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "Which of the following statements about JavaScript memory allocation is TRUE?",
      "options": {
        "A": "JavaScript objects are always allocated on the stack for performance",
        "B": "V8 allocates small objects in the young generation (nursery) and promotes long-lived objects to the old generation",
        "C": "JavaScript uses reference counting as its primary garbage collection mechanism",
        "D": "Memory in Node.js applications must be manually allocated and freed, similar to C++"
      },
      "correct_answer": "B",
      "code_example": "// This code demonstrates object allocation patterns in JavaScript\n\n// Small, short-lived objects allocated in young generation\nfunction processData(data) {\n  // These temporary objects will be allocated in young generation\n  // and likely be collected by the next minor GC\n  const results = [];\n  \n  for (let i = 0; i < data.length; i++) {\n    const processed = {\n      id: data[i].id,\n      value: data[i].value * 2,\n      timestamp: Date.now()\n    };\n    results.push(processed);\n  }\n  \n  return results;\n}\n\n// Long-lived cache object will be promoted to old generation\nconst cache = new Map();\n\nfunction getCachedResult(key, data) {\n  if (cache.has(key)) {\n    return cache.get(key);\n  }\n  \n  const result = processData(data);\n  // This cache entry will survive multiple GCs and be\n  // promoted to the old generation\n  cache.set(key, result);\n  \n  return result;\n}\n\n// Function that potentially causes memory issues\nfunction potentialMemoryProblem() {\n  const bigData = [];\n  \n  // Creating references to large objects and storing them\n  for (let i = 0; i < 10000; i++) {\n    const largeObject = new Array(10000).fill(Math.random());\n    bigData.push(largeObject);\n  }\n  \n  // If bigData is referenced elsewhere (e.g., in a closure)\n  // these objects will stay in memory\n  return function() {\n    return bigData.length;\n  };\n}"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "Which statement BEST describes the key differences between WebSockets, REST, and GraphQL in the context of client-server communication?",
      "options": {
        "A": "WebSockets provide stateless request-response interactions, REST enables real-time bidirectional communication, and GraphQL requires separate endpoints for each resource",
        "B": "WebSockets enable full-duplex communication maintaining a persistent connection, REST provides stateless interactions with standard HTTP methods, and GraphQL allows clients to request exactly the data they need in a single request",
        "C": "WebSockets are only suitable for mobile applications, REST is deprecated in modern web development, and GraphQL is only beneficial for large enterprise applications",
        "D": "WebSockets, REST, and GraphQL all use the same underlying HTTP/2 protocol and differ only in their data formats"
      },
      "correct_answer": "B"
    }
  ]
}
