{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(true && 'Hello World');",
      "options": {
        "A": "true",
        "B": "Hello World",
        "C": "true Hello World",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "Which of the following is the correct way to export a function from a module in Node.js?",
      "options": {
        "A": "exports = myFunction;",
        "B": "module.export = myFunction;",
        "C": "module.exports = myFunction;",
        "D": "exports.module = myFunction;"
      },
      "correct_answer": "C"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(false || 'Default Value');",
      "options": {
        "A": "false",
        "B": "true",
        "C": "Default Value",
        "D": "undefined"
      },
      "correct_answer": "C"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const person = { name: 'John', age: 30 };\nconst entries = Object.entries(person);\nconsole.log(entries);",
      "options": {
        "A": "{ name: 'John', age: 30 }",
        "B": "['name', 'age']",
        "C": "['John', 30]",
        "D": "[['name', 'John'], ['age', 30]]"
      },
      "correct_answer": "D"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What's the difference between '==' and '===' operators in JavaScript?",
      "options": {
        "A": "They are exactly the same",
        "B": "'==' compares values and types, '===' compares only values",
        "C": "'==' compares only values, '===' compares values and types",
        "D": "'==' is for assignment, '===' is for comparison"
      },
      "correct_answer": "C"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "for (let i = 0; i < 5; i++) {\n  if (i === 2) continue;\n  console.log(i);\n}",
      "options": {
        "A": "0 1 2 3 4",
        "B": "0 1 3 4",
        "C": "0 1 2",
        "D": "3 4"
      },
      "correct_answer": "B"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function executeCallback(cb) {\n  cb('Data');\n}\n\nexecuteCallback(function(data) {\n  console.log('Callback received: ' + data);\n});",
      "options": {
        "A": "Callback received: Data",
        "B": "Callback received: undefined",
        "C": "Data",
        "D": "function(data) { console.log('Callback received: ' + data); }"
      },
      "correct_answer": "A"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "console.log(hoistedFunction());\n\nfunction hoistedFunction() {\n  return 'I am hoisted!';\n}",
      "options": {
        "A": "undefined",
        "B": "I am hoisted!",
        "C": "ReferenceError",
        "D": "TypeError"
      },
      "correct_answer": "B"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const promise = new Promise((resolve) => {\n  resolve('Success!');\n});\n\npromise\n  .then(data => console.log(data))\n  .catch(err => console.log('Error:', err));",
      "options": {
        "A": "Error: undefined",
        "B": "Success!",
        "C": "undefined",
        "D": "Nothing, the code will run without logging anything"
      },
      "correct_answer": "B"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What's the main difference between `var` and `let` declarations?",
      "options": {
        "A": "`var` is block-scoped, `let` is function-scoped",
        "B": "`var` is function-scoped, `let` is block-scoped",
        "C": "`var` can be redeclared in the same scope, `let` cannot",
        "D": "Both B and C are correct"
      },
      "correct_answer": "D"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const obj1 = { a: 1, b: 2 };\nconst obj2 = { b: 3, c: 4 };\nconst combined = Object.assign({}, obj1, obj2);\nconsole.log(combined);",
      "options": {
        "A": "{ a: 1, b: 2, c: 4 }",
        "B": "{ a: 1, b: 3, c: 4 }",
        "C": "{ a: 1, b: 2, b: 3, c: 4 }",
        "D": "{ a: 1, c: 4 }"
      },
      "correct_answer": "B"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "Which of the following is NOT a valid field in package.json?",
      "options": {
        "A": "dependencies",
        "B": "scripts",
        "C": "imports",
        "D": "devDependencies"
      },
      "correct_answer": "C"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = [...arr1, ...arr2];\nconsole.log(combined);",
      "options": {
        "A": "[1, 2, 3, 4, 5, 6]",
        "B": "[[1, 2, 3], [4, 5, 6]]",
        "C": "[1, 2, 3, [4, 5, 6]]",
        "D": "[4, 5, 6, 1, 2, 3]"
      },
      "correct_answer": "A"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function greet(name = 'Guest') {\n  console.log(`Hello, ${name}!`);\n}\n\ngreet();",
      "options": {
        "A": "Hello, undefined!",
        "B": "Hello, !",
        "C": "Hello, Guest!",
        "D": "Error: name is not defined"
      },
      "correct_answer": "C"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What is the difference between textContent and innerHTML properties?",
      "options": {
        "A": "They are exactly the same",
        "B": "textContent gets/sets the text only, innerHTML gets/sets HTML content",
        "C": "innerHTML gets/sets the text only, textContent gets/sets HTML content",
        "D": "innerHTML applies only to form elements, textContent applies to all elements"
      },
      "correct_answer": "B"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const age = 17;\nconst message = age >= 18 ? 'Adult' : 'Minor';\nconsole.log(message);",
      "options": {
        "A": "true",
        "B": "false",
        "C": "Adult",
        "D": "Minor"
      },
      "correct_answer": "D"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What is a closure in JavaScript?",
      "options": {
        "A": "A function that has access to variables from its own scope, parent function's scope, and global scope",
        "B": "A design pattern that ensures a function can only be called once",
        "C": "A way to secure variables from being accessed outside a function",
        "D": "A built-in JavaScript object that stores private variables"
      },
      "correct_answer": "A"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const user = {\n  name: 'John',\n  address: null\n};\n\nconst city = user.address?.city;\nconsole.log(city);",
      "options": {
        "A": "null",
        "B": "undefined",
        "C": "''",
        "D": "TypeError: Cannot read property 'city' of null"
      },
      "correct_answer": "B"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function createCounter() {\n  let count = 0;\n  return function() {\n    return ++count;\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter());\nconsole.log(counter());",
      "options": {
        "A": "0, 1",
        "B": "1, 1",
        "C": "1, 2",
        "D": "undefined, undefined"
      },
      "correct_answer": "C"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "Which is the best practice for API versioning in a Node.js Express application?",
      "options": {
        "A": "Including the version in the URL path (e.g., /api/v1/users)",
        "B": "Using different port numbers for different API versions",
        "C": "Defining version in the request body",
        "D": "Not versioning APIs at all"
      },
      "correct_answer": "A"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function multiply(a, b = 1) {\n  return a * b;\n}\n\nconsole.log(multiply(5));\nconsole.log(multiply(5, undefined));\nconsole.log(multiply(5, null));",
      "options": {
        "A": "5, 5, 0",
        "B": "5, 5, 5",
        "C": "5, undefined, 0",
        "D": "5, NaN, 0"
      },
      "correct_answer": "A"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "In Express.js, what is the purpose of express.json() middleware?",
      "options": {
        "A": "To validate JSON data against a schema",
        "B": "To parse incoming request bodies with JSON payloads",
        "C": "To compress JSON responses",
        "D": "To encrypt JSON data"
      },
      "correct_answer": "B"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function handleErrors(err, req, res, next) {\n  res.status(500).json({ error: err.message });\n}\n\n// In an Express app\napp.get('/users', (req, res) => {\n  throw new Error('Database connection failed');\n});\n\napp.use(handleErrors);\n\n// When /users endpoint is hit, what will be the response?",
      "options": {
        "A": "500 status with JSON: { error: 'Database connection failed' }",
        "B": "Default Express error page with stack trace",
        "C": "404 status with 'Not Found' message",
        "D": "The server will crash without a response"
      },
      "correct_answer": "A"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What is the primary purpose of Helmet.js in an Express application?",
      "options": {
        "A": "To encrypt sensitive data",
        "B": "To improve application performance",
        "C": "To secure applications by setting various HTTP headers",
        "D": "To validate user input"
      },
      "correct_answer": "C"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const promise = new Promise((resolve, reject) => {\n  reject(new Error('Something went wrong'));\n});\n\npromise\n  .catch(err => {\n    console.log('Error caught');\n    return 'Recovered';\n  })\n  .then(data => {\n    console.log(`Success: ${data}`);\n  })\n  .finally(() => {\n    console.log('Finally block executed');\n  });",
      "options": {
        "A": "Error caught\nSuccess: Recovered\nFinally block executed",
        "B": "Error caught\nFinally block executed",
        "C": "Success: Recovered\nFinally block executed",
        "D": "Finally block executed"
      },
      "correct_answer": "A"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What is the Event Emitter pattern in Node.js primarily used for?",
      "options": {
        "A": "To handle asynchronous operations",
        "B": "To implement the observer pattern for event-driven programming",
        "C": "To create middleware for Express applications",
        "D": "To optimize CPU-intensive tasks"
      },
      "correct_answer": "B"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What is the most effective way to reduce redundant database queries in a Node.js application?",
      "options": {
        "A": "Using multiple database connections",
        "B": "Implementing database indexing",
        "C": "Implementing caching strategies",
        "D": "Using raw SQL queries instead of ORMs"
      },
      "correct_answer": "C"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const fs = require('fs');\n\ntry {\n  const data = fs.readFileSync('nonexistent.txt', 'utf8');\n  console.log(data);\n} catch (err) {\n  console.log('Error reading file');\n}\n\nconsole.log('Program continues');",
      "options": {
        "A": "Error reading file\nProgram continues",
        "B": "ENOENT: no such file or directory\nProgram continues",
        "C": "Program continues",
        "D": "The program crashes without any output"
      },
      "correct_answer": "A"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const obj = {};\nconst sym1 = Symbol('key1');\nconst sym2 = Symbol('key1');\n\nobj[sym1] = 'Value 1';\nobj[sym2] = 'Value 2';\n\nconsole.log(Object.keys(obj).length);\nconsole.log(obj[sym1] === obj[sym2]);",
      "options": {
        "A": "2, true",
        "B": "2, false",
        "C": "0, true",
        "D": "0, false"
      },
      "correct_answer": "D"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "function factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}\n\nconsole.log(factorial(4));",
      "options": {
        "A": "4",
        "B": "12",
        "C": "24",
        "D": "120"
      },
      "correct_answer": "C"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const promise1 = Promise.resolve('First');\nconst promise2 = new Promise((resolve) => setTimeout(() => resolve('Second'), 100));\nconst promise3 = Promise.resolve('Third');\n\nPromise.all([promise1, promise2, promise3])\n  .then(results => console.log(results));",
      "options": {
        "A": "['First', 'Second', 'Third']",
        "B": "['First', 'Third', 'Second']",
        "C": "['Second', 'First', 'Third']",
        "D": "The order changes each time it runs"
      },
      "correct_answer": "A"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "In Express.js, what's the difference between route parameters and query strings?",
      "options": {
        "A": "There is no difference, they are interchangeable",
        "B": "Route parameters are defined with colons in routes (e.g., /users/:id), query strings are part of the URL after a question mark (e.g., /users?id=123)",
        "C": "Route parameters are used for GET requests, query strings for POST requests",
        "D": "Route parameters are encrypted, query strings are not"
      },
      "correct_answer": "B"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What will be the output of the following code that uses streams to process a large dataset?",
      "options": {
        "A": "The data will be processed but the 'end' event will not fire",
        "B": "RangeError: Maximum call stack size exceeded",
        "C": "The function will log 'Processing complete' and the sum 15",
        "D": "The function will never complete due to a memory leak"
      },
      "correct_answer": "C",
      "code_example": "const { Readable, Transform } = require('stream');\n\nfunction processLargeDataset() {\n  // Create a readable stream with sample data\n  const dataSource = new Readable({\n    objectMode: true,\n    read() {\n      const data = [1, 2, 3, 4, 5];\n      data.forEach(num => this.push(num));\n      this.push(null); // Signal the end of the stream\n    }\n  });\n\n  // Create a transform stream that processes each chunk\n  const processor = new Transform({\n    objectMode: true,\n    transform(chunk, encoding, callback) {\n      // Simply pass the number through\n      callback(null, chunk);\n    }\n  });\n\n  // Process the data\n  let sum = 0;\n  dataSource\n    .pipe(processor)\n    .on('data', (data) => {\n      sum += data;\n    })\n    .on('end', () => {\n      console.log('Processing complete');\n      console.log(sum);\n    });\n}\n\nprocessLargeDataset();"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "Which of the following correctly describes how JavaScript allocates memory for objects?",
      "options": {
        "A": "Objects are allocated on the stack and are automatically managed by the JavaScript engine",
        "B": "Objects are allocated in the heap and referenced values are only garbage collected when explicitly deleted",
        "C": "Objects are allocated in the heap and are garbage collected when they become unreachable",
        "D": "Objects have fixed memory allocation at compile time and use reference counting for cleanup"
      },
      "correct_answer": "C"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What will be the output of the following code using Winston for logging?",
      "options": {
        "A": "{ level: 'error', message: 'An error occurred', timestamp: [timestamp] }",
        "B": "{ message: 'An error occurred', level: 'error' }",
        "C": "Error: An error occurred",
        "D": "Winston will throw an error because the logger configuration is invalid"
      },
      "correct_answer": "A",
      "code_example": "const winston = require('winston');\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  transports: [\n    new winston.transports.Console()\n  ]\n});\n\nfunction performOperation() {\n  try {\n    throw new Error('Operation failed');\n  } catch (error) {\n    logger.error('An error occurred');\n  }\n}\n\nperformOperation();"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "What will be the output of the following code that uses the Node.js crypto module?",
      "options": {
        "A": "The same hash value for both password1 and password2",
        "B": "Different hash values for password1 and password2",
        "C": "An error because the crypto.createHash method is incorrectly used",
        "D": "The code will only hash the first password and then crash"
      },
      "correct_answer": "B",
      "code_example": "const crypto = require('crypto');\n\nfunction hashPassword(password) {\n  const salt = crypto.randomBytes(16).toString('hex');\n  const hash = crypto.createHash('sha256')\n    .update(password + salt)\n    .digest('hex');\n  return { salt, hash };\n}\n\nconst password1 = 'secretPassword';\nconst password2 = 'secretPassword';\n\nconst result1 = hashPassword(password1);\nconst result2 = hashPassword(password2);\n\nconsole.log(result1.hash === result2.hash);"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "When implementing rate limiting with express-rate-limit, which of the following configurations would allow 100 requests per hour per IP address?",
      "options": {
        "A": "{ windowMs: 60 * 60 * 1000, max: 100, standardHeaders: true }",
        "B": "{ duration: 3600, maxRequests: 100 }",
        "C": "{ limit: 100, timeframe: '60m' }",
        "D": "{ rateLimit: { windowTime: 3600, maxHits: 100 } }"
      },
      "correct_answer": "A"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "What is the primary advantage of Just-In-Time (JIT) compilation in JavaScript engines like V8?",
      "options": {
        "A": "It eliminates the need for garbage collection",
        "B": "It converts JavaScript directly to machine code during initial loading",
        "C": "It identifies frequently executed code paths and optimizes them for better performance",
        "D": "It allows JavaScript to run directly on hardware without interpretation"
      },
      "correct_answer": "C"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "What will be the output of the following code that uses CSRF protection?",
      "options": {
        "A": "Error: CSRF token validation failed",
        "B": "The form submission will succeed",
        "C": "Error: CSRF token missing from request",
        "D": "The server will reject the request with a 403 status"
      },
      "correct_answer": "D",
      "code_example": "// Server-side code (Express.js)\nconst express = require('express');\nconst csrf = require('csurf');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\n// Setup CSRF protection\nconst csrfProtection = csrf({ cookie: true });\n\napp.get('/form', csrfProtection, (req, res) => {\n  // Generate and send a CSRF token with the form\n  res.send(`\n    <form action=\"/submit\" method=\"POST\">\n      <input type=\"hidden\" name=\"_csrf\" value=\"invalidToken\">\n      <button type=\"submit\">Submit</button>\n    </form>\n  `);\n});\n\napp.post('/submit', csrfProtection, (req, res) => {\n  res.send('Form submission successful!');\n});\n\n// Client-side code\n// User submits the form with an invalid CSRF token\n// What will happen?"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "What will be the output of the following code that uses EventEmitter in Node.js?",
      "options": {
        "A": "data received: payload",
        "B": "Error: maximum event listeners exceeded",
        "C": "Both 'data received: payload' and 'data received again: payload'",
        "D": "data received again: payload"
      },
      "correct_answer": "C",
      "code_example": "const EventEmitter = require('events');\n\nclass DataSource extends EventEmitter {\n  constructor() {\n    super();\n  }\n\n  send(data) {\n    this.emit('data', data);\n  }\n}\n\nconst source = new DataSource();\n\n// Setup first listener\nsource.on('data', (data) => {\n  console.log(`data received: ${data}`);\n});\n\n// Setup second listener\nsource.on('data', (data) => {\n  console.log(`data received again: ${data}`);\n});\n\n// Emit an event\nsource.send('payload');"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "When deploying a Node.js application to Vercel, which configuration file is required in the root directory to specify build settings and environment variables?",
      "options": {
        "A": "vercel.config.js",
        "B": "now.json",
        "C": "vercel.json",
        "D": "config.vercel.js"
      },
      "correct_answer": "C"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "In the context of OAuth 2.0 with PKCE (Proof Key for Code Exchange), what is the correct flow for a secure authorization?",
      "options": {
        "A": "Client sends client_id and client_secret directly to the resource server which returns access and refresh tokens",
        "B": "Client creates a code_verifier, generates a code_challenge, requests an authorization code, then exchanges it for tokens using the original code_verifier",
        "C": "Client receives an ID token via the implicit flow and uses it to directly access protected resources",
        "D": "Client exchanges username and password for an access token using the resource owner password credentials flow"
      },
      "correct_answer": "B"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates the use of Helm for Kubernetes deployments?",
      "options": {
        "A": "Release \"nodejs-app\" has been upgraded",
        "B": "Error: chart.yaml is missing required fields",
        "C": "Error: could not find template values.yaml",
        "D": "Error: deployment.yaml contains invalid configuration"
      },
      "correct_answer": "A",
      "code_example": "// Assume the following files exist:\n\n// File: chart.yaml\n/*\napiVersion: v2\nname: nodejs-app\nversion: 1.0.0\ndescription: A Helm chart for a Node.js application\n*/\n\n// File: values.yaml\n/*\nreplicaCount: 2\nimage:\n  repository: my-nodejs-app\n  tag: latest\nservice:\n  type: ClusterIP\n  port: 3000\n*/\n\n// File: templates/deployment.yaml\n/*\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: {{ .Release.Name }}\nspec:\n  replicas: {{ .Values.replicaCount }}\n  selector:\n    matchLabels:\n      app: {{ .Release.Name }}\n  template:\n    metadata:\n      labels:\n        app: {{ .Release.Name }}\n    spec:\n      containers:\n      - name: {{ .Chart.Name }}\n        image: {{ .Values.image.repository }}:{{ .Values.image.tag }}\n        ports:\n        - containerPort: {{ .Values.service.port }}\n*/\n\n// When the following command is run:\n// helm upgrade --install nodejs-app ./nodejs-app -f ./nodejs-app/values.yaml"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "What is the correct sequence for setting up a CI/CD pipeline for a Node.js application using GitHub Actions?",
      "options": {
        "A": "Create a .github/workflows/deploy.yml file, define build process, set up test execution, configure deployment to staging, then to production based on branch",
        "B": "Set up Jenkins, configure webhooks, create a Jenkinsfile, define build stages, deploy to production",
        "C": "Use Travis CI, create .travis.yml, define build matrix, run tests, trigger deployment on commit to main branch",
        "D": "Install GitHub Actions CLI, run github-actions init, configure test script, define build process in package.json"
      },
      "correct_answer": "A"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What will be the output of the following code that uses Node.js clustering?",
      "options": {
        "A": "Primary worker with PID [number] started\nWorker 1 started\nWorker 2 started",
        "B": "Primary and 4 workers will be started, but with random ordering of console logs",
        "C": "Error: cluster.fork() can only be called from the primary process",
        "D": "Error: os.cpus() is not a function"
      },
      "correct_answer": "B",
      "code_example": "const cluster = require('cluster');\nconst http = require('http');\nconst os = require('os');\n\nif (cluster.isPrimary) {\n  console.log(`Primary worker with PID ${process.pid} started`);\n  \n  // Fork workers based on CPU count\n  const numCPUs = os.cpus().length;\n  \n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  \n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n  });\n} else {\n  // Workers share the TCP connection\n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end('Hello from worker\\n');\n  }).listen(8000);\n  \n  console.log(`Worker ${cluster.worker.id} started`);\n}"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates a memory leak in event listeners?",
      "options": {
        "A": "The code will run indefinitely without issues",
        "B": "After 11 iterations, a warning will be displayed about too many event listeners",
        "C": "The code will crash with 'JavaScript heap out of memory' after many iterations",
        "D": "The leak will be automatically detected and fixed by Node.js garbage collector"
      },
      "correct_answer": "B",
      "code_example": "const EventEmitter = require('events');\n\nclass DataProcessor extends EventEmitter {}\n\nconst processor = new DataProcessor();\n\nfunction addHandlers() {\n  for (let i = 0; i < 11; i++) {\n    processor.on('data', (data) => {\n      console.log(`Processing data: ${data}`);\n    });\n  }\n}\n\naddHandlers();\nprocessor.emit('data', 'sample');"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What will be the output of the following code that uses bcrypt for password hashing?",
      "options": {
        "A": "false",
        "B": "true",
        "C": "Error: data and hash arguments required",
        "D": "Error: bcrypt.hash is not a function"
      },
      "correct_answer": "B",
      "code_example": "const bcrypt = require('bcrypt');\n\nasync function hashAndVerify() {\n  const password = 'mySecretPassword';\n  const saltRounds = 10;\n  \n  try {\n    // Hash the password\n    const hashedPassword = await bcrypt.hash(password, saltRounds);\n    \n    // Verify the password\n    const isMatch = await bcrypt.compare(password, hashedPassword);\n    console.log(isMatch);\n    \n    // Try an incorrect password\n    const wrongMatch = await bcrypt.compare('wrongPassword', hashedPassword);\n    console.log(wrongMatch);\n  } catch (error) {\n    console.error('Error:', error.message);\n  }\n}\n\n// We'll only log the first console.log result\nhashAndVerify().then(() => {});"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "What will be the output of the following code that uses Transform streams?",
      "options": {
        "A": "HELLO WORLD!",
        "B": "hello world!Error: write after end",
        "C": "HELLO WORLD!undefined",
        "D": "hello world!"
      },
      "correct_answer": "A",
      "code_example": "const { Transform } = require('stream');\nconst { pipeline } = require('stream/promises');\n\nclass UppercaseTransform extends Transform {\n  constructor(options) {\n    super(options);\n  }\n  \n  _transform(chunk, encoding, callback) {\n    const upperCaseChunk = chunk.toString().toUpperCase();\n    this.push(upperCaseChunk);\n    callback();\n  }\n}\n\nasync function transformData() {\n  const source = ['hello world!'];\n  let sourceIndex = 0;\n  \n  const readable = new Transform({\n    objectMode: true,\n    transform(chunk, encoding, callback) {\n      callback(null, chunk);\n    },\n    read() {\n      if (sourceIndex < source.length) {\n        this.push(source[sourceIndex++]);\n      } else {\n        this.push(null);\n      }\n    }\n  });\n  \n  const uppercase = new UppercaseTransform({ objectMode: true });\n  \n  let result = '';\n  const writable = new Transform({\n    objectMode: true,\n    transform(chunk, encoding, callback) {\n      result += chunk;\n      callback();\n    }\n  });\n  \n  await pipeline(readable, uppercase, writable);\n  console.log(result);\n}\n\ntransformData().catch(err => console.error(err));"
    }
  ]
}
