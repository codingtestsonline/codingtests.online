{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "['apple', 'banana', 'cherry']",
        "B": "['banana', 'cherry', 'apple']",
        "C": "['cherry', 'apple', 'banana']",
        "D": "['cherry', 'banana', 'apple']"
      },
      "correct_answer": "B",
      "code_example": "const fruits = ['apple', 'banana'];\nfruits.push('cherry');\nfruits.shift();\nfruits.unshift('cherry');\nconsole.log(fruits);"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "123",
        "B": "123.45",
        "C": "123.5",
        "D": "124"
      },
      "correct_answer": "A",
      "code_example": "const num = '123.45';\nconsole.log(parseInt(num));"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "15",
        "B": "Error: Not a function",
        "C": "undefined",
        "D": "[Function: add]"
      },
      "correct_answer": "A",
      "code_example": "const add = (a, b) => a + b;\nconsole.log(add(7, 8));"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What is the main difference between == and === operators in JavaScript?",
      "options": {
        "A": "== compares values only, while === compares both values and types",
        "B": "== compares types only, while === compares both values and types",
        "C": "== and === are identical in modern JavaScript",
        "D": "== is faster than === for performance optimization"
      },
      "correct_answer": "A"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "{ name: 'John', age: 30 }",
        "B": "{ name: 'John', age: 30, job: 'developer' }",
        "C": "{ name: 'John', job: 'developer' }",
        "D": "Error: Cannot add property job"
      },
      "correct_answer": "B",
      "code_example": "const person = { name: 'John', age: 30 };\nperson.job = 'developer';\nconsole.log(person);"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "John, 30",
        "B": "30, John",
        "C": "undefined, undefined",
        "D": "Error: Invalid syntax"
      },
      "correct_answer": "A",
      "code_example": "const person = { name: 'John', age: 30 };\nconst { name, age } = person;\nconsole.log(name + ', ' + age);"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "Which statement about function scope in JavaScript is correct?",
      "options": {
        "A": "Variables declared with var inside a function are accessible outside the function",
        "B": "Variables declared with let inside a block are accessible outside the block",
        "C": "Variables declared with const inside a function are not accessible outside the function",
        "D": "All variables in JavaScript have global scope by default"
      },
      "correct_answer": "C"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "In Node.js, how do you access environment variables?",
      "options": {
        "A": "Using window.env.VARIABLE_NAME",
        "B": "Using environment.VARIABLE_NAME",
        "C": "Using process.env.VARIABLE_NAME",
        "D": "Using global.env.VARIABLE_NAME"
      },
      "correct_answer": "C"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "Which of the following statements about Node.js compared to browser JavaScript is NOT true?",
      "options": {
        "A": "Node.js has a file system module not available in browsers",
        "B": "Node.js uses the global object instead of window",
        "C": "Node.js always requires the use of semicolons while browser JavaScript doesn't",
        "D": "Node.js can directly access the operating system"
      },
      "correct_answer": "C"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "Which statement correctly exports a function in Node.js CommonJS format?",
      "options": {
        "A": "exports = { myFunction };",
        "B": "module.exports = { myFunction };",
        "C": "export default myFunction;",
        "D": "export { myFunction };"
      },
      "correct_answer": "B"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "[1, 2, 3]",
        "B": "['a', 'b', 'c']",
        "C": "[\"name\", \"age\", \"city\"]",
        "D": "{}"
      },
      "correct_answer": "C",
      "code_example": "const person = { name: 'John', age: 30, city: 'New York' };\nconsole.log(Object.keys(person));"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What's the key difference between function declarations and function expressions in JavaScript?",
      "options": {
        "A": "Function declarations can be anonymous while function expressions cannot",
        "B": "Function expressions can be used as IIFE (Immediately Invoked Function Expressions) while function declarations cannot",
        "C": "Function declarations are hoisted while function expressions are not",
        "D": "Function expressions are faster than function declarations"
      },
      "correct_answer": "C"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "true",
        "B": "false",
        "C": "undefined",
        "D": "Error"
      },
      "correct_answer": "A",
      "code_example": "console.log('10' == 10);"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "1 2 3 4 5",
        "B": "1 2 4 5",
        "C": "1 3 4 5",
        "D": "Error: continue not properly defined"
      },
      "correct_answer": "B",
      "code_example": "for(let i = 1; i <= 5; i++) {\n  if(i === 3) {\n    continue;\n  }\n  console.log(i);\n}"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "banana",
        "B": "cherry",
        "C": "apple",
        "D": "undefined"
      },
      "correct_answer": "B",
      "code_example": "const fruits = ['apple', 'banana', 'cherry'];\nconsole.log(fruits[2]);"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "Which of the following correctly selects an element with ID 'myElement' from the DOM?",
      "options": {
        "A": "document.findElementById('myElement')",
        "B": "document.querySelector('#myElement')",
        "C": "document.selectElement('myElement')",
        "D": "document.getElementsById('myElement')"
      },
      "correct_answer": "B"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "Hello",
        "B": "undefined",
        "C": "null",
        "D": "World"
      },
      "correct_answer": "D",
      "code_example": "const greeting = null;\nconst defaultGreeting = undefined;\nconst result = greeting ?? defaultGreeting ?? 'World';\nconsole.log(result);"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "Which HTTP status code indicates that the server has successfully processed the request?",
      "options": {
        "A": "404",
        "B": "500",
        "C": "200",
        "D": "401"
      },
      "correct_answer": "C"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "When working with large files in Node.js, which approach is most memory efficient?",
      "options": {
        "A": "Using fs.readFileSync to load the entire file at once",
        "B": "Using streams to process the file in chunks",
        "C": "Loading the file into a Buffer all at once",
        "D": "Converting the file to Base64 before processing"
      },
      "correct_answer": "B"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "Which Express.js middleware correctly handles form data submitted with Content-Type: application/x-www-form-urlencoded?",
      "options": {
        "A": "app.use(express.json())",
        "B": "app.use(express.urlencoded({ extended: true }))",
        "C": "app.use(express.form())",
        "D": "app.use(express.parser())"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "Server running on port 3000",
        "B": "Error: app.listen is not a function",
        "C": "Error: express is not defined",
        "D": "Nothing, the server starts silently"
      },
      "correct_answer": "A",
      "code_example": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send('Hello World');\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "Which HTTP method is most appropriate for updating an existing resource on the server?",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "correct_answer": "C"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "1 2 3",
        "B": "3 2 1",
        "C": "Error: Callback hell detected",
        "D": "3 undefined undefined"
      },
      "correct_answer": "B",
      "code_example": "function step1(callback) {\n  setTimeout(() => {\n    console.log(1);\n    callback();\n  }, 300);\n}\n\nfunction step2(callback) {\n  setTimeout(() => {\n    console.log(2);\n    callback();\n  }, 200);\n}\n\nfunction step3() {\n  setTimeout(() => {\n    console.log(3);\n  }, 100);\n}\n\nstep1(() => {\n  step2(() => {\n    step3();\n  });\n});"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What will be the output of the following code with debounce implementation?",
      "options": {
        "A": "Input value logged once after typing stops",
        "B": "Input value logged for every keystroke",
        "C": "Error: lodash.debounce is not a function",
        "D": "Input value logged at regular intervals during typing"
      },
      "correct_answer": "A",
      "code_example": "// Assuming lodash is imported\nconst handleInput = (event) => {\n  console.log(event.target.value);\n};\n\nconst debouncedHandler = _.debounce(handleInput, 300);\n\nconst inputElement = document.querySelector('input');\ninputElement.addEventListener('input', debouncedHandler);"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What is the correct way to define a RESTful endpoint for retrieving a specific user by ID in Express?",
      "options": {
        "A": "app.get('/users/:id', getUserById);",
        "B": "app.post('/users/get/:id', getUserById);",
        "C": "app.put('/users?id=:id', getUserById);",
        "D": "app.get('/getUserById/:id', getUserById);"
      },
      "correct_answer": "A"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What will be the output of the following code using MongoDB/Mongoose?",
      "options": {
        "A": "A single user object with _id equal to '123'",
        "B": "An array of all users in the collection",
        "C": "Error: findById requires a callback",
        "D": "null if no user with _id '123' exists"
      },
      "correct_answer": "D",
      "code_example": "// Assuming mongoose is set up and User model is defined\nconst findUser = async () => {\n  try {\n    const user = await User.findById('123');\n    console.log(user);\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nfindUser();"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will be the output of the following Express.js route handler?",
      "options": {
        "A": "A String: 'Success'",
        "B": "A JSON object: { message: 'Success' }",
        "C": "Error: res.json is not a function",
        "D": "Empty response"
      },
      "correct_answer": "B",
      "code_example": "app.get('/api/status', (req, res) => {\n  res.json({ message: 'Success' });\n});"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "Which of the following correctly establishes a MongoDB connection using Mongoose?",
      "options": {
        "A": "mongoose.createConnection('mongodb://localhost:27017/myapp');",
        "B": "mongoose.connect('mongodb://localhost:27017/myapp').then(() => console.log('Connected'));",
        "C": "mongoose.open('mongodb://localhost:27017/myapp');",
        "D": "mongoose.db.connect('mongodb://localhost:27017/myapp');"
      },
      "correct_answer": "B"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What is the primary purpose of the 'loading' attribute on image elements?",
      "options": {
        "A": "To specify the loading priority of the image",
        "B": "To defer image loading until it's needed (lazy loading)",
        "C": "To indicate a loading animation should be shown",
        "D": "To control loading error handling"
      },
      "correct_answer": "B"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What is the correct way to create modular routes in Express.js?",
      "options": {
        "A": "const router = express.Route(); module.exports = router;",
        "B": "const router = new express.Routes(); module.exports = router;",
        "C": "const router = express.Router(); module.exports = router;",
        "D": "const router = express.createRouter(); module.exports = router;"
      },
      "correct_answer": "C"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will be the output of the following multer configuration?",
      "options": {
        "A": "Uploaded files will be stored in memory only",
        "B": "Uploaded files will be stored in the 'uploads/' directory",
        "C": "Error: multer.diskStorage is not a function",
        "D": "Uploaded files will be rejected"
      },
      "correct_answer": "B",
      "code_example": "const multer = require('multer');\n\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) => {\n    cb(null, 'uploads/');\n  },\n  filename: (req, file, cb) => {\n    cb(null, Date.now() + '-' + file.originalname);\n  }\n});\n\nconst upload = multer({ storage: storage });"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "Hello World!",
        "B": "Error: fs.readFileSync is not a function",
        "C": "Error: Cannot find module 'fs'",
        "D": "The content of 'example.txt' file"
      },
      "correct_answer": "D",
      "code_example": "const fs = require('fs');\n\ntry {\n  const data = fs.readFileSync('example.txt', 'utf8');\n  console.log(data);\n} catch (err) {\n  console.error('Error reading file:', err);\n}"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What will be the output of the following code which demonstrates a potential memory leak with event listeners?",
      "options": {
        "A": "Memory leak will occur because the event listener is not removed before the element is deleted",
        "B": "No memory leak will occur because JavaScript's garbage collector automatically handles event listeners",
        "C": "Memory leak will occur because the closure captures the outer scope variables",
        "D": "No memory leak will occur because event listeners are automatically removed when the element is deleted"
      },
      "correct_answer": "A",
      "code_example": "function createButton() {\n  const largeData = new Array(1000000).fill('potential memory leak');\n  \n  const button = document.createElement('button');\n  button.innerText = 'Click me';\n  \n  button.addEventListener('click', function() {\n    // This closure captures largeData\n    console.log(largeData.length);\n  });\n  \n  document.body.appendChild(button);\n  \n  // Later in code\n  document.body.removeChild(button);\n  // Missing: button.removeEventListener()\n}"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "When using Node.js's --inspect flag for debugging, which of the following statements is true?",
      "options": {
        "A": "It automatically pauses execution at the first line of code",
        "B": "It exposes the debugging protocol only on localhost for security",
        "C": "It cannot be used in production environments under any circumstances",
        "D": "It requires a special debugging client and cannot work with Chrome DevTools"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "What is the output of the following code demonstrating V8 engine optimizations?",
      "options": {
        "A": "1, 2, 3, 4, 5",
        "B": "5, 5, 5, 5, 5",
        "C": "1, 2, 3, 4, 5 followed by 'Function optimized'",
        "D": "TypeError: Cannot find module 'v8'"
      },
      "correct_answer": "A",
      "code_example": "function sumNumbers(a, b) {\n  return a + b;\n}\n\n// Force V8 to optimize by calling multiple times with same types\nfor (let i = 0; i < 100000; i++) {\n  sumNumbers(1, i);\n}\n\n// Now use the optimized function\nfor (let i = 1; i <= 5; i++) {\n  console.log(sumNumbers(0, i));\n}"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "Which statement about hidden classes and inline caching in the V8 JavaScript engine is correct?",
      "options": {
        "A": "Adding properties to an object in different orders always results in the same hidden class",
        "B": "Inline caching improves performance by caching the results of property lookups",
        "C": "Hidden classes are directly accessible to JavaScript developers through the V8 API",
        "D": "Using array indices instead of named properties creates fewer hidden classes"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "What is the output of this code that reads a large file using Node.js streams?",
      "options": {
        "A": "The entire file content as a single string",
        "B": "An error about exceeding the buffer size limit",
        "C": "The count of chunks processed and the total byte count",
        "D": "A memory leak warning from Node.js"
      },
      "correct_answer": "C",
      "code_example": "const fs = require('fs');\n\nfunction processLargeFile(filePath) {\n  let chunkCount = 0;\n  let totalBytes = 0;\n  \n  const readStream = fs.createReadStream(filePath, { \n    highWaterMark: 64 * 1024 // 64KB chunks\n  });\n  \n  readStream.on('data', (chunk) => {\n    chunkCount++;\n    totalBytes += chunk.length;\n  });\n  \n  readStream.on('end', () => {\n    console.log(`Processed ${chunkCount} chunks totaling ${totalBytes} bytes`);\n  });\n  \n  readStream.on('error', (err) => {\n    console.error('Error reading file:', err);\n  });\n}\n\n// Assuming large-file.txt exists\nprocessLargeFile('./large-file.txt');"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "What is the primary purpose of Node.js clustering as implemented with the cluster module?",
      "options": {
        "A": "To distribute database queries across multiple servers",
        "B": "To run multiple worker processes that share server ports",
        "C": "To organize code into manageable modules",
        "D": "To optimize the V8 garbage collection process"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "What will be the output of this code using transform streams?",
      "options": {
        "A": "hello\nworld",
        "B": "HELLO\nWORLD",
        "C": "Transformed: HELLO\nTransformed: WORLD",
        "D": "Error: Cannot pipe after stream has been destroyed"
      },
      "correct_answer": "C",
      "code_example": "const { Transform } = require('stream');\nconst { createReadStream, createWriteStream } = require('fs');\n\nclass UppercaseTransform extends Transform {\n  _transform(chunk, encoding, callback) {\n    const upperChunk = chunk.toString().toUpperCase();\n    this.push(`Transformed: ${upperChunk}`);\n    callback();\n  }\n}\n\n// Mock implementation for testing purposes\nconst mockSource = require('stream').Readable.from(['hello\\n', 'world']);\nconst transformStream = new UppercaseTransform();\nconst mockDestination = new (require('stream').Writable)({\n  write(chunk, encoding, callback) {\n    console.log(chunk.toString());\n    callback();\n  }\n});\n\nmockSource.pipe(transformStream).pipe(mockDestination);"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "Which of the following is NOT an effective method to identify memory leaks in a Node.js application?",
      "options": {
        "A": "Using the heap snapshot feature in Chrome DevTools",
        "B": "Monitoring process memory with process.memoryUsage()",
        "C": "Using Node.js's built-in memory leak detector flag (--detect-leaks)",
        "D": "Implementing weak references with the WeakMap and WeakSet objects"
      },
      "correct_answer": "C",
      "code_example": null
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What is the output of this code demonstrating JavaScript memory allocation?",
      "options": {
        "A": "1 1 2",
        "B": "1 2 2",
        "C": "1 1 1",
        "D": "TypeError: Assignment to constant variable"
      },
      "correct_answer": "A",
      "code_example": "let obj1 = { value: 1 };\nconst obj2 = obj1;\n\nconsole.log(obj1.value);\n\nobj1.value = 2;\nobj1 = { value: 1 };\n\nconsole.log(obj2.value);\nconsole.log(obj1.value);"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "When implementing custom event listeners in JavaScript, which approach is considered best practice for performance?",
      "options": {
        "A": "Adding event listeners directly to each element that needs to respond to events",
        "B": "Using event delegation with a common ancestor to handle events for multiple child elements",
        "C": "Creating a separate event listener for each possible event type",
        "D": "Converting custom events to native events using the CustomEvent constructor"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What will be the output of this code implementing custom event listeners?",
      "options": {
        "A": "Button Clicked with data: {name: 'Custom Button'}",
        "B": "Error: Cannot read property 'addEventListener' of undefined",
        "C": "Button Clicked",
        "D": "No output because the event is never triggered"
      },
      "correct_answer": "A",
      "code_example": "class EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = [];\n    }\n    this.events[eventName].push(callback);\n  }\n\n  emit(eventName, data) {\n    if (this.events[eventName]) {\n      this.events[eventName].forEach(callback => {\n        callback(data);\n      });\n    }\n  }\n}\n\n// Testing the implementation\nconst buttonEvents = new EventEmitter();\n\nbuttonEvents.on('click', (data) => {\n  console.log(`Button Clicked with data: ${JSON.stringify(data)}`);\n});\n\n// Simulate a button click\nbuttonEvents.emit('click', {name: 'Custom Button'});"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "Which method provides the most secure way to prevent Cross-Site Scripting (XSS) attacks in a JavaScript application?",
      "options": {
        "A": "Using an HTTP-only cookie flag for session tokens",
        "B": "Implementing Content Security Policy (CSP) headers",
        "C": "Validating user input on the client side only",
        "D": "Encoding all data twice to ensure security"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What is the output of this code demonstrating a Cross-Site Scripting (XSS) vulnerability and its prevention?",
      "options": {
        "A": "User comment: <script>alert('XSS')</script>",
        "B": "User comment: &lt;script&gt;alert('XSS')&lt;/script&gt;",
        "C": "Alert dialog with the message 'XSS'",
        "D": "Error: Potential XSS attack detected"
      },
      "correct_answer": "B",
      "code_example": "function escapeHTML(unsafeText) {\n  return unsafeText\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n}\n\nfunction displayUserComment(comment) {\n  // Vulnerability if used directly: element.innerHTML = comment;\n  \n  // Safe approach:\n  const sanitizedComment = escapeHTML(comment);\n  console.log(`User comment: ${sanitizedComment}`);\n  // In real app: element.innerHTML = sanitizedComment;\n}\n\n// Simulated malicious user input\nconst userInput = \"<script>alert('XSS')</script>\";\ndisplayUserComment(userInput);"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "When using Nginx as a reverse proxy for a Node.js application, which configuration directive is used to forward client requests to the Node.js server?",
      "options": {
        "A": "forward_proxy",
        "B": "upstream",
        "C": "proxy_pass",
        "D": "node_server"
      },
      "correct_answer": "C",
      "code_example": null
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What will be the output of this code implementing refresh tokens and access tokens?",
      "options": {
        "A": "New access token generated: jwt_access_token",
        "B": "Error: Refresh token expired",
        "C": "Access granted with existing token",
        "D": "New refresh token: jwt_refresh_token"
      },
      "correct_answer": "A",
      "code_example": "function handleTokenAuthentication() {\n  // Mock implementation for testing\n  const tokenStore = {\n    accessToken: {\n      value: 'old_access_token',\n      expiresAt: Date.now() - 1000 // Expired\n    },\n    refreshToken: {\n      value: 'valid_refresh_token',\n      expiresAt: Date.now() + 86400000 // Valid for 24 hours\n    }\n  };\n\n  function isTokenValid(token) {\n    return token && token.expiresAt > Date.now();\n  }\n\n  function generateNewAccessToken() {\n    // In a real app, this would create a proper JWT\n    return 'jwt_access_token';\n  }\n\n  // Authentication logic\n  if (isTokenValid(tokenStore.accessToken)) {\n    console.log('Access granted with existing token');\n    return;\n  }\n  \n  // Access token expired, try using refresh token\n  if (isTokenValid(tokenStore.refreshToken)) {\n    // Generate new access token\n    const newAccessToken = generateNewAccessToken();\n    tokenStore.accessToken = {\n      value: newAccessToken,\n      expiresAt: Date.now() + 3600000 // Valid for 1 hour\n    };\n    console.log(`New access token generated: ${newAccessToken}`);\n  } else {\n    console.log('Error: Refresh token expired');\n  }\n}\n\nhandleTokenAuthentication();"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "What is the most effective way to encrypt sensitive data in a JavaScript application?",
      "options": {
        "A": "Using Base64 encoding to obscure the data",
        "B": "Implementing custom encryption algorithms in JavaScript",
        "C": "Using the Web Crypto API with proper key management",
        "D": "Storing encryption keys in localStorage for persistence"
      },
      "correct_answer": "C",
      "code_example": null
    }
  ]
}
