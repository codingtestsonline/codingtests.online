{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled);",
      "options": {
        "A": "[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]",
        "B": "[2, 4, 6, 8, 10]",
        "C": "[1, 4, 9, 16, 25]",
        "D": "TypeError: numbers.map is not a function"
      },
      "correct_answer": "B"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What's the difference between function declarations and function expressions?",
      "options": {
        "A": "Function declarations are hoisted, while function expressions are not",
        "B": "Function expressions can be anonymous, while function declarations cannot",
        "C": "Function declarations can only be defined at the top level of a file",
        "D": "Both A and B are correct"
      },
      "correct_answer": "D"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const paragraph = document.createElement('p');\nparagraph.textContent = 'Hello';\nparagraph.innerHTML = '<strong>World</strong>';\nconsole.log(paragraph.textContent);",
      "options": {
        "A": "Hello",
        "B": "World",
        "C": "<strong>World</strong>",
        "D": "HelloWorld"
      },
      "correct_answer": "B"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "In package.json, which field specifies the main entry point for your Node.js application?",
      "options": {
        "A": "entry",
        "B": "start",
        "C": "main",
        "D": "index"
      },
      "correct_answer": "C"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const element = document.querySelector('#myElement');\nconst allElements = document.querySelectorAll('.myClass');\nconsole.log(Array.isArray(allElements));",
      "options": {
        "A": "true",
        "B": "false",
        "C": "TypeError",
        "D": "undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const age = 17;\nconst message = age >= 18 ? 'Adult' : 'Minor';\nconsole.log(message);",
      "options": {
        "A": "Adult",
        "B": "Minor",
        "C": "undefined",
        "D": "SyntaxError"
      },
      "correct_answer": "B"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const fruits = ['apple', 'banana', 'cherry'];\nfruits.unshift('orange');\nfruits.push('grape');\nconsole.log(fruits);",
      "options": {
        "A": "['apple', 'banana', 'cherry', 'orange', 'grape']",
        "B": "['orange', 'apple', 'banana', 'cherry', 'grape']",
        "C": "['grape', 'apple', 'banana', 'cherry', 'orange']",
        "D": "['orange', 'grape', 'apple', 'banana', 'cherry']"
      },
      "correct_answer": "B"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const promise = new Promise((resolve, reject) => {\n  setTimeout(() => resolve('Success'), 100);\n});\n\npromise\n  .then(result => result + '!')\n  .then(result => console.log(result));",
      "options": {
        "A": "Success",
        "B": "Success!",
        "C": "undefined",
        "D": "Promise {<fulfilled>: 'Success!'}"
      },
      "correct_answer": "B"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const arr = [1, 2, 3];\narr[10] = 10;\nconsole.log(arr.length);",
      "options": {
        "A": "3",
        "B": "4",
        "C": "10",
        "D": "11"
      },
      "correct_answer": "D"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "(function() {\n  var x = 10;\n  console.log(x);\n})();",
      "options": {
        "A": "10",
        "B": "undefined",
        "C": "ReferenceError: x is not defined",
        "D": "SyntaxError"
      },
      "correct_answer": "A"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "var x = 1;\nlet y = 2;\nconst z = 3;\n\n{\n  var x = 4;\n  let y = 5;\n  const z = 6;\n}\n\nconsole.log(x, y, z);",
      "options": {
        "A": "1 2 3",
        "B": "4 2 3",
        "C": "4 5 6",
        "D": "1 5 6"
      },
      "correct_answer": "B"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "const person = { name: 'John', age: 30, city: 'New York' };\nconst keys = Object.keys(person);\nconsole.log(keys);",
      "options": {
        "A": "['name', 'age', 'city']",
        "B": "['John', 30, 'New York']",
        "C": "{name: 'John', age: 30, city: 'New York'}",
        "D": "3"
      },
      "correct_answer": "A"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "function outer() {\n  const x = 10;\n  function inner() {\n    console.log(x);\n  }\n  inner();\n}\nouter();",
      "options": {
        "A": "10",
        "B": "undefined",
        "C": "ReferenceError",
        "D": "NaN"
      },
      "correct_answer": "A"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "async function fetchData() {\n  return 'Data';\n}\n\nasync function getData() {\n  const result = await fetchData();\n  console.log(result);\n}\n\ngetData();",
      "options": {
        "A": "Promise {<pending>}",
        "B": "Data",
        "C": "undefined",
        "D": "Error: await is only valid in async functions"
      },
      "correct_answer": "B"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "for (let i = 0; i < 5; i++) {\n  if (i === 2) {\n    continue;\n  }\n  console.log(i);\n}",
      "options": {
        "A": "0 1 2 3 4",
        "B": "0 1 3 4",
        "C": "0 1",
        "D": "0 1 2"
      },
      "correct_answer": "B"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What is the most efficient way to add an event listener to a button in JavaScript?",
      "options": {
        "A": "button.onclick = function() { /* code */ }",
        "B": "button.addEventListener('click', function() { /* code */ })",
        "C": "button.attachEvent('onclick', function() { /* code */ })",
        "D": "<button onclick=\"myFunction()\">Click me</button>"
      },
      "correct_answer": "B"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "const numbers = [1, 2, 3, 4, 5];\n\n// Instead of using a loop\nconst sum = numbers.reduce((total, num) => total + num, 0);\nconst squaredSum = numbers.map(num => num * num).reduce((total, num) => total + num, 0);\n\nconsole.log(sum, squaredSum);",
      "options": {
        "A": "15 55",
        "B": "15 15",
        "C": "15 225",
        "D": "Error: Cannot read property 'reduce' of undefined"
      },
      "correct_answer": "A"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "In Express.js, what is the correct order of middleware execution in the following code?",
      "code_example": "app.use(express.json());\napp.use(logger);\napp.get('/users', validateUser, (req, res) => {\n  res.send('User route');\n});\napp.use(errorHandler);",
      "options": {
        "A": "express.json() → logger → validateUser → route handler → errorHandler",
        "B": "logger → express.json() → validateUser → route handler → errorHandler",
        "C": "express.json() → logger → errorHandler → validateUser → route handler",
        "D": "validateUser → express.json() → logger → route handler → errorHandler"
      },
      "correct_answer": "A"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What will be the output of the following JWT verification code?",
      "code_example": "const jwt = require('jsonwebtoken');\n\nconst verifyToken = (token, secret) => {\n  try {\n    return jwt.verify(token, secret);\n  } catch (error) {\n    return null;\n  }\n};\n\n// Assume this token is expired\nconst result = verifyToken('expired.token.here', 'secret');\nconsole.log(result);",
      "options": {
        "A": "{ error: 'TokenExpiredError' }",
        "B": "TokenExpiredError: jwt expired",
        "C": "null",
        "D": "undefined"
      },
      "correct_answer": "C"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "What will be the output of the following code using streams?",
      "code_example": "const { Readable, Writable } = require('stream');\n\nconst readable = new Readable({\n  read() {}\n});\n\nconst writable = new Writable({\n  write(chunk, encoding, callback) {\n    console.log(chunk.toString());\n    callback();\n  }\n});\n\nreadable.pipe(writable);\nreadable.push('Hello Stream!');\nreadable.push(null);",
      "options": {
        "A": "Hello Stream!",
        "B": "Buffer <48 65 6c 6c 6f 20 53 74 72 65 61 6d 21>",
        "C": "undefined",
        "D": "Error: stream is not readable"
      },
      "correct_answer": "A"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "Which HTTP status code is most appropriate when a resource is not found?",
      "options": {
        "A": "400 Bad Request",
        "B": "401 Unauthorized",
        "C": "403 Forbidden",
        "D": "404 Not Found"
      },
      "correct_answer": "D"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What will be the output of the following error handling middleware in Express?",
      "code_example": "app.get('/users/:id', (req, res, next) => {\n  if (isNaN(req.params.id)) {\n    const error = new Error('Invalid ID');\n    error.status = 400;\n    next(error);\n  } else {\n    res.send('Valid ID');\n  }\n});\n\napp.use((err, req, res, next) => {\n  console.log(`Status: ${err.status}, Message: ${err.message}`);\n  res.status(err.status || 500).json({ error: err.message });\n});",
      "options": {
        "A": "The server will respond with status 400 and JSON {\"error\": \"Invalid ID\"} when an invalid ID is provided",
        "B": "The server will respond with status 500 and JSON {\"error\": \"Internal Server Error\"} regardless of the error",
        "C": "The server will crash with an unhandled error",
        "D": "The middleware will never be called because the route handler doesn't call next()"
      },
      "correct_answer": "A"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What will be the output of the following code demonstrating first-class functions?",
      "code_example": "function multiply(a, b) {\n  return a * b;\n}\n\nfunction applyOperation(operation, a, b) {\n  return operation(a, b);\n}\n\nconst result = applyOperation(multiply, 4, 5);\nconsole.log(result);",
      "options": {
        "A": "9",
        "B": "20",
        "C": "function multiply(a, b) { return a * b; }",
        "D": "TypeError: operation is not a function"
      },
      "correct_answer": "B"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What will be the output of the following Express Router code?",
      "code_example": "// users.js\nconst express = require('express');\nconst router = express.Router();\n\nrouter.get('/', (req, res) => {\n  res.send('Users list');\n});\n\nrouter.get('/:id', (req, res) => {\n  res.send(`User ${req.params.id}`);\n});\n\nmodule.exports = router;\n\n// app.js\napp.use('/api/users', require('./users'));\n\n// What will be returned when a client requests GET /api/users/42",
      "options": {
        "A": "Users list",
        "B": "User 42",
        "C": "404 Not Found",
        "D": "Cannot GET /api/users/42"
      },
      "correct_answer": "B"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What will be the output of the following code using explicit binding?",
      "code_example": "const person = {\n  name: 'John',\n  greet: function(greeting) {\n    return `${greeting}, ${this.name}!`;\n  }\n};\n\nconst anotherPerson = { name: 'Sarah' };\nconst boundGreet = person.greet.bind(anotherPerson);\n\nconsole.log(boundGreet('Hello'));",
      "options": {
        "A": "Hello, John!",
        "B": "Hello, Sarah!",
        "C": "Hello, undefined!",
        "D": "TypeError: Cannot read property 'name' of undefined"
      },
      "correct_answer": "B"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "How does JavaScript's prototypal inheritance differ from classical inheritance?",
      "options": {
        "A": "JavaScript uses classes while classical OOP uses prototypes",
        "B": "In JavaScript, objects inherit directly from other objects, not from classes",
        "C": "JavaScript doesn't support inheritance at all",
        "D": "Classical inheritance is more efficient than JavaScript's inheritance model"
      },
      "correct_answer": "B"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will be the output of the following code demonstrating pure functions?",
      "code_example": "// Pure function\nfunction add(a, b) {\n  return a + b;\n}\n\n// Impure function\nlet total = 0;\nfunction addToTotal(value) {\n  total += value;\n  return total;\n}\n\nconsole.log(add(5, 3));\nconsole.log(addToTotal(5));\nconsole.log(add(5, 3));\nconsole.log(addToTotal(3));",
      "options": {
        "A": "8, 5, 8, 8",
        "B": "8, 5, 8, 5",
        "C": "8, 5, 5, 8",
        "D": "8, 5, 8, 13"
      },
      "correct_answer": "A"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What will be the output of the following code using spread and rest operators?",
      "code_example": "function logArguments(...args) {\n  return args;\n}\n\nconst numbers = [1, 2, 3];\nconst moreNumbers = [...numbers, 4, 5];\n\nconsole.log(logArguments(...moreNumbers));",
      "options": {
        "A": "[1, 2, 3, 4, 5]",
        "B": "1, 2, 3, 4, 5",
        "C": "[[1, 2, 3], 4, 5]",
        "D": "SyntaxError: Unexpected token ..."
      },
      "correct_answer": "A"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What will be the output of the following Express server code?",
      "code_example": "const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\napp.get('/api/*', (req, res) => {\n  res.send('API route');\n});\n\napp.get('/users', (req, res) => {\n  res.send('Users route');\n});\n\n// What will be returned when a client requests GET /api/users",
      "options": {
        "A": "Hello World!",
        "B": "API route",
        "C": "Users route",
        "D": "Cannot GET /api/users"
      },
      "correct_answer": "B"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What will be the output of the following Mongoose schema validation code?",
      "code_example": "const mongoose = require('mongoose');\n\nconst userSchema = new mongoose.Schema({\n  username: {\n    type: String,\n    required: true,\n    minlength: 3\n  },\n  email: {\n    type: String,\n    required: true,\n    match: /.+@.+\\..+/\n  },\n  age: {\n    type: Number,\n    min: 18\n  }\n});\n\nconst User = mongoose.model('User', userSchema);\n\nconst newUser = new User({\n  username: 'jo',\n  email: 'invalid-email',\n  age: 25\n});\n\nnewUser.validate(err => {\n  console.log(err ? 'Validation failed' : 'Validation passed');\n});",
      "options": {
        "A": "Validation passed",
        "B": "Validation failed",
        "C": "Error: Schema validation not supported",
        "D": "TypeError: newUser.validate is not a function"
      },
      "correct_answer": "B"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will be the output of the following Sequelize code for a MySQL database?",
      "code_example": "const { Sequelize, DataTypes } = require('sequelize');\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  host: 'localhost',\n  dialect: 'mysql'\n});\n\nconst User = sequelize.define('User', {\n  username: {\n    type: DataTypes.STRING,\n    allowNull: false,\n    unique: true\n  },\n  isAdmin: {\n    type: DataTypes.BOOLEAN,\n    defaultValue: false\n  }\n});\n\nasync function createUser() {\n  try {\n    const user = await User.create({\n      username: 'john'\n    });\n    console.log(user.toJSON());\n  } catch (error) {\n    console.error('Error creating user');\n  }\n}\n\ncreateUser();",
      "options": {
        "A": "{ id: 1, username: 'john', isAdmin: null, createdAt: '2023-01-01T...', updatedAt: '2023-01-01T...' }",
        "B": "{ id: 1, username: 'john', isAdmin: false, createdAt: '2023-01-01T...', updatedAt: '2023-01-01T...' }",
        "C": "Error: username must be unique",
        "D": "Error: isAdmin cannot be null"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What will be the output of the following Express rate limiting code?",
      "code_example": "const express = require('express');\nconst rateLimit = require('express-rate-limit');\n\nconst app = express();\n\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 3, // 3 requests per windowMs\n  message: 'Too many requests from this IP, please try again later'\n});\n\napp.use('/api/', apiLimiter);\n\napp.get('/api/data', (req, res) => {\n  res.json({ message: 'Data retrieved successfully' });\n});\n\napp.get('/public/data', (req, res) => {\n  res.json({ message: 'Public data retrieved' });\n});",
      "options": {
        "A": "The '/api/data' route will always respond with { message: 'Data retrieved successfully' }",
        "B": "After 3 requests within 15 minutes to '/api/data', further requests will receive a 429 Too Many Requests response",
        "C": "Both '/api/data' and '/public/data' routes are limited to 3 requests per 15 minutes",
        "D": "The rate limiter will have no effect because it's incorrectly configured"
      },
      "correct_answer": "B"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "Which statement about WebSockets compared to REST and GraphQL is correct?",
      "options": {
        "A": "WebSockets use the HTTP protocol for the entire communication lifecycle",
        "B": "GraphQL maintains a persistent connection like WebSockets",
        "C": "WebSockets maintain a persistent bidirectional connection after an initial handshake",
        "D": "REST is better suited than WebSockets for real-time applications like chat or live dashboards"
      },
      "correct_answer": "C"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates an issue with event listener memory leaks?",
      "options": {
        "A": "Event listener count: 1",
        "B": "Event listener count: 5",
        "C": "Event listener count: 0",
        "D": "RangeError: Maximum call stack size exceeded"
      },
      "correct_answer": "B",
      "code_example": "const EventEmitter = require('events');\nconst emitter = new EventEmitter();\n\nfunction createListeners() {\n  const listener = () => console.log('Event triggered');\n  emitter.on('test', listener);\n  // Oops, forgot to remove the listener\n}\n\nfor (let i = 0; i < 5; i++) {\n  createListeners();\n}\n\nconsole.log('Event listener count:', emitter.listenerCount('test'));"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "In the context of Node.js architecture, what is the main difference between horizontal and vertical scaling?",
      "options": {
        "A": "Horizontal scaling means using powerful cloud services, while vertical scaling means using on-premises servers",
        "B": "Horizontal scaling adds more machines to your resource pool, while vertical scaling adds more power to existing machines",
        "C": "Horizontal scaling is free while vertical scaling requires payment for additional resources",
        "D": "Horizontal scaling refers to adding more CPU cores while vertical scaling refers to adding more RAM"
      },
      "correct_answer": "B"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "What will be the output of the following code using the Node.js crypto module?",
      "options": {
        "A": "true",
        "B": "false",
        "C": "Error: Invalid key length",
        "D": "undefined"
      },
      "correct_answer": "A",
      "code_example": "const crypto = require('crypto');\n\n// Generate a secret key\nconst key = crypto.randomBytes(32);\nconst iv = crypto.randomBytes(16);\n\n// Message to encrypt\nconst message = 'top secret information';\n\n// Encrypt\nconst cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\nlet encrypted = cipher.update(message, 'utf8', 'hex');\nencrypted += cipher.final('hex');\n\n// Decrypt\nconst decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);\nlet decrypted = decipher.update(encrypted, 'hex', 'utf8');\ndecrypted += decipher.final('utf8');\n\n// Check if original message equals decrypted message\nconsole.log(message === decrypted);"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "What is the primary purpose of implementing rate limiting in a Node.js application?",
      "options": {
        "A": "To ensure equal distribution of CPU resources among all clients",
        "B": "To reduce database query complexity and improve performance",
        "C": "To prevent abuse by limiting the number of requests a user can make in a given timeframe",
        "D": "To optimize caching strategies for frequently accessed routes"
      },
      "correct_answer": "C"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "What will be the output of this code demonstrating the effect of a memory leak in a closure?",
      "options": {
        "A": "Memory usage stabilizes around 10MB",
        "B": "Memory usage continuously increases",
        "C": "'RangeError: Maximum call stack size exceeded'",
        "D": "The program crashes after 5 seconds"
      },
      "correct_answer": "B",
      "code_example": "// This example demonstrates a memory leak pattern\n// In a real application, this would cause problems over time\n\nlet leakyArray = [];\n\nfunction createLargeClosure() {\n  // Create a large object (5MB)\n  const largeData = new Array(1024 * 1024 * 5).fill('X');\n  \n  // Return a function that captures the large data in its closure\n  return function() {\n    // This reference prevents largeData from being garbage collected\n    console.log('Array length:', largeData.length);\n    return largeData;\n  };\n}\n\n// In a real app, this might happen in response to user actions\nfor (let i = 0; i < 3; i++) {\n  leakyArray.push(createLargeClosure());\n}\n\n// Memory usage behavior: 'Memory usage continuously increases'\n// This is because each closure retains a reference to its own\n// large data array, preventing garbage collection"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "In the context of Just-In-Time (JIT) compilation in JavaScript engines, which statement is correct?",
      "options": {
        "A": "JIT compilation always produces faster code than interpreted execution",
        "B": "JIT compilation converts JavaScript directly to machine code before any execution begins",
        "C": "JIT compilation identifies frequently executed code paths and optimizes them during runtime",
        "D": "JIT compilation eliminates the need for garbage collection in modern JavaScript engines"
      },
      "correct_answer": "C"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "When deploying a Node.js application to Heroku, which configuration is correct?",
      "options": {
        "A": "The application must listen on port 80 for HTTP traffic",
        "B": "The application should use process.env.PORT for the server to listen on",
        "C": "package.json must include Heroku as a dependency",
        "D": "All dependencies must be installed globally rather than listed in package.json"
      },
      "correct_answer": "B"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What will be the output of the following code using bcrypt for password hashing?",
      "options": {
        "A": "true, false",
        "B": "false, false",
        "C": "true, true",
        "D": "Error: Invalid salt rounds"
      },
      "correct_answer": "A",
      "code_example": "const bcrypt = require('bcrypt');\n\nasync function testBcrypt() {\n  const password = 'secure_password123';\n  const saltRounds = 10;\n  \n  // Hash the password\n  const hash = await bcrypt.hash(password, saltRounds);\n  \n  // Test correct password\n  const match1 = await bcrypt.compare(password, hash);\n  \n  // Test incorrect password\n  const match2 = await bcrypt.compare('wrong_password', hash);\n  \n  console.log(match1, match2);\n}\n\ntestBcrypt();"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "In a docker-compose.yml file for a Node.js application with MongoDB, which configuration correctly sets up environment variables for the Node.js service to connect to MongoDB?",
      "options": {
        "A": "environment: - MONGO_CONNECTION=mongodb://mongodb:27017/myapp",
        "B": "env_file: .env",
        "C": "environment: [\"MONGO_URI=mongodb://mongodb:27017/myapp\"]",
        "D": "environment:\n  - MONGO_URI=mongodb://mongodb:27017/myapp"
      },
      "correct_answer": "D"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What will be the output of the following EventEmitter code in Node.js?",
      "options": {
        "A": "First listener\nSecond listener",
        "B": "Second listener\nFirst listener",
        "C": "First listener\nSecond listener\nFirst listener",
        "D": "Second listener"
      },
      "correct_answer": "C",
      "code_example": "const EventEmitter = require('events');\n\nclass MyEmitter extends EventEmitter {}\n\nconst myEmitter = new MyEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('First listener');\n});\n\n// Second listener\nmyEmitter.on('event', function secondListener() {\n  console.log('Second listener');\n  \n  // Remove the first listener\n  this.removeListener('event', firstListener);\n});\n\n// Third listener (reference to firstListener)\nfunction firstListener() {\n  console.log('First listener');\n}\n\nmyEmitter.on('event', firstListener);\n\n// Trigger the event\nmyEmitter.emit('event');"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "Which Helmet.js configuration correctly sets a Content Security Policy that allows scripts only from the same origin and inline styles?",
      "options": {
        "A": "app.use(helmet.contentSecurityPolicy({ directives: { scriptSrc: [\"'self'\"], styleSrc: [\"'self'\", \"'unsafe-inline'\"] } }))",
        "B": "app.use(helmet({ contentSecurityPolicy: { directives: { scriptSrc: [\"'self'\"], styleSrc: [\"'self'\", \"'unsafe-inline'\"] } } }))",
        "C": "app.use(helmet.csp({ policies: { scripts: [\"'self'\"], styles: [\"'self'\", \"'unsafe-inline'\"] } }))",
        "D": "app.use(helmet({ csp: { script: [\"'self'\"], style: [\"'self'\", \"'unsafe-inline'\"] } }))"
      },
      "correct_answer": "B"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What will be the output of the following code using Node.js streams?",
      "options": {
        "A": "Data: Hello World",
        "B": "Data: HELLO WORLD",
        "C": "Error: Stream not readable",
        "D": "Data: hello world"
      },
      "correct_answer": "B",
      "code_example": "const { Transform, Readable } = require('stream');\n\n// Create a transform stream that converts data to uppercase\nconst upperCaseTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    callback(null, chunk.toString().toUpperCase());\n  }\n});\n\n// Create a readable stream\nconst readableStream = new Readable({\n  read() {}\n});\n\n// Pipe the data through the transform stream\nreadableStream\n  .pipe(upperCaseTransform)\n  .on('data', (chunk) => {\n    console.log('Data:', chunk.toString());\n  });\n\n// Push data to the readable stream\nreadableStream.push('Hello World');\nreadableStream.push(null); // Signal the end of the stream"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "What will be the output of the following code demonstrating the Node.js cluster module?",
      "options": {
        "A": "Primary worker started\nWorker started: 1",
        "B": "Primary worker started\nWorker started: 1\nWorker started: 2\nWorker started: 3\nWorker started: 4",
        "C": "Error: cluster.fork() can only be called from the primary process",
        "D": "Primary worker started"
      },
      "correct_answer": "B",
      "code_example": "const cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = 4; // Using a fixed number for predictable output\n\nif (cluster.isPrimary) {\n  console.log('Primary worker started');\n  \n  // Fork workers based on CPU count\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  \n  cluster.on('exit', (worker) => {\n    console.log(`Worker ${worker.process.pid} died`);\n  });\n} else {\n  // Workers share the same server port\n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end('Hello World\\n');\n  }).listen(8000);\n  \n  console.log(`Worker started: ${cluster.worker.id}`);\n}"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "Which of the following is the most effective method to identify memory leaks in a Node.js application?",
      "options": {
        "A": "Manually inspecting all closure variables in the codebase",
        "B": "Running the application with the --inspect flag and analyzing heap snapshots in Chrome DevTools",
        "C": "Adding console.log statements to track memory usage throughout the application",
        "D": "Using process.memoryUsage() exclusively to monitor the application"
      },
      "correct_answer": "B"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "What will be the output of the following code that demonstrates rate limiting in Express?",
      "options": {
        "A": "Request 1: Success\nRequest 2: Success\nRequest 3: Too many requests",
        "B": "Request 1: Success\nRequest 2: Success\nRequest 3: Success",
        "C": "Error: Missing required options",
        "D": "Request 1: Success\nRequest 2: Too many requests\nRequest 3: Too many requests"
      },
      "correct_answer": "A",
      "code_example": "const express = require('express');\nconst rateLimit = require('express-rate-limit');\n\nconst app = express();\n\n// Create a limiter: maximum 2 requests per window\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minute window\n  max: 2, // limit each IP to 2 requests per windowMs\n  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers\n  legacyHeaders: false // Disable the `X-RateLimit-*` headers\n});\n\n// Apply the rate limiting middleware to all requests\napp.use(limiter);\n\n// Mock server response function for testing purposes\nfunction mockServer(reqNum) {\n  return new Promise((resolve) => {\n    // Simulate the middleware checking the rate limit\n    if (reqNum <= 2) {\n      resolve(`Request ${reqNum}: Success`);\n    } else {\n      resolve(`Request ${reqNum}: Too many requests`);\n    }\n  });\n}\n\n// Test the rate limit behavior\nasync function testRateLimit() {\n  for (let i = 1; i <= 3; i++) {\n    const response = await mockServer(i);\n    console.log(response);\n  }\n}\n\ntestRateLimit();"
    }
  ]
}
