{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "[1, 2, 3, 4, 5]",
        "B": "[1, 2, 3, 4, 5, 6]",
        "C": "[1, 2, 3, 4, 5, [6]]",
        "D": "Error: 'list' object has no attribute 'add'"
      },
      "correct_answer": "B",
      "code_example": "numbers = [1, 2, 3, 4, 5]\nnumbers.append(6)\nprint(numbers)"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What is the result of the following string operation?",
      "options": {
        "A": "Hello World",
        "B": "dlroW olleH",
        "C": "olleH dlroW",
        "D": "HHeelllloo  WWoorrlldd"
      },
      "correct_answer": "B",
      "code_example": "text = \"Hello World\"\nreversed_text = text[::-1]\nprint(reversed_text)"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What does the following try/except/else/finally block return?",
      "options": {
        "A": "Success!",
        "B": "Error!",
        "C": "Cleanup!",
        "D": "Success!Cleanup!"
      },
      "correct_answer": "D",
      "code_example": "def test_function():\n    result = \"\"\n    try:\n        x = 10\n        y = 2\n        z = x / y\n    except ZeroDivisionError:\n        result += \"Error!\"\n    else:\n        result += \"Success!\"\n    finally:\n        result += \"Cleanup!\"\n    return result\n\nprint(test_function())"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of this code using a while loop?",
      "options": {
        "A": "5 4 3 2 1",
        "B": "5 4 3 2 1 0",
        "C": "5 4 3 2",
        "D": "4 3 2 1 0"
      },
      "correct_answer": "C",
      "code_example": "count = 5\nwhile count > 1:\n    print(count, end=\" \")\n    count -= 1"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "According to PEP 8, which of the following is the correct naming convention for a constant in Python?",
      "options": {
        "A": "maxSize",
        "B": "MAX_SIZE",
        "C": "MaxSize",
        "D": "max_size"
      },
      "correct_answer": "B"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What is the median value in the following list?",
      "options": {
        "A": "5",
        "B": "6",
        "C": "7",
        "D": "8"
      },
      "correct_answer": "C",
      "code_example": "numbers = [8, 5, 12, 7, 3, 9]\nnumbers.sort()\nmedian = numbers[len(numbers) // 2] if len(numbers) % 2 != 0 else (numbers[len(numbers) // 2 - 1] + numbers[len(numbers) // 2]) / 2\nprint(median)"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What will be the output of the tuple unpacking operation?",
      "options": {
        "A": "('John', 'Doe')",
        "B": "John",
        "C": "Doe",
        "D": "John Doe"
      },
      "correct_answer": "A",
      "code_example": "person = ('John', 'Doe', 30, 'Developer')\nfirst_name, last_name = person[:2]\nprint((first_name, last_name))"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What is the difference between parameters and arguments in Python functions?",
      "options": {
        "A": "They are the same thing, just different terminology",
        "B": "Parameters are defined in function declarations, arguments are the values passed to functions when called",
        "C": "Arguments are defined in function declarations, parameters are the values passed to functions when called",
        "D": "Parameters are optional, arguments are required"
      },
      "correct_answer": "B"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What is the output of the following string manipulation code?",
      "options": {
        "A": "['apple', 'banana', 'cherry']",
        "B": "apple-banana-cherry",
        "C": "apple,banana,cherry",
        "D": "apple banana cherry"
      },
      "correct_answer": "B",
      "code_example": "fruits = ['apple', 'banana', 'cherry']\nresult = '-'.join(fruits)\nprint(result)"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "Which of the following is a valid way to create a multi-line string in Python?",
      "options": {
        "A": "\"\"\"This is a\nmulti-line string\"\"\"",
        "B": "\"This is a\nmulti-line string\"",
        "C": "'This is a\nmulti-line string'",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What will the following code print?",
      "options": {
        "A": "0 a\\n1 b\\n2 c",
        "B": "1 a\\n2 b\\n3 c",
        "C": "a 0\\nb 1\\nc 2",
        "D": "a 1\\nb 2\\nc 3"
      },
      "correct_answer": "A",
      "code_example": "letters = ['a', 'b', 'c']\nfor i, letter in enumerate(letters):\n    print(i, letter)"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will the following code snippet return?",
      "options": {
        "A": "63",
        "B": "42",
        "C": "0x2a",
        "D": "0b101010"
      },
      "correct_answer": "C",
      "code_example": "decimal_num = 42\nhex_representation = hex(decimal_num)\nprint(hex_representation)"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "Which of the following correctly checks if a number is prime?",
      "options": {
        "A": "def is_prime(n):\n    return all(n % i != 0 for i in range(2, n))",
        "B": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
        "C": "def is_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True",
        "D": "def is_prime(n):\n    for i in range(2, n):\n        if n % i != 0:\n            return True\n    return False"
      },
      "correct_answer": "B"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What is the output of the following CSV file operation?",
      "options": {
        "A": "['John', 'Doe', '30']",
        "B": "John,Doe,30",
        "C": "Error: missing required parameter 'delimiter'",
        "D": "{'Name': 'John', 'Surname': 'Doe', 'Age': '30'}"
      },
      "correct_answer": "A",
      "code_example": "import csv\n\ncsv_data = 'John,Doe,30'\nrow = next(csv.reader([csv_data]))\nprint(row)"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What happens when you attempt to modify a tuple?",
      "options": {
        "A": "The tuple is modified in-place",
        "B": "A new tuple is created with the modifications",
        "C": "A TypeError is raised because tuples are immutable",
        "D": "Nothing happens, but no error is raised"
      },
      "correct_answer": "C",
      "code_example": "my_tuple = (1, 2, 3)\ntry:\n    my_tuple[0] = 10\n    print(\"Modified\")\nexcept TypeError:\n    print(\"TypeError is raised because tuples are immutable\")"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "How would you create a custom exception in Python?",
      "options": {
        "A": "class MyCustomError extends Exception: pass",
        "B": "class MyCustomError implements Exception: pass",
        "C": "class MyCustomError(Exception): pass",
        "D": "def MyCustomError(): raise Exception()"
      },
      "correct_answer": "C"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What will be the output of this decorator example?",
      "options": {
        "A": "Before function\\nHello, World!\\nAfter function",
        "B": "Hello, World!",
        "C": "Before function\\nHello, World!",
        "D": "Function called: greet"
      },
      "correct_answer": "A",
      "code_example": "def decorator_function(func):\n    def wrapper():\n        print(\"Before function\")\n        func()\n        print(\"After function\")\n    return wrapper\n\n@decorator_function\ndef greet():\n    print(\"Hello, World!\")\n\ngreet()"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "Which HTTP method is typically used for updating an existing resource in a RESTful API?",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "correct_answer": "C"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What will the following closure function return?",
      "options": {
        "A": "15",
        "B": "20",
        "C": "Error: UnboundLocalError",
        "D": "None"
      },
      "correct_answer": "A",
      "code_example": "def outer_function(x):\n    def inner_function(y):\n        return x + y\n    return inner_function\n\nadd_five = outer_function(5)\nresult = add_five(10)\nprint(result)"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "What is the time complexity of this binary search implementation?",
      "options": {
        "A": "O(n)",
        "B": "O(log n)",
        "C": "O(n log n)",
        "D": "O(1)"
      },
      "correct_answer": "B",
      "code_example": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return -1"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "Which regex pattern will match valid email addresses?",
      "options": {
        "A": "\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b",
        "B": "[a-zA-Z0-9]+@[a-zA-Z0-9]+",
        "C": ".*@.*\\..*",
        "D": ".+@.+"
      },
      "correct_answer": "A",
      "code_example": "import re\n\ndef is_valid_email(email):\n    pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n    return bool(re.match(pattern, email))\n\nprint(is_valid_email(\"user@example.com\"))"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What does the following code implementing a stack do?",
      "options": {
        "A": "Returns True if the stack contains any element, False otherwise",
        "B": "Returns the number of elements in the stack",
        "C": "Returns the top element without removing it",
        "D": "Removes and returns the most recently added element"
      },
      "correct_answer": "D",
      "code_example": "class Stack:\n    def __init__(self):\n        self.items = []\n        \n    def push(self, item):\n        self.items.append(item)\n        \n    def is_empty(self):\n        return len(self.items) == 0\n        \n    def peek(self):\n        if not self.is_empty():\n            return self.items[-1]\n            \n    def pop(self):\n        if not self.is_empty():\n            return self.items.pop()\n            \n# Which method removes and returns the most recently added element?"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What is the output of the following code using **kwargs?",
      "options": {
        "A": "{'a': 1, 'b': 2, 'c': 3}",
        "B": "{'a': 1, 'b': 2}",
        "C": "{'a': 1, 'b': 2, 'c': 3, 'd': 4}",
        "D": "Error: multiple values for keyword argument"
      },
      "correct_answer": "C",
      "code_example": "def combine_dicts(first, second, **kwargs):\n    result = {**first, **second, **kwargs}\n    return result\n\nfirst_dict = {'a': 1}\nsecond_dict = {'b': 2}\nprint(combine_dicts(first_dict, second_dict, c=3, d=4))"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What's the primary difference between a list and an array in Python?",
      "options": {
        "A": "Lists can store mixed data types, arrays can only store a single data type",
        "B": "Arrays are built-in, lists require import",
        "C": "Lists can be nested, arrays cannot",
        "D": "There is no difference, they are synonyms in Python"
      },
      "correct_answer": "A"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "Which method would you use to check if a cycle exists in a directed graph?",
      "options": {
        "A": "Breadth-First Search with path tracking",
        "B": "Depth-First Search with visited node tracking",
        "C": "Dijkstra's algorithm",
        "D": "A* search algorithm"
      },
      "correct_answer": "B",
      "code_example": "def has_cycle(graph):\n    visited = set()\n    path = set()\n    \n    def dfs(node):\n        visited.add(node)\n        path.add(node)\n        \n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                if dfs(neighbor):\n                    return True\n            elif neighbor in path:\n                return True\n                \n        path.remove(node)\n        return False\n    \n    for node in graph:\n        if node not in visited:\n            if dfs(node):\n                return True\n                \n    return False"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What will the following code implementing a breadth-first search return?",
      "options": {
        "A": "The shortest path from start to end node",
        "B": "All possible paths from start to end node",
        "C": "Whether a path exists from start to end node",
        "D": "The longest path from start to end node"
      },
      "correct_answer": "C",
      "code_example": "from collections import deque\n\ndef bfs(graph, start, end):\n    if start == end:\n        return True\n        \n    visited = set([start])\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        \n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                if neighbor == end:\n                    return True\n                visited.add(neighbor)\n                queue.append(neighbor)\n                \n    return False"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will be the output of this requests library example?",
      "options": {
        "A": "A dictionary containing JSON data from the response",
        "B": "The HTTP status code of the response",
        "C": "The raw HTML content of the response",
        "D": "The URL of the request"
      },
      "correct_answer": "A",
      "code_example": "import requests\n\ndef get_data(url):\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.json()\n    return None\n\n# What does this function return for a successful API call?"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What is the purpose of the following code?",
      "options": {
        "A": "Implementing a queue using two stacks",
        "B": "Implementing a hash table with linear probing",
        "C": "Converting a binary tree to a linked list",
        "D": "Creating a circular buffer"
      },
      "correct_answer": "B",
      "code_example": "class HashTable:\n    def __init__(self, size=10):\n        self.size = size\n        self.keys = [None] * size\n        self.values = [None] * size\n        \n    def _hash(self, key):\n        return hash(key) % self.size\n        \n    def put(self, key, value):\n        index = self._hash(key)\n        \n        while self.keys[index] is not None:\n            if self.keys[index] == key:\n                break\n            index = (index + 1) % self.size\n            \n        self.keys[index] = key\n        self.values[index] = value\n        \n    def get(self, key):\n        index = self._hash(key)\n        \n        while self.keys[index] is not None:\n            if self.keys[index] == key:\n                return self.values[index]\n            index = (index + 1) % self.size\n            \n        return None"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What will the following Flask API endpoint return?",
      "options": {
        "A": "A JSON object with a 'message' property",
        "B": "A 404 error",
        "C": "A redirect to the /api/users endpoint",
        "D": "An HTML page"
      },
      "correct_answer": "A",
      "code_example": "from flask import Flask, jsonify\n\napp = Flask(__name__)\n\n@app.route('/api/hello', methods=['GET'])\ndef hello_world():\n    return jsonify({'message': 'Hello, World!'})"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What will be the result of the following class implementation?",
      "options": {
        "A": "\"My name is Alice and I am 30 years old\"",
        "B": "\"Alice (30)\"",
        "C": "\"<__main__.Person object at 0x...>\"",
        "D": "TypeError: __str__ returned non-string"
      },
      "correct_answer": "A",
      "code_example": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        \n    def __str__(self):\n        return f\"My name is {self.name} and I am {self.age} years old\"\n        \nperson = Person(\"Alice\", 30)\nprint(person)"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What is the correct way to implement CRUD operations in a RESTful API?",
      "options": {
        "A": "GET for Create, PUT for Read, POST for Update, DELETE for Delete",
        "B": "POST for Create, GET for Read, PUT for Update, DELETE for Delete",
        "C": "PUT for Create, GET for Read, POST for Update, DELETE for Delete",
        "D": "POST for Create, GET for Read, DELETE for Update, PUT for Delete"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What will the following code using a decorator with arguments do?",
      "options": {
        "A": "Execute the function 3 times",
        "B": "Print \"Retry 1\", \"Retry 2\", \"Retry 3\" and then execute the function",
        "C": "Try to execute the function, retrying up to 3 times if it fails",
        "D": "Execute the function with 3 as its argument"
      },
      "correct_answer": "C",
      "code_example": "def retry(max_attempts):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            attempts = 0\n            while attempts < max_attempts:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    attempts += 1\n                    if attempts == max_attempts:\n                        raise e\n        return wrapper\n    return decorator\n\n@retry(3)\ndef potentially_failing_function():\n    # function implementation\n    pass"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What happens to unreferenced objects in Python with circular references?",
      "options": {
        "A": "They remain in memory indefinitely",
        "B": "They are immediately collected by reference counting",
        "C": "They are collected by the cyclic garbage collector",
        "D": "They cause a MemoryError exception"
      },
      "correct_answer": "C",
      "code_example": "import gc\n\nclass Node:\n    def __init__(self, name):\n        self.name = name\n        self.next = None\n\n# Create circular reference\nnode1 = Node('node1')\nnode2 = Node('node2')\nnode1.next = node2\nnode2.next = node1\n\n# Remove references to the nodes\nnode1 = None\nnode2 = None\n\n# Force garbage collection\nprint(f'Unreachable objects before collection: {gc.collect()}')"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "What will be the output of the following code using class decorators?",
      "options": {
        "A": "10",
        "B": "11",
        "C": "Hello, world!",
        "D": "TypeError: 'str' object is not callable"
      },
      "correct_answer": "B",
      "code_example": "def add_method(cls):\n    cls.increment = lambda self: self.value + 1\n    return cls\n\n@add_method\nclass Counter:\n    def __init__(self, value):\n        self.value = value\n\ncounter = Counter(10)\nprint(counter.increment())"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "Which traversal method would produce the output [4, 2, 5, 1, 6, 3, 7] for the following binary tree?",
      "options": {
        "A": "Pre-order traversal",
        "B": "In-order traversal",
        "C": "Post-order traversal",
        "D": "Level-order traversal"
      },
      "correct_answer": "A",
      "code_example": "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef build_tree():\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    root.right.left = Node(6)\n    root.right.right = Node(7)\n    return root\n\ndef pre_order(node, result):\n    if node:\n        result.append(node.value)\n        pre_order(node.left, result)\n        pre_order(node.right, result)\n\nresult = []\npre_order(build_tree(), result)\nprint(result)"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "What will be the output of this backtracking algorithm that generates all permutations of [1, 2, 3]?",
      "options": {
        "A": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
        "B": "[[1, 2, 3]]",
        "C": "[[1, 1, 1], [2, 2, 2], [3, 3, 3]]",
        "D": "[]"
      },
      "correct_answer": "A",
      "code_example": "def permute(nums):\n    result = []\n    \n    def backtrack(curr, remaining):\n        if not remaining:\n            result.append(curr[:])\n            return\n        \n        for i in range(len(remaining)):\n            curr.append(remaining[i])\n            backtrack(curr, remaining[:i] + remaining[i+1:])\n            curr.pop()\n    \n    backtrack([], nums)\n    return result\n\nprint(permute([1, 2, 3]))"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "What does the following code do when executed?",
      "options": {
        "A": "Prints the titles of all articles on the webpage",
        "B": "Extracts and prints all paragraph text from the webpage",
        "C": "Downloads all images from the webpage",
        "D": "Prints all links on the webpage"
      },
      "correct_answer": "D",
      "code_example": "import requests\nfrom bs4 import BeautifulSoup\n\ndef extract_info(url):\n    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}\n    response = requests.get(url, headers=headers)\n    soup = BeautifulSoup(response.text, 'html.parser')\n    \n    links = []\n    for a_tag in soup.find_all('a', href=True):\n        links.append(a_tag['href'])\n    \n    return links\n\n# This would print all links from the webpage\n# print(extract_info('https://example.com'))"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "Which of the following statements about PyPy's just-in-time compilation is FALSE?",
      "options": {
        "A": "PyPy typically executes numerical computations faster than CPython",
        "B": "PyPy uses tracing JIT compilation to optimize frequently executed code paths",
        "C": "PyPy is fully compatible with all C extension modules designed for CPython",
        "D": "PyPy can reduce memory usage compared to CPython in long-running applications"
      },
      "correct_answer": "C"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "In the context of database transactions, what is the highest isolation level that guarantees no phantom reads will occur?",
      "options": {
        "A": "Read Uncommitted",
        "B": "Read Committed",
        "C": "Repeatable Read",
        "D": "Serializable"
      },
      "correct_answer": "D"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "Which of the following is NOT an ethical web scraping practice?",
      "options": {
        "A": "Respecting robots.txt directives",
        "B": "Implementing rate limiting to avoid server overload",
        "C": "Using multiple IP addresses to bypass rate limits",
        "D": "Including user-agent information in request headers"
      },
      "correct_answer": "C"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What will be the result of running this implementation of the A* search algorithm on the given graph?",
      "options": {
        "A": "Path: [1, 3, 6], Cost: 7",
        "B": "Path: [1, 2, 5, 6], Cost: 8",
        "C": "Path: [1, 4, 6], Cost: 9",
        "D": "No path found"
      },
      "correct_answer": "A",
      "code_example": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    open_set = [(0 + heuristic[start], 0, start, [start])]\n    closed_set = set()\n    \n    while open_set:\n        f, cost, current, path = heapq.heappop(open_set)\n        \n        if current in closed_set:\n            continue\n            \n        if current == goal:\n            return path, cost\n            \n        closed_set.add(current)\n        \n        for neighbor, step_cost in graph[current].items():\n            if neighbor not in closed_set:\n                new_cost = cost + step_cost\n                new_f = new_cost + heuristic[neighbor]\n                heapq.heappush(open_set, (new_f, new_cost, neighbor, path + [neighbor]))\n    \n    return None, float('inf')\n\n# Graph represented as adjacency list with costs\ngraph = {\n    1: {2: 3, 3: 2, 4: 5},\n    2: {1: 3, 5: 4},\n    3: {1: 2, 6: 5},\n    4: {1: 5, 6: 4},\n    5: {2: 4, 6: 1},\n    6: {3: 5, 4: 4, 5: 1}\n}\n\n# Heuristic values (estimated cost to goal)\nheuristic = {1: 6, 2: 3, 3: 2, 4: 4, 5: 1, 6: 0}\n\npath, cost = a_star_search(graph, 1, 6, heuristic)\nprint(f\"Path: {path}, Cost: {cost}\")"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "What will be the output of this finite state machine implementation?",
      "options": {
        "A": "Accepted",
        "B": "Rejected",
        "C": "State transition error",
        "D": "Stack overflow"
      },
      "correct_answer": "B",
      "code_example": "class StateMachine:\n    def __init__(self):\n        self.state = 'start'\n        self.transitions = {\n            'start': {'a': 'state1', 'b': 'state2'},\n            'state1': {'a': 'state1', 'b': 'state3'},\n            'state2': {'a': 'state3', 'b': 'state2'},\n            'state3': {'a': 'state2', 'b': 'state1'}\n        }\n        self.accepting_states = {'state3'}\n    \n    def process(self, input_string):\n        for char in input_string:\n            if char in self.transitions[self.state]:\n                self.state = self.transitions[self.state][char]\n            else:\n                return \"Rejected\"\n        \n        if self.state in self.accepting_states:\n            return \"Accepted\"\n        else:\n            return \"Rejected\"\n\nsm = StateMachine()\nresult = sm.process(\"ababba\")\nprint(result)"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What will be the result of the following NumPy operations?",
      "options": {
        "A": "array([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])",
        "B": "array([[ 0,  4,  8],\n       [ 1,  5,  9],\n       [ 2,  6, 10],\n       [ 3,  7, 11]])",
        "C": "array([[ 0,  4,  8],\n       [ 1,  5,  9],\n       [ 2,  6, 10]])",
        "D": "ValueError: operands could not be broadcast together"
      },
      "correct_answer": "B",
      "code_example": "import numpy as np\n\na = np.arange(12).reshape(3, 4)\nb = a.T  # Transpose\n\nprint(b)"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "Which of the following statements about CPython's implementation is FALSE?",
      "options": {
        "A": "CPython compiles Python code to bytecode before execution",
        "B": "CPython uses a Global Interpreter Lock (GIL) that restricts multiple threads from executing Python bytecode simultaneously",
        "C": "CPython converts Python code directly to machine code for execution",
        "D": "CPython implements reference counting as its primary method of memory management"
      },
      "correct_answer": "C"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What will be the output of this code that handles a JavaScript-heavy website?",
      "options": {
        "A": "It extracts all text from the page",
        "B": "It waits for JavaScript to load, then clicks a button",
        "C": "It disables JavaScript execution on the page",
        "D": "It extracts all links generated by JavaScript"
      },
      "correct_answer": "B",
      "code_example": "from selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n\ndef interact_with_js_page(url):\n    driver = webdriver.Chrome()\n    try:\n        driver.get(url)\n        # Wait for button to be clickable\n        button = WebDriverWait(driver, 10).until(\n            EC.element_to_be_clickable((By.ID, \"dynamicButton\"))\n        )\n        button.click()\n        return \"Clicked the button after waiting for JavaScript to load\"\n    finally:\n        driver.quit()\n\n# This would interact with a JavaScript-heavy page\n# print(interact_with_js_page('https://example.com'))"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "What approximation algorithm is implemented in the following code?",
      "options": {
        "A": "Traveling Salesman approximation",
        "B": "Knapsack problem approximation",
        "C": "Minimum vertex cover approximation",
        "D": "Set cover approximation"
      },
      "correct_answer": "B",
      "code_example": "def approximate_solution(items, max_weight):\n    # items is a list of (value, weight) tuples\n    # Sort items by value/weight ratio in descending order\n    items_sorted = sorted(items, key=lambda x: x[0] / x[1], reverse=True)\n    \n    total_value = 0\n    total_weight = 0\n    selected_items = []\n    \n    for value, weight in items_sorted:\n        if total_weight + weight <= max_weight:\n            selected_items.append((value, weight))\n            total_value += value\n            total_weight += weight\n    \n    return total_value, selected_items\n\nitems = [(60, 10), (100, 20), (120, 30), (80, 15), (40, 5)]\nmax_weight = 35\n\nvalue, selected = approximate_solution(items, max_weight)\nprint(f\"Total value: {value}, Selected items: {selected}\")"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "What debugging technique is being used in the following code?",
      "options": {
        "A": "Assertion-based debugging",
        "B": "Logging-based debugging",
        "C": "Tracing with pdb",
        "D": "Profiling"
      },
      "correct_answer": "C",
      "code_example": "def calculate_factorial(n):\n    if n < 0:\n        return None\n    if n == 0 or n == 1:\n        return 1\n    return n * calculate_factorial(n - 1)\n\ndef debug_factorial():\n    import pdb\n    pdb.set_trace()  # Start the debugger\n    result = calculate_factorial(4)\n    print(f\"Factorial: {result}\")\n\n# This would start an interactive debugging session\n# debug_factorial()"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "What will the following Selenium code do when executed?",
      "options": {
        "A": "Take a screenshot of a page after scrolling to the bottom",
        "B": "Fill out a form, submit it, and wait for a success message",
        "C": "Scroll through an infinite loading page and collect all items",
        "D": "Navigate through multiple pages of a pagination system"
      },
      "correct_answer": "C",
      "code_example": "from selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\n\ndef scroll_and_collect(url, max_items=100):\n    driver = webdriver.Chrome()\n    try:\n        driver.get(url)\n        items = []\n        last_count = 0\n        \n        while len(items) < max_items:\n            # Find all items currently loaded\n            elements = driver.find_elements(By.CSS_SELECTOR, \".item\")\n            \n            # Extract data from new elements\n            for i in range(last_count, len(elements)):\n                if i < len(elements):\n                    items.append(elements[i].text)\n            \n            if len(elements) == last_count:  # No new items loaded\n                break\n                \n            last_count = len(elements)\n            \n            # Scroll to bottom to trigger loading more items\n            driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")\n            time.sleep(2)  # Wait for new items to load\n            \n        return items\n    finally:\n        driver.quit()\n\n# This would scroll through a page with infinite loading\n# print(scroll_and_collect('https://example.com'))"
    }
  ]
}
