{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "x = 10\nif x > 5:\n    print('Greater')\nelif x < 5:\n    print('Lesser')\nelse:\n    print('Equal')",
      "options": {
        "A": "Greater",
        "B": "Lesser",
        "C": "Equal",
        "D": "No output"
      },
      "correct_answer": "A"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What is the result of the following conditional expression?",
      "code_example": "result = 'Even' if 8 % 2 == 0 else 'Odd'\nprint(result)",
      "options": {
        "A": "Odd",
        "B": "Even",
        "C": "True",
        "D": "False"
      },
      "correct_answer": "B"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will this function return when called as shown?",
      "code_example": "def multiply(a, b=2):\n    return a * b\n\nprint(multiply(5))",
      "options": {
        "A": "5",
        "B": "2",
        "C": "10",
        "D": "Error"
      },
      "correct_answer": "C"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "Convert the decimal number 42 to binary. What is the result?",
      "options": {
        "A": "100010",
        "B": "101010",
        "C": "110010",
        "D": "111010"
      },
      "correct_answer": "B"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What is the greatest common divisor (GCD) of 48 and 60?",
      "options": {
        "A": "6",
        "B": "12",
        "C": "24",
        "D": "36"
      },
      "correct_answer": "B"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What is the output of this factorial calculation?",
      "code_example": "def factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nprint(factorial(4))",
      "options": {
        "A": "12",
        "B": "16",
        "C": "24",
        "D": "64"
      },
      "correct_answer": "C"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "What happens when the following code is executed?",
      "code_example": "with open('nonexistent_file.txt', 'r') as file:\n    data = file.read()\nprint('File read successfully')",
      "options": {
        "A": "An empty file is created",
        "B": "The program prints 'File read successfully'",
        "C": "A FileNotFoundError is raised",
        "D": "A PermissionError is raised"
      },
      "correct_answer": "C"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be printed by this code?",
      "code_example": "x = 10\n\ndef modify():\n    x = 20\n    print(f\"Inside function: {x}\")\n\nmodify()\nprint(f\"Outside function: {x}\")",
      "options": {
        "A": "Inside function: 10\nOutside function: 10",
        "B": "Inside function: 20\nOutside function: 10",
        "C": "Inside function: 20\nOutside function: 20",
        "D": "Inside function: 10\nOutside function: 20"
      },
      "correct_answer": "B"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What exception will be raised by the following code?",
      "code_example": "numbers = [1, 2, 3]\nprint(numbers[5])",
      "options": {
        "A": "ValueError",
        "B": "TypeError",
        "C": "IndexError",
        "D": "KeyError"
      },
      "correct_answer": "C"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What will be the output of this while loop?",
      "code_example": "counter = 0\nwhile counter < 5:\n    counter += 1\n    if counter == 3:\n        continue\n    print(counter, end=' ')",
      "options": {
        "A": "1 2 3 4 5",
        "B": "1 2 4 5",
        "C": "1 2 3 4",
        "D": "1 2 4"
      },
      "correct_answer": "B"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "What is the advantage of using raw strings in Python?",
      "options": {
        "A": "They execute faster than regular strings",
        "B": "They can store more characters than regular strings",
        "C": "They don't treat backslashes as escape characters",
        "D": "They automatically convert to uppercase"
      },
      "correct_answer": "C"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following string slicing operation?",
      "code_example": "text = \"Python Programming\"\nprint(text[7:11])",
      "options": {
        "A": "Prog",
        "B": "Pyth",
        "C": "Programm",
        "D": "gram"
      },
      "correct_answer": "A"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "How can you handle multiple exceptions in a single except block?",
      "code_example": "try:\n    value = int(input('Enter a number: '))\n    result = 10 / value\n    print(result)\nexcept (ValueError, ZeroDivisionError) as e:\n    print(f\"Error: {e}\")",
      "options": {
        "A": "Using a list of exceptions",
        "B": "Using a tuple of exceptions",
        "C": "Using a dictionary of exceptions",
        "D": "Multiple except blocks cannot handle multiple exceptions"
      },
      "correct_answer": "B"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What is the purpose of the 'with' statement in Python?",
      "options": {
        "A": "To create a new function",
        "B": "To handle exceptions",
        "C": "To implement context management (automatic resource cleanup)",
        "D": "To define a new class"
      },
      "correct_answer": "C"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of this try/except/else/finally block?",
      "code_example": "try:\n    print('Try block')\n    x = 10\nexcept:\n    print('Except block')\nelse:\n    print('Else block')\nfinally:\n    print('Finally block')",
      "options": {
        "A": "Try block\nFinally block",
        "B": "Try block\nExcept block\nFinally block",
        "C": "Try block\nElse block\nFinally block",
        "D": "Try block\nElse block"
      },
      "correct_answer": "C"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "Calculate the mean and median of the following dataset: [4, 1, 7, 1, 8, 3]",
      "options": {
        "A": "Mean: 4.0, Median: 3.5",
        "B": "Mean: 4.0, Median: 4.0",
        "C": "Mean: 3.5, Median: 4.0",
        "D": "Mean: 24, Median: 4.0"
      },
      "correct_answer": "A"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "Which algorithm can be used to detect cycles in a directed graph?",
      "options": {
        "A": "Breadth-First Search with a visited set",
        "B": "Depth-First Search with a recursion stack",
        "C": "Binary search with backtracking",
        "D": "Bubble sort with graph coloring"
      },
      "correct_answer": "B"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "What will be the output of this code using the requests library?",
      "code_example": "import requests\n\nresponse = requests.get('https://httpbin.org/status/404')\nif response.status_code == 200:\n    print('Success')\nelse:\n    print(f'Failed: {response.status_code}')",
      "options": {
        "A": "Success",
        "B": "Failed: 404",
        "C": "Failed: 500",
        "D": "The code will raise an exception"
      },
      "correct_answer": "B"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "When would you use a NumPy array instead of a Python list?",
      "options": {
        "A": "When you need to store different data types",
        "B": "When you need frequent insertions and deletions",
        "C": "When you need efficient numerical operations on homogeneous data",
        "D": "When you need to maintain order of insertion"
      },
      "correct_answer": "C"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "In a web framework like Flask or Django, what is the relationship between templates and static files?",
      "options": {
        "A": "Templates contain HTML with placeholders for dynamic data; static files are unchanging resources like CSS/JS",
        "B": "Templates are Python modules; static files are HTML documents",
        "C": "Templates and static files are the same thing",
        "D": "Templates are database models; static files are configuration files"
      },
      "correct_answer": "A"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What is the key difference between a generator expression and a list comprehension?",
      "code_example": "# Expression 1\nlist_comp = [x**2 for x in range(1000000)]\n\n# Expression 2\ngen_exp = (x**2 for x in range(1000000))",
      "options": {
        "A": "Generator expressions use parentheses while list comprehensions use square brackets",
        "B": "Generator expressions evaluate lazily (on-demand) while list comprehensions create the entire list in memory",
        "C": "Generator expressions can only be used once while list comprehensions can be reused",
        "D": "All of the above"
      },
      "correct_answer": "D"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What will be printed by the following code involving nested data structures?",
      "code_example": "users = [\n    {'name': 'Alice', 'age': 25, 'active': True},\n    {'name': 'Bob', 'age': 30, 'active': False},\n    {'name': 'Charlie', 'age': 35, 'active': True}\n]\n\nactive_names = [user['name'] for user in users if user['active']]\nprint(active_names)",
      "options": {
        "A": "['Alice', 'Bob', 'Charlie']",
        "B": "['Alice', 'Charlie']",
        "C": "['Bob']",
        "D": "[{'name': 'Alice'}, {'name': 'Charlie'}]"
      },
      "correct_answer": "B"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "How would you find all connected components in an undirected graph?",
      "options": {
        "A": "Use a breadth-first search starting from each unvisited node",
        "B": "Sort the graph's edges in ascending order of weight",
        "C": "Apply the Floyd-Warshall algorithm to find all shortest paths",
        "D": "Use a priority queue to find the minimum spanning tree"
      },
      "correct_answer": "A"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What will happen when you execute the following code?",
      "code_example": "# main.py\nfrom mymodule import my_function\n\n# mymodule.py (in the same directory)\ndef my_function():\n    print('Hello from mymodule!')\n\nif __name__ == '__main__':\n    print('mymodule executed directly')\nelse:\n    print('mymodule imported elsewhere')",
      "options": {
        "A": "Prints: 'Hello from mymodule!'",
        "B": "Prints: 'mymodule executed directly'",
        "C": "Prints: 'mymodule imported elsewhere'",
        "D": "Raises an ImportError"
      },
      "correct_answer": "C"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What is a primary benefit of lazy evaluation in Python?",
      "options": {
        "A": "It makes the code more readable",
        "B": "It reduces memory consumption by computing values only when needed",
        "C": "It automatically optimizes recursive functions",
        "D": "It prevents stack overflow errors"
      },
      "correct_answer": "B"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What modification would make this binary search algorithm more efficient?",
      "code_example": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
      "options": {
        "A": "Change mid calculation to avoid potential integer overflow: mid = left + (right - left) // 2",
        "B": "Use recursion instead of iteration",
        "C": "Change the return value to None instead of -1",
        "D": "Use a dictionary instead of an array for the search"
      },
      "correct_answer": "A"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What will be the result of the following functional operations?",
      "code_example": "from functools import reduce\n\nnumbers = [1, 2, 3, 4, 5]\nresult = reduce(lambda x, y: x * y, map(lambda x: x**2, filter(lambda x: x % 2 == 1, numbers)))\nprint(result)",
      "options": {
        "A": "15",
        "B": "225",
        "C": "945",
        "D": "625"
      },
      "correct_answer": "B"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What will the following regex pattern match?",
      "code_example": "import re\n\npattern = r'^\\w+[.-]\\w+@\\w+\\.\\w{2,3}$'\nprint(re.match(pattern, 'user-name@example.com'))",
      "options": {
        "A": "Any valid email address",
        "B": "Email addresses with a hyphen or dot in the username part",
        "C": "Email addresses with exactly two or three characters in the TLD",
        "D": "Email addresses with username containing only letters, domains with only letters"
      },
      "correct_answer": "B"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What will be the output of this code using property decorators?",
      "code_example": "class Circle:\n    def __init__(self, radius):\n        self._radius = radius\n        \n    @property\n    def radius(self):\n        return self._radius\n        \n    @radius.setter\n    def radius(self, value):\n        if value > 0:\n            self._radius = value\n        \n    @property\n    def area(self):\n        return 3.14 * self._radius ** 2\n\nc = Circle(5)\nc.radius = -10\nprint(f\"Radius: {c.radius}, Area: {c.area:.2f}\")",
      "options": {
        "A": "Radius: -10, Area: 314.00",
        "B": "Radius: 5, Area: 78.50",
        "C": "Radius: -10, Area: -314.00",
        "D": "Error: 'Circle' object has no attribute 'area'"
      },
      "correct_answer": "B"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "Which regex pattern would be most efficient for validating a US phone number in the format (123) 456-7890?",
      "options": {
        "A": "r'\\(\\d{3}\\) \\d{3}-\\d{4}'",
        "B": "r'\\(\\d+\\) \\d+-\\d+'",
        "C": "r'\\([0-9][0-9][0-9]\\) [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]'",
        "D": "r'.*\\(\\d{3}\\) \\d{3}-\\d{4}.*'"
      },
      "correct_answer": "A"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What will be the output of this code using *args and **kwargs?",
      "code_example": "def format_message(*args, **kwargs):\n    result = ', '.join(args)\n    if kwargs:\n        result += ' | ' + ', '.join([f\"{k}={v}\" for k, v in kwargs.items()])\n    return result\n\nprint(format_message('Hello', 'World', user='John', status='active'))",
      "options": {
        "A": "Hello, World",
        "B": "Hello, World | user=John, status=active",
        "C": "('Hello', 'World') | {'user': 'John', 'status': 'active'}",
        "D": "Hello, World | John, active"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What will the following dictionary and set comprehensions produce?",
      "code_example": "numbers = [1, 2, 3, 4, 5, 5]\n\nsquared_dict = {n: n**2 for n in numbers}\nsquared_set = {n**2 for n in numbers}\n\nprint(f\"Dict: {squared_dict}\\nSet: {squared_set}\")",
      "options": {
        "A": "Dict: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\nSet: {1, 4, 9, 16, 25}",
        "B": "Dict: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 5: 25}\nSet: {1, 4, 9, 16, 25}",
        "C": "Dict: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\nSet: {1, 4, 9, 16, 25, 25}",
        "D": "Dict: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 5: 25}\nSet: {1, 4, 9, 16, 25, 25}"
      },
      "correct_answer": "A"
    },
 {
      "id": 33,
      "difficulty": "hard",
      "topic": "Multiple inheritance and MRO",
      "question": "What will be the output of the following code that demonstrates Method Resolution Order (MRO)?",
      "code_example": "class A:\n    def process(self):\n        return 'A'\n\nclass B(A):\n    def process(self):\n        return 'B' + super().process()\n\nclass C(A):\n    def process(self):\n        return 'C' + super().process()\n\nclass D(B, C):\n    def process(self):\n        return 'D' + super().process()\n\nprint(D.__mro__)\nprint(D().process())",
      "options": {
        "A": "(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)\nDBA",
        "B": "(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)\nDBCA",
        "C": "(<class '__main__.D'>, <class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)\nDCBA",
        "D": "(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.A'>, <class '__main__.C'>, <class 'object'>)\nDBA"
      },
      "correct_answer": "B"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "topic": "Backtracking algorithms",
      "question": "What will be the value of 'result' after executing the following backtracking algorithm for the N-Queens problem with n=4?",
      "code_example": "def is_safe(board, row, col, n):\n    # Check row on left side\n    for i in range(col):\n        if board[row][i] == 1:\n            return False\n    \n    # Check upper diagonal on left side\n    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    \n    # Check lower diagonal on left side\n    for i, j in zip(range(row, n), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    \n    return True\n\ndef solve_n_queens(n):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    solutions = []\n    \n    def backtrack(col):\n        if col >= n:\n            # Found a solution, add it to the list\n            solution = []\n            for i in range(n):\n                row_str = ''\n                for j in range(n):\n                    if board[i][j] == 1:\n                        row_str += 'Q'\n                    else:\n                        row_str += '.'\n                solution.append(row_str)\n            solutions.append(solution)\n            return\n        \n        for row in range(n):\n            if is_safe(board, row, col, n):\n                board[row][col] = 1\n                backtrack(col + 1)\n                board[row][col] = 0  # Backtrack\n    \n    backtrack(0)\n    return solutions\n\nresult = solve_n_queens(4)\nprint(len(result))",
      "options": {
        "A": "1",
        "B": "2", 
        "C": "4",
        "D": "92"
      },
      "correct_answer": "B"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "topic": "Design patterns (Singleton, Factory, Observer)",
      "question": "Which of the following describes a problem with the implementation of this Singleton pattern?",
      "code_example": "class DatabaseConnection:\n    _instance = None\n    \n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super(DatabaseConnection, cls).__new__(cls)\n            # Initialization code\n            cls._instance.host = 'localhost'\n            cls._instance.port = 5432\n            cls._instance.user = 'admin'\n            cls._instance.connected = False\n        return cls._instance\n    \n    def connect(self):\n        if not self.connected:\n            # Connect to the database\n            self.connected = True\n            print(f\"Connected to {self.host}:{self.port} as {self.user}\")\n        else:\n            print(\"Already connected\")\n\n# Create two database instances\ndb1 = DatabaseConnection()\ndb2 = DatabaseConnection()\n\n# Check if they are the same instance\nprint(db1 is db2)\n\n# Modify one instance\ndb1.host = '127.0.0.1'\n\n# Check if the change is reflected in the other instance\nprint(db2.host)",
      "options": {
        "A": "The pattern is not thread-safe and could create multiple instances in a multi-threaded environment",
        "B": "The pattern doesn't properly handle inheritance - subclasses would each have their own singleton instance",
        "C": "The __init__ method is missing, so the object's initialization is incomplete",
        "D": "The implementation relies on class variables which can cause memory leaks"
      },
      "correct_answer": "A"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "topic": "Basic ML pipeline implementation",
      "question": "In the following ML pipeline code, what is the primary issue that needs to be addressed?",
      "code_example": "from sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import accuracy_score\nimport pandas as pd\nimport numpy as np\n\n# Load and prepare data\ndata = pd.DataFrame({\n    'feature1': np.random.randn(100),\n    'feature2': np.random.randn(100),\n    'target': np.random.choice([0, 1], size=100)\n})\n\n# Split into features and target\nX = data[['feature1', 'feature2']]\ny = data['target']\n\n# Split into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Scale the features\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\n\n# Train the model\nmodel = LogisticRegression(random_state=42)\nmodel.fit(X_train_scaled, y_train)\n\n# Predict and evaluate\nX_test_scaled = scaler.transform(X_test)\ny_pred = model.predict(X_test_scaled)\naccuracy = accuracy_score(y_test, y_pred)\nprint(f\"Accuracy: {accuracy:.2f}\")",
      "options": {
        "A": "The training and test data should be split after scaling, not before",
        "B": "Cross-validation is missing, which is essential for reliable model evaluation",
        "C": "The scaler is fitted on the training data and then used to transform the test data, which may lead to data leakage",
        "D": "The model should be initialized with a different random state than the train_test_split function"
      },
      "correct_answer": "C"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "topic": "Query optimization",
      "question": "Which of the following techniques would be LEAST effective in optimizing the performance of this database query in a Python application?",
      "code_example": "import psycopg2\n\ndef get_user_orders(user_id):\n    conn = psycopg2.connect(\"dbname=store user=postgres password=secret\")\n    cursor = conn.cursor()\n    \n    query = \"\"\"\n    SELECT o.order_id, o.order_date, o.total_amount,\n           p.product_id, p.name, p.price, oi.quantity\n    FROM orders o\n    JOIN order_items oi ON o.order_id = oi.order_id\n    JOIN products p ON oi.product_id = p.product_id\n    WHERE o.user_id = %s\n    ORDER BY o.order_date DESC\n    \"\"\"\n    \n    cursor.execute(query, (user_id,))\n    results = cursor.fetchall()\n    \n    cursor.close()\n    conn.close()\n    \n    return results",
      "options": {
        "A": "Creating database indexes on the join columns and filtering columns",
        "B": "Using connection pooling instead of creating a new connection for each query",
        "C": "Converting the query to use NoSQL document structures instead of SQL joins",
        "D": "Implementing result pagination with LIMIT and OFFSET clauses"
      },
      "correct_answer": "C"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "topic": "Topological sorting",
      "question": "Given the following implementation of topological sorting for course prerequisites, what will be the output when prerequisites = [(1,0), (2,0), (3,1), (3,2)]?",
      "code_example": "from collections import defaultdict, deque\n\ndef topological_sort(prerequisites, num_courses):\n    # Build adjacency list\n    graph = defaultdict(list)\n    in_degree = [0] * num_courses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    # Initialize queue with courses that have no prerequisites\n    queue = deque([i for i in range(num_courses) if in_degree[i] == 0])\n    result = []\n    \n    # Process queue\n    while queue:\n        current = queue.popleft()\n        result.append(current)\n        \n        for neighbor in graph[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check if topological sort is possible\n    if len(result) != num_courses:\n        return \"Impossible to complete all courses due to cyclic dependencies\"\n    \n    return result\n\nprerequisites = [(1,0), (2,0), (3,1), (3,2)]\nprint(topological_sort(prerequisites, 4))",
      "options": {
        "A": "[0, 1, 2, 3]",
        "B": "[0, 2, 1, 3]", 
        "C": "[0, 1, 3, 2]",
        "D": "Impossible to complete all courses due to cyclic dependencies"
      },
      "correct_answer": "A"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "topic": "GraphQL APIs",
      "question": "When building a Python GraphQL API with Graphene, what is the primary benefit of using DataLoader compared to resolving relationships individually?",
      "options": {
        "A": "DataLoader automatically handles pagination for GraphQL queries",
        "B": "DataLoader solves the N+1 query problem by batching and caching database requests",
        "C": "DataLoader provides client-side state management for GraphQL mutations",
        "D": "DataLoader improves security by automatically filtering sensitive fields"
      },
      "correct_answer": "B"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "topic": "SOLID principles implementation",
      "question": "Which SOLID principle is being violated in the following code?",
      "code_example": "class Report:\n    def __init__(self, data):\n        self.data = data\n    \n    def generate(self, format_type):\n        if format_type == 'PDF':\n            return self._generate_pdf()\n        elif format_type == 'HTML':\n            return self._generate_html()\n        elif format_type == 'JSON':\n            return self._generate_json()\n        else:\n            raise ValueError(f\"Unsupported format: {format_type}\")\n    \n    def _generate_pdf(self):\n        # Complex PDF generation logic\n        return \"PDF Report\"\n    \n    def _generate_html(self):\n        # Complex HTML generation logic\n        return \"<html>HTML Report</html>\"\n    \n    def _generate_json(self):\n        # JSON conversion logic\n        return '{\"report\": \"JSON Report\"}'\n\nreport = Report([1, 2, 3, 4, 5])\nprint(report.generate('HTML'))",
      "options": {
        "A": "Single Responsibility Principle - the Report class has multiple responsibilities",
        "B": "Open/Closed Principle - the class must be modified to add new report formats",
        "C": "Liskov Substitution Principle - the class cannot be properly inherited from",
        "D": "Interface Segregation Principle - clients are forced to depend on methods they don't use"
      },
      "correct_answer": "B"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "topic": "String algorithms (KMP, Rabin-Karp)",
      "question": "What will be the output of the following implementation of the Rabin-Karp string matching algorithm when searching for the pattern 'AABA' in the text 'AABAACAADAABAABA'?",
      "code_example": "def rabin_karp(pattern, text, prime=101):\n    m, n = len(pattern), len(text)\n    p_hash = 0  # hash value for pattern\n    t_hash = 0  # hash value for text\n    matches = []\n    \n    # Calculate hash values for pattern and first window of text\n    for i in range(m):\n        p_hash = (p_hash * 256 + ord(pattern[i])) % prime\n        t_hash = (t_hash * 256 + ord(text[i])) % prime\n    \n    # Calculate (256^(m-1)) % prime for rolling hash\n    h = 1\n    for i in range(m-1):\n        h = (h * 256) % prime\n    \n    # Slide the pattern over text one by one\n    for i in range(n - m + 1):\n        # Check if hash values match\n        if p_hash == t_hash:\n            # Check for actual match character by character\n            match = True\n            for j in range(m):\n                if text[i+j] != pattern[j]:\n                    match = False\n                    break\n            \n            if match:\n                matches.append(i)\n        \n        # Calculate hash value for next window\n        if i < n - m:\n            t_hash = (256 * (t_hash - ord(text[i]) * h) + ord(text[i + m])) % prime\n            # Make sure hash is positive\n            if t_hash < 0:\n                t_hash += prime\n    \n    return matches\n\ntext = \"AABAACAADAABAABA\"\npattern = \"AABA\"\nresult = rabin_karp(pattern, text)\nprint(result)",
      "options": {
        "A": "[0, 10]",
        "B": "[0, 9, 12]", 
        "C": "[0, 10, 12]",
        "D": "[0, 9, 10, 12]"
      },
      "correct_answer": "B"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "topic": "Handling JavaScript-heavy sites",
      "question": "When using Python to scrape a JavaScript-heavy website, what is the main limitation of the following approach?",
      "code_example": "import requests\nfrom bs4 import BeautifulSoup\n\ndef scrape_js_site(url):\n    # Send HTTP request to the website\n    response = requests.get(url)\n    \n    # Parse HTML content\n    soup = BeautifulSoup(response.text, 'html.parser')\n    \n    # Extract data from the parsed HTML\n    products = []\n    for product in soup.select('.product-item'):\n        name = product.select_one('.product-name').text.strip()\n        price = product.select_one('.product-price').text.strip()\n        products.append({'name': name, 'price': price})\n    \n    return products",
      "options": {
        "A": "It can't handle content that is loaded asynchronously via AJAX calls",
        "B": "BeautifulSoup is significantly slower than alternative parsers for JavaScript content",
        "C": "The requests library doesn't support the HTTP/2 protocol needed for modern websites",
        "D": "This approach would quickly get rate-limited because it doesn't use proper request headers"
      },
      "correct_answer": "A"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "topic": "Shortest path algorithms (Dijkstra's, Bellman-Ford)",
      "question": "What will be the output of the following implementation of Dijkstra's algorithm when finding the shortest path from node 0 to all other nodes?",
      "code_example": "import heapq\n\ndef dijkstra(graph, start):\n    # Initialize distances with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in range(len(graph))}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node) pairs\n    pq = [(0, start)]\n    \n    # Track visited nodes\n    visited = set()\n    \n    while pq:\n        # Get the node with the smallest distance\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If we've already processed this node, skip it\n        if current_node in visited:\n            continue\n        \n        # Mark as visited\n        visited.add(current_node)\n        \n        # Check all neighbors\n        for neighbor, weight in graph[current_node]:\n            if neighbor in visited:\n                continue\n                \n            # Calculate distance to neighbor through current node\n            distance = current_distance + weight\n            \n            # If we found a shorter path, update the distance\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\n# Graph represented as adjacency list: (neighbor, weight) pairs\ngraph = [\n    [(1, 4), (2, 2)],          # Node 0 connections\n    [(0, 4), (2, 1), (3, 5)],    # Node 1 connections\n    [(0, 2), (1, 1), (3, 8)],    # Node 2 connections\n    [(1, 5), (2, 8)]             # Node 3 connections\n]\n\nresult = dijkstra(graph, 0)\nprint(result)",
      "options": {
        "A": "{0: 0, 1: 3, 2: 2, 3: 8}",
        "B": "{0: 0, 1: 4, 2: 2, 3: 7}", 
        "C": "{0: 0, 1: 4, 2: 2, 3: 9}",
        "D": "{0: 0, 1: 4, 2: 2, 3: 10}"
      },
      "correct_answer": "C"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "topic": "Mock objects and patching",
      "question": "What will be the output of running the following test with pytest?",
      "code_example": "import pytest\nfrom unittest.mock import patch, MagicMock\n\nclass Database:\n    def connect(self):\n        # In a real implementation, this would connect to a database\n        return \"Connected to real database\"\n    \n    def execute_query(self, query):\n        # This would execute an actual database query\n        return f\"Executed: {query}\"\n\nclass UserService:\n    def __init__(self, database):\n        self.db = database\n    \n    def get_user_by_id(self, user_id):\n        query = f\"SELECT * FROM users WHERE id = {user_id}\"\n        result = self.db.execute_query(query)\n        # Process result...\n        return {\"id\": user_id, \"name\": \"Test User\"}\n\n# The test\ndef test_get_user_by_id():\n    # Create a mock database\n    mock_db = MagicMock()\n    mock_db.execute_query.return_value = \"Mocked query result\"\n    \n    # Create the service with the mock\n    service = UserService(mock_db)\n    \n    # Test the method\n    with patch.object(service, 'get_user_by_id', wraps=service.get_user_by_id) as wrapped_method:\n        result = service.get_user_by_id(42)\n        \n        # Assertions\n        assert result[\"id\"] == 42\n        print(f\"Called with: {wrapped_method.call_args[0][0]}\")\n        print(f\"Mock called: {mock_db.execute_query.called}\")\n        print(f\"Call count: {mock_db.execute_query.call_count}\")\n        print(f\"Call args: {mock_db.execute_query.call_args[0][0]}\")",
      "options": {
        "A": "Called with: 42\nMock called: True\nCall count: 1\nCall args: SELECT * FROM users WHERE id = 42",
        "B": "Called with: 42\nMock called: False\nCall count: 0\nCall args: None", 
        "C": "TypeError: 'MagicMock' object is not subscriptable",
        "D": "AssertionError: assert 'Mocked query result' == {'id': 42, 'name': 'Test User'}"
      },
      "correct_answer": "A"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "topic": "Pandas for data manipulation",
      "question": "What will be the shape of the DataFrame after executing the following Pandas operations?",
      "code_example": "import pandas as pd\nimport numpy as np\n\n# Create a DataFrame\ndf = pd.DataFrame({\n    'A': np.random.randn(6),\n    'B': ['foo', 'bar', 'foo', 'bar', 'foo', 'bar'],\n    'C': np.random.randint(0, 10, 6),\n    'D': pd.date_range('20230101', periods=6)\n})\n\n# Add a new column with NaN values\ndf['E'] = [1.0, np.nan, 3.0, np.nan, 5.0, 6.0]\n\n# Filter rows\nmasked_df = df[df['C'] > 5]\n\n# Group by column B and aggregate\ngrouped = masked_df.groupby('B').agg({\n    'A': 'mean',\n    'C': 'sum',\n    'E': 'min'\n}).reset_index()\n\n# Merge with original DataFrame\nresult = pd.merge(\n    df,\n    grouped,\n    on='B',\n    suffixes=('', '_grouped')\n)\n\nprint(result.shape)",
      "options": {
        "A": "(6, 8)",
        "B": "(2, 8)",
        "C": "(6, 7)",
        "D": "(2, 7)"
      },
      "correct_answer": "A"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "topic": "Attribute access (getattr, setattr)",
      "question": "What will be printed when executing the following code using Python's attribute access mechanisms?",
      "code_example": "class DynamicAttributes:\n    def __init__(self):\n        self._attributes = {}\n    \n    def __getattr__(self, name):\n        if name in self._attributes:\n            return self._attributes[name]\n        elif name.startswith('get_'):\n            attr_name = name[4:]  # Remove 'get_' prefix\n            return lambda: self._attributes.get(attr_name, None)\n        else:\n            raise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{name}'\")\n    \n    def __setattr__(self, name, value):\n        if name == '_attributes':\n            super().__setattr__(name, value)\n        else:\n            # Store the attribute in our internal dictionary\n            self._attributes[name] = value\n    \n    def __delattr__(self, name):\n        if name in self._attributes:\n            del self._attributes[name]\n        else:\n            raise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{name}'\")\n\n# Create an instance\nobj = DynamicAttributes()\n\n# Set some attributes\nobj.name = \"Dynamic Object\"\nobj.value = 42\n\n# Access them directly and through getattr\nprint(obj.name)\nprint(getattr(obj, \"value\"))\n\n# Use the dynamic getter method\nprint(obj.get_name())\n\n# Try to access a non-existent attribute\ntry:\n    print(obj.missing)\nexcept AttributeError as e:\n    print(f\"Error: {e}\")\n\n# Set an attribute using setattr\nsetattr(obj, \"new_attr\", \"Created with setattr\")\n\n# Delete an attribute\ndelattr(obj, \"value\")\n\n# Check the internal state\nprint(obj._attributes)",
      "options": {
        "A": "Dynamic Object\n42\nDynamic Object\nError: 'DynamicAttributes' object has no attribute 'missing'\n{'name': 'Dynamic Object', 'new_attr': 'Created with setattr'}",
        "B": "Dynamic Object\n42\nDynamic Object\nError: 'DynamicAttributes' object has no attribute 'missing'\n{'name': 'Dynamic Object', 'value': 42, 'new_attr': 'Created with setattr'}", 
        "C": "Dynamic Object\n42\nDynamic Object\nNone\n{'name': 'Dynamic Object', 'new_attr': 'Created with setattr'}",
        "D": "Error: 'DynamicAttributes' object has no attribute 'name'\nError: 'DynamicAttributes' object has no attribute 'value'\nError: 'DynamicAttributes' object has no attribute 'get_name'\nError: 'DynamicAttributes' object has no attribute 'missing'\n{}"
      },
      "correct_answer": "A"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "topic": "Async/await syntax and event loops",
      "question": "What is the expected output sequence when running this async code?",
      "code_example": "import asyncio\n\nasync def task1():\n    print(\"Task 1: Started\")\n    await asyncio.sleep(2)\n    print(\"Task 1: Finished after 2 seconds\")\n    return \"Result from Task 1\"\n\nasync def task2():\n    print(\"Task 2: Started\")\n    await asyncio.sleep(1)\n    print(\"Task 2: Finished after 1 second\")\n    return \"Result from Task 2\"\n\nasync def task3(result1, result2):\n    print(f\"Task 3: Started with {result1} and {result2}\")\n    await asyncio.sleep(1.5)\n    print(\"Task 3: Finished after 1.5 seconds\")\n    return \"Final result\"\n\nasync def main():\n    print(\"Main: Started\")\n    \n    # Run tasks concurrently\n    results = await asyncio.gather(\n        task1(),\n        task2()\n    )\n    \n    # Use results in the third task\n    final_result = await task3(results[0], results[1])\n    \n    print(f\"Main: Completed with {final_result}\")\n\nasyncio.run(main())",
      "options": {
        "A": "Main: Started\nTask 1: Started\nTask 2: Started\nTask 2: Finished after 1 second\nTask 1: Finished after 2 seconds\nTask 3: Started with Result from Task 1 and Result from Task 2\nTask 3: Finished after 1.5 seconds\nMain: Completed with Final result",
        "B": "Main: Started\nTask 1: Started\nTask 1: Finished after 2 seconds\nTask 2: Started\nTask 2: Finished after 1 second\nTask 3: Started with Result from Task 1 and Result from Task 2\nTask 3: Finished after 1.5 seconds\nMain: Completed with Final result", 
        "C": "Main: Started\nTask 1: Started\nTask 2: Started\nTask 2: Finished after 1 second\nTask 1: Finished after 2 seconds\nTask 3: Started with Result from Task 1 and Result from Task 2\nMain: Completed with Final result\nTask 3: Finished after 1.5 seconds",
        "D": "Main: Started\nTask 1: Started\nTask 2: Started\nTask 1: Finished after 2 seconds\nTask 2: Finished after 1 second\nTask 3: Started with Result from Task 1 and Result from Task 2\nTask 3: Finished after 1.5 seconds\nMain: Completed with Final result"
      },
      "correct_answer": "A"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "Which statement about Python's NumPy is NOT true?",
      "options": {
        "A": "NumPy arrays are more memory-efficient than Python lists for large numerical data",
        "B": "NumPy operations are usually vectorized, making them faster than equivalent Python loops",
        "C": "NumPy arrays must contain elements of the same type",
        "D": "NumPy uses Python's Global Interpreter Lock for all operations, limiting parallel processing"
      },
      "correct_answer": "D"
    }
]
}
