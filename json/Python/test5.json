{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "numbers = [1, 2, 3, 4, 5]\nprint(numbers[1:4])",
      "options": {
        "A": "[1, 2, 3]",
        "B": "[2, 3, 4]",
        "C": "[1, 2, 3, 4]",
        "D": "[2, 3, 4, 5]"
      },
      "correct_answer": "B"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What is the result of the following operation?",
      "code_example": "a = {1, 2, 3, 4}\nb = {3, 4, 5, 6}\nprint(a.union(b))",
      "options": {
        "A": "{1, 2, 3, 4, 5, 6}",
        "B": "{3, 4}",
        "C": "{1, 2, 5, 6}",
        "D": "{1, 2, 3, 4} + {3, 4, 5, 6}"
      },
      "correct_answer": "A"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "Which of the following is the correct implementation of a factorial function in Python?",
      "options": {
        "A": "def factorial(n):\n    if n == 0:\n        return 0\n    else:\n        return n * factorial(n-1)",
        "B": "def factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n-1)",
        "C": "def factorial(n):\n    if n <= 0:\n        return 0\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result",
        "D": "def factorial(n):\n    result = 0\n    for i in range(n):\n        result *= i\n    return result"
      },
      "correct_answer": "B"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of the following list comprehension?",
      "code_example": "result = [x*x for x in range(5) if x % 2 == 0]\nprint(result)",
      "options": {
        "A": "[0, 4, 16]",
        "B": "[0, 2, 4]",
        "C": "[0, 4]",
        "D": "[0, 1, 4, 9, 16]"
      },
      "correct_answer": "A"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "In the function definition 'def greet(name, message=\"Hello\"):', what is 'message=\"Hello\"'?",
      "options": {
        "A": "A required parameter",
        "B": "A default parameter",
        "C": "A keyword argument",
        "D": "A positional argument"
      },
      "correct_answer": "B"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "text = \"  Python Programming  \"\nprint(text.strip().lower().replace(\"programming\", \"coding\"))",
      "options": {
        "A": "python coding",
        "B": "Python Coding",
        "C": "python programming",
        "D": "  python coding  "
      },
      "correct_answer": "A"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "Which of the following is NOT a primitive type in Python?",
      "options": {
        "A": "int",
        "B": "float",
        "C": "array",
        "D": "bool"
      },
      "correct_answer": "C"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "try:\n    x = int(\"abc\")\nexcept ValueError:\n    print(\"Value error\")\nexcept TypeError:\n    print(\"Type error\")\nelse:\n    print(\"No error\")\nfinally:\n    print(\"Done\")",
      "options": {
        "A": "Value error\nDone",
        "B": "Type error\nDone",
        "C": "No error\nDone",
        "D": "Done"
      },
      "correct_answer": "A"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "Which exception will be raised by the following code?",
      "code_example": "numbers = [1, 2, 3]\nprint(numbers[3])",
      "options": {
        "A": "ValueError",
        "B": "TypeError",
        "C": "IndexError",
        "D": "KeyError"
      },
      "correct_answer": "C"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What is the time complexity of bubble sort in the worst case?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n²)",
        "D": "O(log n)"
      },
      "correct_answer": "C"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "In the file mode 'w+', what does the '+' indicate?",
      "options": {
        "A": "The file is opened for appending",
        "B": "The file is opened for both reading and writing",
        "C": "The file is created if it doesn't exist",
        "D": "The file is opened in binary mode"
      },
      "correct_answer": "B"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "i = 0\nwhile i < 5:\n    i += 1\n    if i == 3:\n        continue\n    print(i, end=' ')",
      "options": {
        "A": "1 2 3 4 5",
        "B": "1 2 4 5",
        "C": "0 1 2 4 5",
        "D": "1 2 3 4"
      },
      "correct_answer": "B"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "x = 10\ndef change_x():\n    global x\n    x = 20\n    print(\"Inside function:\", x)\nchange_x()\nprint(\"Outside function:\", x)",
      "options": {
        "A": "Inside function: 10\nOutside function: 10",
        "B": "Inside function: 20\nOutside function: 10",
        "C": "Inside function: 20\nOutside function: 20",
        "D": "Error: x is not defined"
      },
      "correct_answer": "C"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "Which of the following is the correct way to define a function that takes two arguments and returns their sum?",
      "options": {
        "A": "function add(a, b) { return a + b; }",
        "B": "def add(a, b): return a + b",
        "C": "def add(a, b) { return a + b; }",
        "D": "function add(a, b): return a + b"
      },
      "correct_answer": "B"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "def is_palindrome(text):\n    text = text.lower().replace(\" \", \"\")\n    return text == text[::-1]\nprint(is_palindrome(\"A man a plan a canal Panama\"))",
      "options": {
        "A": "False",
        "B": "True",
        "C": "Error",
        "D": "None"
      },
      "correct_answer": "B"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "code_example": "fruits = [\"apple\", \"banana\", \"cherry\"]\nfruits.append(\"orange\")\nfruits.insert(1, \"grape\")\nfruits.pop(0)\nprint(fruits)",
      "options": {
        "A": "['apple', 'grape', 'banana', 'cherry', 'orange']",
        "B": "['grape', 'banana', 'cherry', 'orange']",
        "C": "['banana', 'cherry', 'orange']",
        "D": "['apple', 'grape', 'banana', 'cherry']"
      },
      "correct_answer": "B"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "In a Flask application, which of the following correctly defines a route for handling POST requests only?",
      "options": {
        "A": "@app.route('/submit', methods=['POST'])",
        "B": "@app.route('/submit', method='POST')",
        "C": "@app.post('/submit')",
        "D": "@app.request('/submit', type='POST')"
      },
      "correct_answer": "A"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        \n    def greet(self):\n        return f\"Hello, my name is {self.name}\"\n\np = Person(\"Alice\", 30)\nprint(p.greet())",
      "options": {
        "A": "Hello, my name is Person",
        "B": "Hello, my name is Alice",
        "C": "{'name': 'Alice', 'age': 30}",
        "D": "Error: self is not defined"
      },
      "correct_answer": "B"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "Which of the following is the correct way to import a function 'calc' from a module 'math_utils' in a package 'utils'?",
      "options": {
        "A": "import utils.math_utils.calc",
        "B": "from utils import math_utils.calc",
        "C": "from utils.math_utils import calc",
        "D": "import calc from utils.math_utils"
      },
      "correct_answer": "C"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "In Django, what is the primary purpose of a model?",
      "options": {
        "A": "To handle HTTP requests",
        "B": "To define the structure of a database table",
        "C": "To render HTML templates",
        "D": "To validate form data"
      },
      "correct_answer": "B"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "Which of the following regex operations is typically the most computationally expensive?",
      "options": {
        "A": "Simple string matching (e.g., 'abc')",
        "B": "Character classes (e.g., '[a-z]')",
        "C": "Backtracking with nested repetition (e.g., '(a+)+b')",
        "D": "Alternation (e.g., 'a|b|c')"
      },
      "correct_answer": "C"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "from itertools import islice\n\ndef fibonacci():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nfib = fibonacci()\nprint(list(islice(fib, 6)))",
      "options": {
        "A": "[0, 1, 1, 2, 3, 5]",
        "B": "[1, 1, 2, 3, 5, 8]",
        "C": "[0, 1, 1, 2, 3]",
        "D": "[0, 1, 2, 3, 4, 5]"
      },
      "correct_answer": "A"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "class Animal:\n    def speak(self):\n        return \"Animal speaks\"\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Dog barks\"\n\nclass Labrador(Dog):\n    pass\n\npet = Labrador()\nprint(pet.speak())",
      "options": {
        "A": "Animal speaks",
        "B": "Dog barks",
        "C": "Labrador speaks",
        "D": "Error: Labrador has no speak method"
      },
      "correct_answer": "B"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What is the result of the following sliding window algorithm implementation?",
      "code_example": "def max_subarray_sum(arr, k):\n    n = len(arr)\n    if n < k:\n        return None\n    \n    window_sum = sum(arr[:k])\n    max_sum = window_sum\n    \n    for i in range(n - k):\n        window_sum = window_sum - arr[i] + arr[i + k]\n        max_sum = max(max_sum, window_sum)\n    \n    return max_sum\n\nprint(max_subarray_sum([1, 4, 2, 10, 2, 3, 1, 0, 20], 3))",
      "options": {
        "A": "15",
        "B": "16",
        "C": "21",
        "D": "24"
      },
      "correct_answer": "A"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What will be the output of the following depth-first search implementation?",
      "code_example": "def dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    print(start, end=' ')\n    \n    for neighbor in sorted(graph[start]):\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\ndfs(graph, 'A')",
      "options": {
        "A": "A B C D E F",
        "B": "A B D E F C",
        "C": "A C F E B D",
        "D": "A B D E C F"
      },
      "correct_answer": "B"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What will be the output of the following stack implementation?",
      "code_example": "class Stack:\n    def __init__(self):\n        self.items = []\n    \n    def push(self, item):\n        self.items.append(item)\n    \n    def pop(self):\n        if not self.is_empty():\n            return self.items.pop()\n    \n    def peek(self):\n        if not self.is_empty():\n            return self.items[-1]\n    \n    def is_empty(self):\n        return len(self.items) == 0\n\ns = Stack()\ns.push(1)\ns.push(2)\ns.push(3)\nprint(s.pop())\nprint(s.peek())\ns.push(4)\nprint(s.pop())",
      "options": {
        "A": "3\n2\n4",
        "B": "1\n2\n3",
        "C": "3\n1\n4",
        "D": "1\n2\n4"
      },
      "correct_answer": "A"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "In SQLAlchemy, which of the following correctly defines a one-to-many relationship between 'User' and 'Post' models?",
      "options": {
        "A": "Post.user = relationship('User', backref='posts')",
        "B": "User.posts = relationship('Post', uselist=True)",
        "C": "User.posts = relationship('Post', backref='user')",
        "D": "Post.user = relationship('User', foreignkeys=User.id)"
      },
      "correct_answer": "C"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "Which of the following is a secure method for API authentication?",
      "options": {
        "A": "Sending username and password in plain text",
        "B": "Using API keys in URL parameters",
        "C": "Using JWT tokens with HTTPS",
        "D": "Storing authentication tokens in client-side cookies without secure flag"
      },
      "correct_answer": "C"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What is the difference between the following two expressions?",
      "code_example": "# Expression 1\nlist_comp = [x*x for x in range(1000000)]\n\n# Expression 2\ngen_exp = (x*x for x in range(1000000))",
      "options": {
        "A": "There is no difference; both create a list of squares",
        "B": "The generator expression is more efficient as it generates values on demand",
        "C": "The list comprehension is faster for lookups and random access",
        "D": "The generator expression can be used multiple times, the list comprehension cannot"
      },
      "correct_answer": "B"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "Which HTTP status code indicates that a resource has been successfully created?",
      "options": {
        "A": "200 OK",
        "B": "201 Created",
        "C": "204 No Content",
        "D": "302 Found"
      },
      "correct_answer": "B"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "What is the time complexity of the merge sort algorithm in the average case?",
      "options": {
        "A": "O(n)",
        "B": "O(n log n)",
        "C": "O(n²)",
        "D": "O(log n)"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "code_example": "from collections import Counter, defaultdict, OrderedDict\n\nwords = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']\ncount = Counter(words)\nprint(count.most_common(1)[0][0])",
      "options": {
        "A": "{'apple': 3}",
        "B": "('apple', 3)",
        "C": "apple",
        "D": "3"
      },
      "correct_answer": "C"
    },
{
      "id": 33,
      "difficulty": "hard",
      "topic": "Metaclasses",
      "question": "What will be the output of the following code?",
      "code_example": "class Meta(type):\n    def __new__(cls, name, bases, attrs):\n        attrs['x'] = 10\n        return super().__new__(cls, name, bases, attrs)\n\nclass MyClass(metaclass=Meta):\n    x = 5\n\nobj = MyClass()\nprint(obj.x)",
      "options": {
        "A": "5",
        "B": "10",
        "C": "15",
        "D": "AttributeError: 'MyClass' object has no attribute 'x'"
      },
      "correct_answer": "B"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "topic": "NumPy for numerical computing",
      "question": "What will be the output of the following NumPy code?",
      "code_example": "import numpy as np\n\narr = np.array([[1, 2, 3], [4, 5, 6]])\nmask = arr > 2\n\nresult = np.where(mask, arr * 2, -1)\nprint(result.sum())",
      "options": {
        "A": "21",
        "B": "24",
        "C": "28",
        "D": "32"
      },
      "correct_answer": "C"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "topic": "Memoization vs tabulation",
      "question": "What will be the output of the following code that uses memoization to calculate the nth Fibonacci number?",
      "code_example": "def fibonacci(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n    return memo[n]\n\nprint(fibonacci(6))\nprint(fibonacci(3))",
      "options": {
        "A": "8, 2",
        "B": "8, 3",
        "C": "13, 2",
        "D": "13, 3"
      },
      "correct_answer": "A"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "topic": "Backtracking algorithms",
      "question": "What will be the output of the following backtracking algorithm that finds all possible ways to place N queens on an NxN chessboard?",
      "code_example": "def is_safe(board, row, col, n):\n    # Check if no queen can attack this position\n    # Check the row\n    for i in range(col):\n        if board[row][i] == 1:\n            return False\n    \n    # Check upper diagonal\n    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    \n    # Check lower diagonal\n    for i, j in zip(range(row, n), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    \n    return True\n\ndef solve_n_queens(n):\n    # Initialize the board\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    solutions = []\n    \n    def solve(col):\n        if col >= n:\n            # Found a solution\n            solution = []\n            for i in range(n):\n                row_str = ''\n                for j in range(n):\n                    row_str += 'Q' if board[i][j] == 1 else '.'\n                solution.append(row_str)\n            solutions.append(solution)\n            return True\n        \n        res = False\n        for row in range(n):\n            if is_safe(board, row, col, n):\n                board[row][col] = 1\n                \n                res = solve(col + 1) or res\n                \n                # Backtrack\n                board[row][col] = 0\n        \n        return res\n    \n    solve(0)\n    return len(solutions)\n\nprint(solve_n_queens(4))",
      "options": {
        "A": "1",
        "B": "2",
        "C": "4",
        "D": "92"
      },
      "correct_answer": "B"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "topic": "Scrapy framework",
      "question": "What is the correct way to extract all href links from a Scrapy response that match a specific pattern?",
      "code_example": "import scrapy\n\nclass MySpider(scrapy.Spider):\n    name = 'link_extractor'\n    start_urls = ['http://example.com']\n    \n    def parse(self, response):\n        # Extract links that contain 'product' in the URL\n        product_links = response.css('a[href*=product]::attr(href)').getall()\n        return {'product_links': product_links}",
      "options": {
        "A": "response.xpath('//a[contains(@href, \"product\")]/@href').extract()",
        "B": "response.css('a::attr(href)[contains(., \"product\")]').getall()",
        "C": "response.css('a[href*=product]::attr(href)').getall()",
        "D": "response.xpath('//a/@href[contains(., \"product\")]').getall()"
      },
      "correct_answer": "C"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "topic": "Race conditions and deadlocks",
      "question": "Which of the following accurately describes a potential deadlock in this code?",
      "code_example": "import threading\n\nlock_a = threading.Lock()\nlock_b = threading.Lock()\n\ndef thread_1():\n    with lock_a:\n        # Do something\n        with lock_b:\n            print(\"Thread 1 has both locks\")\n\ndef thread_2():\n    with lock_b:\n        # Do something\n        with lock_a:\n            print(\"Thread 2 has both locks\")\n\n# Create and start threads\nt1 = threading.Thread(target=thread_1)\nt2 = threading.Thread(target=thread_2)\nt1.start()\nt2.start()",
      "options": {
        "A": "A deadlock will always occur because thread_1 and thread_2 use locks in different orders",
        "B": "A deadlock will never occur because the with statement automatically releases locks",
        "C": "A deadlock may occur if thread_1 acquires lock_a and thread_2 acquires lock_b before either can acquire the second lock",
        "D": "A deadlock cannot occur because Python's GIL prevents true concurrent execution"
      },
      "correct_answer": "C"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "topic": "Scikit-learn basics",
      "question": "What will be the output of the following code using scikit-learn's train_test_split function?",
      "code_example": "import numpy as np\nfrom sklearn.model_selection import train_test_split\n\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\ny = np.array([0, 1, 0, 1])\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.5, random_state=42)\n\nprint(f\"X_train shape: {X_train.shape}, X_test shape: {X_test.shape}\")",
      "options": {
        "A": "X_train shape: (2, 2), X_test shape: (2, 2)",
        "B": "X_train shape: (3, 2), X_test shape: (1, 2)",
        "C": "X_train shape: (4, 1), X_test shape: (4, 1)",
        "D": "X_train shape: (2, 2), X_test shape: (4, 2)"
      },
      "correct_answer": "A"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "topic": "Asynchronous web frameworks (FastAPI)",
      "question": "Which of the following statements about FastAPI is incorrect?",
      "options": {
        "A": "FastAPI automatically generates OpenAPI documentation for your API",
        "B": "FastAPI uses Python type hints for request validation and serialization",
        "C": "FastAPI requires explicit async/await syntax for all endpoint handlers",
        "D": "FastAPI is built on top of Starlette and Pydantic"
      },
      "correct_answer": "C"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "topic": "Just-in-time compilation (PyPy)",
      "question": "What will be the output when the following code is executed using PyPy?",
      "code_example": "import time\n\ndef compute_sum():\n    start_time = time.time()\n    total = 0\n    for i in range(10**7):\n        total += i\n    end_time = time.time()\n    return total, end_time - start_time\n\n# First run\nresult1, time1 = compute_sum()\n\n# Second run\nresult2, time2 = compute_sum()\n\nprint(f\"Time difference ratio (first run / second run): {time1/time2:.1f}\")",
      "options": {
        "A": "Time difference ratio (first run / second run): 1.0",
        "B": "Time difference ratio (first run / second run): approximately 1.5 to 3.0",
        "C": "Time difference ratio (first run / second run): approximately 4.0 to 10.0",
        "D": "Will vary greatly depending on the system"
      },
      "correct_answer": "C"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "topic": "Dependency injection",
      "question": "Consider the following code implementing dependency injection in Python. What is the primary advantage of this approach compared to directly instantiating dependencies?",
      "code_example": "class DatabaseConnection:\n    def __init__(self, connection_string):\n        self.connection_string = connection_string\n        \n    def query(self, sql):\n        # Implementation\n        return f\"Results for {sql}\"\n\nclass UserRepository:\n    def __init__(self, db_connection):\n        self.db = db_connection\n        \n    def get_user(self, user_id):\n        return self.db.query(f\"SELECT * FROM users WHERE id = {user_id}\")\n\nclass UserService:\n    def __init__(self, user_repository):\n        self.repository = user_repository\n        \n    def get_user_data(self, user_id):\n        return self.repository.get_user(user_id)\n\n# Usage\ndb = DatabaseConnection(\"postgresql://localhost/mydb\")\nuser_repo = UserRepository(db)\nuser_service = UserService(user_repo)\n\nprint(user_service.get_user_data(42))",
      "options": {
        "A": "It makes code execution faster by reducing function call overhead",
        "B": "It simplifies testing by allowing dependencies to be mocked or replaced",
        "C": "It reduces memory usage by sharing singleton instances",
        "D": "It eliminates circular import problems in Python modules"
      },
      "correct_answer": "B"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "topic": "Approximation algorithms",
      "question": "Which of the following best describes the time complexity of this greedy approximation algorithm for the set cover problem?",
      "code_example": "def greedy_set_cover(universe, subsets):\n    \"\"\"Greedy approximation algorithm for set cover problem.\n    \n    Args:\n        universe: Set of elements that need to be covered\n        subsets: List of available sets to choose from\n        \n    Returns:\n        List of chosen subsets that cover the universe\n    \"\"\"\n    elements_remaining = set(universe)\n    subsets_chosen = []\n    \n    while elements_remaining:\n        # Find the subset that covers the most uncovered elements\n        best_subset = None\n        max_covered = 0\n        \n        for subset in subsets:\n            covered = len(elements_remaining.intersection(subset))\n            if covered > max_covered:\n                max_covered = covered\n                best_subset = subset\n        \n        if max_covered == 0:\n            break  # No subset covers any remaining element\n            \n        # Add the best subset to our solution\n        subsets_chosen.append(best_subset)\n        # Remove the covered elements\n        elements_remaining -= set(best_subset)\n    \n    return subsets_chosen",
      "options": {
        "A": "O(n log n) where n is the size of the universe",
        "B": "O(n * m) where n is the number of subsets and m is the size of the universe",
        "C": "O(n²) where n is the sum of the sizes of all subsets",
        "D": "O(n * m²) where n is the number of subsets and m is the size of the universe"
      },
      "correct_answer": "B"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "topic": "WebSockets implementation",
      "question": "Which of the following correctly describes how to handle WebSocket connections in an asynchronous Python server?",
      "options": {
        "A": "WebSockets maintain a persistent TCP connection but still require headers and cookies with each message",
        "B": "WebSockets cannot transmit binary data and must use JSON for all communication",
        "C": "WebSockets require explicit heartbeat messages to maintain the connection",
        "D": "WebSockets use an HTTP handshake to establish the initial connection before switching protocols"
      },
      "correct_answer": "D"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "topic": "Query optimization",
      "question": "What will be the output of the following code that demonstrates query optimization using SQLAlchemy?",
      "code_example": "from sqlalchemy import create_engine, Column, Integer, String, func, select\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\n# Setup (assuming this works)\nBase = declarative_base()\nengine = create_engine('sqlite:///:memory:')\nSession = sessionmaker(bind=engine)\n\nclass User(Base):\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    age = Column(Integer)\n\n# Create tables and add sample data\nBase.metadata.create_all(engine)\nsession = Session()\n\n# Add sample data\nusers = [\n    User(name='Alice', age=30),\n    User(name='Bob', age=25),\n    User(name='Charlie', age=35),\n    User(name='Dave', age=25)\n]\nsession.add_all(users)\nsession.commit()\n\n# Query 1: Regular ORM query\nq1 = session.query(User).filter(User.age == 25).all()\n\n# Query 2: Optimized query using only necessary columns\nq2 = session.query(User.name).filter(User.age == 25).all()\n\n# Query 3: Aggregation directly in the database\nq3 = session.query(func.count(User.id)).filter(User.age == 25).scalar()\n\nprint(f\"Query 1 returns {len(q1)} full User objects\")\nprint(f\"Query 2 returns {len(q2)} name-only tuples\")\nprint(f\"Query 3 returns {q3} as a count\")",
      "options": {
        "A": "Query 1 returns 2 full User objects\nQuery 2 returns 2 name-only tuples\nQuery 3 returns 2 as a count",
        "B": "Query 1 returns 2 full User objects\nQuery 2 returns 2 name-only tuples\nQuery 3 returns 1 as a count",
        "C": "Query 1 returns 2 full User objects\nQuery 2 returns ('Bob',) and ('Dave',) tuples\nQuery 3 returns 2 as a count",
        "D": "Query 1 returns 1 full User objects\nQuery 2 returns 2 name-only tuples\nQuery 3 returns 2 as a count"
      },
      "correct_answer": "A"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "topic": "Overlapping subproblems identification",
      "question": "Which of the following problems is best suited for dynamic programming due to having optimal substructure and overlapping subproblems?",
      "options": {
        "A": "Finding the maximum element in an unsorted array",
        "B": "Determining if a number is prime",
        "C": "Computing the nth Fibonacci number",
        "D": "Sorting an array using quicksort"
      },
      "correct_answer": "C"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "topic": "Container orchestration basics (Kubernetes)",
      "question": "Which of the following statements about Kubernetes in relation to Python applications is correct?",
      "options": {
        "A": "Kubernetes pods can only contain one container, so Python microservices must be deployed separately",
        "B": "Kubernetes requires Python applications to use a specific web framework like Django or Flask",
        "C": "Kubernetes can automatically scale Python applications based on CPU or memory usage",
        "D": "Kubernetes can only deploy Python applications that use asynchronous programming"
      },
      "correct_answer": "C"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "topic": "Message queues (RabbitMQ, Kafka)",
      "question": "What is the output of the following code using Pika to interact with RabbitMQ?",
      "code_example": "import pika\nimport uuid\nimport threading\nimport time\n\nclass FibonacciRpcClient:\n    def __init__(self):\n        # Setup connection\n        self.connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\n        self.channel = self.connection.channel()\n\n        # Create callback queue\n        result = self.channel.queue_declare(queue='', exclusive=True)\n        self.callback_queue = result.method.queue\n\n        self.channel.basic_consume(\n            queue=self.callback_queue,\n            on_message_callback=self.on_response,\n            auto_ack=True)\n        \n        self.response = None\n        self.corr_id = None\n\n    def on_response(self, ch, method, props, body):\n        if self.corr_id == props.correlation_id:\n            self.response = int(body)\n\n    def call(self, n):\n        self.response = None\n        self.corr_id = str(uuid.uuid4())\n        self.channel.basic_publish(\n            exchange='',\n            routing_key='rpc_queue',\n            properties=pika.BasicProperties(\n                reply_to=self.callback_queue,\n                correlation_id=self.corr_id,\n            ),\n            body=str(n))\n        \n        # Simulate RPC response (in a real scenario, the server would process and respond)\n        # For this test example, we're simulating the server side as well\n        def simulate_server_response():\n            time.sleep(0.1)  # Simulate processing time\n            # Calculate Fibonacci (this would happen on the server)\n            def fib(n):\n                if n == 0 or n == 1:\n                    return n\n                else:\n                    return fib(n-1) + fib(n-2)\n            \n            # Simulate server sending response back\n            self.response = fib(n)\n        \n        # Start the simulation in a separate thread\n        threading.Thread(target=simulate_server_response).start()\n        \n        # Wait for the response\n        while self.response is None:\n            self.connection.process_data_events()\n        return self.response\n\n# Create client and call\nfibonacci_rpc = FibonacciRpcClient()\nprint(f\"Requesting fib(6)\")\nresponse = fibonacci_rpc.call(6)\nprint(f\"Got {response}\")",
      "options": {
        "A": "Requesting fib(6)\nGot 6",
        "B": "Requesting fib(6)\nGot 8",
        "C": "Requesting fib(6)\nGot 13",
        "D": "Requesting fib(6)\nTimeout error: no response received"
      },
      "correct_answer": "B"
    }
  ]
}
