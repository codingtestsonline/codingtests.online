{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "topic": "Converting number bases",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "42",
        "B": "0o52",
        "C": "0x2a",
        "D": "0b101010"
      },
      "correct_answer": "D",
      "code_example": "decimal_num = 42\nprint(bin(decimal_num))"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "topic": "Default parameters and return values",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "Hello World",
        "B": "Hello Python",
        "C": "Hello ",
        "D": "TypeError: greet() missing required argument"
      },
      "correct_answer": "B",
      "code_example": "def greet(name=\"Python\"):\n    return f\"Hello {name}\"\n\nprint(greet())"
    },
    {
      "id": 3,
      "difficulty": "easy",
      "topic": "GCD and LCM calculations",
      "question": "What is the least common multiple (LCM) of 12 and 18?",
      "options": {
        "A": "6",
        "B": "12",
        "C": "36",
        "D": "216"
      },
      "correct_answer": "C"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "topic": "Lists: creation, access, methods",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "[1, 2, 3, 4, 5]",
        "B": "[1, 2, 99, 3, 4, 5]",
        "C": "[1, 2, 99, 4, 5]",
        "D": "[1, 2, 99, 3, 5]"
      },
      "correct_answer": "B",
      "code_example": "numbers = [1, 2, 3, 4, 5]\nnumbers.insert(2, 99)\nprint(numbers)"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "topic": "String reversal and manipulation",
      "question": "Which of the following is the correct way to reverse a string in Python?",
      "options": {
        "A": "my_string.reverse()",
        "B": "reverse(my_string)",
        "C": "my_string[::-1]",
        "D": "reversed(my_string)"
      },
      "correct_answer": "C"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "topic": "Constants and naming conventions",
      "question": "According to PEP 8, which of the following is the correct naming convention for a constant in Python?",
      "options": {
        "A": "MAX_SIZE",
        "B": "maxSize",
        "C": "max_size",
        "D": "MaxSize"
      },
      "correct_answer": "A"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "topic": "String slicing and indexing",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "Python",
        "B": "ytho",
        "C": "Pyth",
        "D": "thon"
      },
      "correct_answer": "B",
      "code_example": "text = \"Python\"\nprint(text[1:5])"
    },
    {
      "id": 8,
      "difficulty": "easy",
      "topic": "Pass, else clauses in loops",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "No numbers found",
        "B": "Done processing",
        "C": "No output will be generated",
        "D": "Both 'No numbers found' and 'Done processing'"
      },
      "correct_answer": "A",
      "code_example": "numbers = []\nfor num in numbers:\n    print(num)\nelse:\n    print(\"No numbers found\")"
    },
    {
      "id": 9,
      "difficulty": "easy",
      "topic": "Sets: methods",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "{1, 2, 3, 4, 5, 6}",
        "B": "{3, 4}",
        "C": "{1, 2, 5, 6}",
        "D": "{1, 2, 3, 4}"
      },
      "correct_answer": "B",
      "code_example": "set1 = {1, 2, 3, 4}\nset2 = {3, 4, 5, 6}\nprint(set1.intersection(set2))"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "topic": "Tuples: immutability, packing/unpacking",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "Alice 25",
        "B": "('Alice', 25)",
        "C": "TypeError: 'tuple' object does not support item assignment",
        "D": "SyntaxError: can't assign to literal"
      },
      "correct_answer": "C",
      "code_example": "person = ('Alice', 25)\nperson[1] = 26\nprint(person)"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "topic": "Type conversion and checking",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "True True",
        "B": "True False",
        "C": "False True",
        "D": "False False"
      },
      "correct_answer": "B",
      "code_example": "number = 42\nprint(isinstance(number, int), isinstance(number, float))"
    },
    {
      "id": 12,
      "difficulty": "easy",
      "topic": "Function definition and calling",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "10 5",
        "B": "5 10",
        "C": "5 5",
        "D": "10 10"
      },
      "correct_answer": "A",
      "code_example": "def swap(a, b):\n    temp = a\n    a = b\n    b = temp\n    return a, b\n\nx = 5\ny = 10\nnew_x, new_y = swap(x, y)\nprint(new_y, new_x)"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "topic": "Handling multiple exceptions",
      "question": "What will happen when the following code is executed?",
      "options": {
        "A": "It will print 'Division by zero!'",
        "B": "It will print 'An error occurred: division by zero'",
        "C": "It will print 'This will always execute.'",
        "D": "It will print 'An error occurred: division by zero' followed by 'This will always execute.'"
      },
      "correct_answer": "D",
      "code_example": "try:\n    result = 10 / 0\nexcept ZeroDivisionError as e:\n    print(f\"An error occurred: {e}\")\nfinally:\n    print(\"This will always execute.\")"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "topic": "String methods",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "['apple', 'banana', 'cherry']",
        "B": "['apple', ' banana', ' cherry']",
        "C": "['apple', 'banana', 'cherry', '']",
        "D": "['', 'apple', 'banana', 'cherry']"
      },
      "correct_answer": "A",
      "code_example": "fruits = \"apple,banana,cherry\"\nfruit_list = fruits.split(\",\")\nprint(fruit_list)"
    },
    {
      "id": 15,
      "difficulty": "easy",
      "topic": "Linear search implementation",
      "question": "What is the time complexity of the following linear search implementation?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n²)"
      },
      "correct_answer": "C",
      "code_example": "def linear_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "topic": "Parameters vs arguments",
      "question": "In the context of Python functions, which statement is correct?",
      "options": {
        "A": "Parameters are defined in function calls, while arguments are defined in function definitions",
        "B": "Parameters are defined in function definitions, while arguments are passed in function calls",
        "C": "Parameters and arguments are different names for the same concept",
        "D": "Arguments are only used with keyword parameters, not positional parameters"
      },
      "correct_answer": "B"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "topic": "Django basics",
      "question": "In a Django project, what is the purpose of the 'views.py' file?",
      "options": {
        "A": "To define the database schema",
        "B": "To handle HTTP requests and return HTTP responses",
        "C": "To define URL patterns for the application",
        "D": "To manage static files like CSS and JavaScript"
      },
      "correct_answer": "B"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "topic": "Divide and conquer",
      "question": "Which of the following algorithms is NOT typically implemented using the divide and conquer approach?",
      "options": {
        "A": "Merge Sort",
        "B": "Quick Sort",
        "C": "Bubble Sort",
        "D": "Binary Search"
      },
      "correct_answer": "C"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "topic": "Simple API endpoints",
      "question": "Which HTTP method is most appropriate for retrieving data from an API endpoint without modifying any resources?",
      "options": {
        "A": "POST",
        "B": "PUT",
        "C": "DELETE",
        "D": "GET"
      },
      "correct_answer": "D"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "topic": "Absolute vs relative imports",
      "question": "Given the following directory structure, what is the correct way to import the 'helpers' module from within 'views.py'?",
      "options": {
        "A": "import app.utils.helpers",
        "B": "import .utils.helpers",
        "C": "from ..utils import helpers",
        "D": "from app.utils import helpers"
      },
      "correct_answer": "D",
      "code_example": "# Directory structure:\n# myproject/\n#   ├── app/\n#   │   ├── __init__.py\n#   │   ├── views.py\n#   │   └── utils/\n#   │       ├── __init__.py\n#   │       └── helpers.py"
    },
    {
      "id": 21,
      "difficulty": "medium",
      "topic": "Binary search variations",
      "question": "What will be the output of the following binary search implementation when searching for the value 7 in the given sorted array?",
      "options": {
        "A": "2",
        "B": "3",
        "C": "-1",
        "D": "IndexError"
      },
      "correct_answer": "B",
      "code_example": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\narr = [1, 3, 5, 7, 9, 11]\nprint(binary_search(arr, 7))"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "topic": "Dictionary and set comprehensions",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "{1: 1, 2: 4, 3: 9, 4: 16}",
        "B": "{1: 1, 2: 8, 3: 27, 4: 64}",
        "C": "{1: 'odd', 2: 'even', 3: 'odd', 4: 'even'}",
        "D": "{1: True, 2: False, 3: True, 4: False}"
      },
      "correct_answer": "C",
      "code_example": "numbers = [1, 2, 3, 4]\nresult = {num: 'odd' if num % 2 else 'even' for num in numbers}\nprint(result)"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "topic": "CRUD operations",
      "question": "In the context of database operations, what does the 'U' in CRUD stand for?",
      "options": {
        "A": "Unify",
        "B": "Utilize",
        "C": "Update",
        "D": "Upgrade"
      },
      "correct_answer": "C"
    },
    {
      "id": 24,
      "difficulty": "medium",
      "topic": "Partial functions and currying",
      "question": "What will be the output of the following code using partial functions?",
      "options": {
        "A": "15",
        "B": "25",
        "C": "35",
        "D": "TypeError"
      },
      "correct_answer": "A",
      "code_example": "from functools import partial\n\ndef multiply(x, y):\n    return x * y\n\ndouble = partial(multiply, 3)\nprint(double(5))"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "topic": "Closures and scopes",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "10 20",
        "B": "20 20",
        "C": "10 10",
        "D": "20 10"
      },
      "correct_answer": "B",
      "code_example": "def outer_function():\n    x = 10\n    \n    def inner_function():\n        nonlocal x\n        x = 20\n        print(x, end=' ')\n    \n    inner_function()\n    print(x)\n\nouter_function()"
    },
    {
      "id": 26,
      "difficulty": "medium",
      "topic": "Recursion with memoization",
      "question": "What is the purpose of memoization in recursive functions?",
      "options": {
        "A": "To eliminate the need for base cases",
        "B": "To convert recursion to iteration",
        "C": "To avoid redundant calculations by caching results",
        "D": "To limit the maximum recursion depth"
      },
      "correct_answer": "C"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "topic": "Linked lists",
      "question": "What will be the output of the following code that implements a singly linked list?",
      "options": {
        "A": "10 -> 20 -> 30 -> None",
        "B": "10 -> 20 -> None",
        "C": "20 -> 30 -> None",
        "D": "30 -> 20 -> 10 -> None"
      },
      "correct_answer": "A",
      "code_example": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n    \n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        \n        current = self.head\n        while current.next:\n            current = current.next\n        current.next = new_node\n    \n    def __str__(self):\n        result = \"\"\n        current = self.head\n        while current:\n            result += str(current.data) + \" -> \"\n            current = current.next\n        result += \"None\"\n        return result\n\nlinked_list = LinkedList()\nlinked_list.append(10)\nlinked_list.append(20)\nlinked_list.append(30)\nprint(linked_list)"
    },
    {
      "id": 28,
      "difficulty": "medium",
      "topic": "Basic hash table implementation",
      "question": "What is the time complexity of inserting an element into a hash table with chaining for collision resolution in the average case?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n log n)"
      },
      "correct_answer": "A"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "topic": "Priority queue using heapq",
      "question": "What will be the output of the following code using heapq?",
      "options": {
        "A": "[1, 3, 5, 10, 8]",
        "B": "[1, 3, 5, 8, 10]",
        "C": "[10, 8, 5, 3, 1]",
        "D": "[1, 3, 5]"
      },
      "correct_answer": "D",
      "code_example": "import heapq\n\nheap = [5, 3, 10, 1, 8]\nheapq.heapify(heap)\n\nresult = []\nfor _ in range(3):\n    result.append(heapq.heappop(heap))\n\nprint(result)"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "topic": "Creating generator functions with yield",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "[0, 2, 4, 6, 8]",
        "B": "[0, 1, 2, 3, 4]",
        "C": "TypeError: 'generator' object is not subscriptable",
        "D": "0 2 4 6 8"
      },
      "correct_answer": "D",
      "code_example": "def even_numbers(n):\n    for i in range(n):\n        if i % 2 == 0:\n            yield i\n\ngen = even_numbers(10)\nfor num in gen:\n    print(num, end=' ')"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "topic": "Hash-based searching",
      "question": "What is the primary advantage of hash-based searching over binary search?",
      "options": {
        "A": "Hash-based searching always has a stable worst-case time complexity",
        "B": "Hash-based searching can work on unsorted data",
        "C": "Hash-based searching requires less memory",
        "D": "Hash-based searching is always faster regardless of data size"
      },
      "correct_answer": "B"
    },
    {
      "id": 32,
      "difficulty": "medium",
      "topic": "Basic ORM concepts",
      "question": "In SQLAlchemy ORM, what is the relationship between a Python class and a database table?",
      "options": {
        "A": "A Python class instance represents a database table",
        "B": "A Python class represents a database table, and instances represent rows",
        "C": "A Python class represents a database column",
        "D": "A Python class represents a database query"
      },
      "correct_answer": "B"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "Consider the following Python code using descriptors. What will be the output when we execute the code below?",
      "options": {
        "A": "Values: 50, 20, 30",
        "B": "Values: 50, 20, Error: Value cannot be negative",
        "C": "Values: 50, Error: Value cannot be negative, 30",
        "D": "Values: Error: Max value exceeded, 20, 30"
      },
      "correct_answer": "B",
      "code_example": "class RangeValidator:\n    def __init__(self, min_value=0, max_value=100):\n        self.min_value = min_value\n        self.max_value = max_value\n        \n    def __set_name__(self, owner, name):\n        self.name = f'_{name}'\n        \n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        return getattr(instance, self.name, None)\n    \n    def __set__(self, instance, value):\n        if value < self.min_value:\n            raise ValueError(f'Value cannot be negative')\n        if value > self.max_value:\n            raise ValueError(f'Max value exceeded')\n        setattr(instance, self.name, value)\n\nclass DataPoint:\n    x = RangeValidator(0, 100)\n    y = RangeValidator(0, 50)\n    z = RangeValidator(0, 100)\n    \n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\nresult = []\ntry:\n    point = DataPoint(50, 20, 30)\n    result.append(f'Values: {point.x}, {point.y}, {point.z}')\nexcept ValueError as e:\n    result.append(f'Values: Error: {e}')\n\ntry:\n    point = DataPoint(50, -10, 30)\n    result.append(f'Values: {point.x}, {point.y}, {point.z}')\nexcept ValueError as e:\n    result.append(f'Values: {point.x}, Error: {e}')\n\nprint(result[0])"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "What is the time complexity for inserting a node into a Red-Black tree?",
      "options": {
        "A": "O(1)",
        "B": "O(log n)",
        "C": "O(n)",
        "D": "O(n log n)"
      },
      "correct_answer": "B"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "Given the following code using FastAPI, what will be the behavior of this endpoint when it receives a request with an invalid token?",
      "options": {
        "A": "It will return a 401 Unauthorized response",
        "B": "It will return a 403 Forbidden response",
        "C": "It will return a 500 Internal Server Error",
        "D": "It will process the request normally but with an empty user_id"
      },
      "correct_answer": "A",
      "code_example": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nimport jwt\nfrom typing import Optional\n\napp = FastAPI()\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nSECRET_KEY = \"your_secret_key\"\nALGORITHM = \"HS256\"\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        user_id: str = payload.get(\"sub\")\n        if user_id is None:\n            raise credentials_exception\n    except jwt.PyJWTError:\n        raise credentials_exception\n    return {\"user_id\": user_id}\n\n@app.get(\"/protected-resource/\")\nasync def protected_resource(current_user: dict = Depends(get_current_user)):\n    return {\"message\": f\"Hello {current_user['user_id']}\"}"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "When implementing a CI/CD pipeline for a Python project using GitHub Actions, which of the following strategies is best for managing secrets such as database credentials?",
      "options": {
        "A": "Store them directly in the workflow YAML file for easy access",
        "B": "Add them to a config.py file in the repository and import as needed",
        "C": "Use GitHub's repository secrets and access them via environment variables",
        "D": "Hardcode them in the application code for better performance"
      },
      "correct_answer": "C"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "Consider the following Python code using scikit-learn. What will be the output of the final print statement?",
      "options": {
        "A": "[1 0 1]",
        "B": "[0 1 0]",
        "C": "[1 1 0]",
        "D": "[1 0 0]"
      },
      "correct_answer": "C",
      "code_example": "import numpy as np\nfrom sklearn.tree import DecisionTreeClassifier\n\n# Create a simple dataset\nX = np.array([[0, 0], [1, 1], [1, 0]])\ny = np.array([0, 1, 1])\n\n# Train a decision tree with max_depth=1\nclf = DecisionTreeClassifier(max_depth=1, random_state=42)\nclf.fit(X, y)\n\n# Make predictions\npredictions = clf.predict(X)\nprint(predictions)"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "In a distributed system using RabbitMQ, what will happen if a consumer processes a message but crashes before it can acknowledge the message?",
      "options": {
        "A": "The message is permanently lost",
        "B": "The message is automatically requeued and will be delivered to another consumer",
        "C": "The message remains in the queue but will never be delivered again",
        "D": "The message is moved to a dead-letter queue automatically"
      },
      "correct_answer": "B"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "What will the following Python code using topological sorting output?",
      "options": {
        "A": "['C', 'A', 'B', 'D']",
        "B": "['A', 'C', 'B', 'D']",
        "C": "['A', 'B', 'C', 'D']",
        "D": "['C', 'A', 'D', 'B']"
      },
      "correct_answer": "A",
      "code_example": "from collections import defaultdict, deque\n\ndef topological_sort(graph):\n    # Count incoming edges for each vertex\n    in_degree = {u: 0 for u in graph}\n    for u in graph:\n        for v in graph[u]:\n            in_degree[v] += 1\n    \n    # Queue with nodes that have no incoming edges\n    queue = deque([u for u in in_degree if in_degree[u] == 0])\n    result = []\n    \n    while queue:\n        u = queue.popleft()\n        result.append(u)\n        \n        for v in graph[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n    \n    if len(result) != len(graph):\n        return \"Cycle detected, no topological ordering exists\"\n    return result\n\n# Define a directed acyclic graph\ngraph = {\n    'A': ['B'],\n    'B': ['D'],\n    'C': ['A', 'B'],\n    'D': []\n}\n\nprint(topological_sort(graph))"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "In a horizontally sharded database system, which of the following is the most important consideration when choosing a shard key?",
      "options": {
        "A": "The shard key should be unique for every record",
        "B": "The shard key should only contain numeric values for faster lookups",
        "C": "The shard key should provide even data distribution and minimize cross-shard queries",
        "D": "The shard key should be as small as possible to minimize index size"
      },
      "correct_answer": "C"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What will be the output of the following code which demonstrates transaction isolation levels in SQLAlchemy?",
      "options": {
        "A": "Initial balance: 1000, New balance: 900",
        "B": "Initial balance: 1000, New balance: 1000",
        "C": "SQLAlchemyError: Could not serialize access",
        "D": "SQLAlchemyError: Deadlock detected"
      },
      "correct_answer": "A",
      "code_example": "from sqlalchemy import create_engine, Column, Integer, String, text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import StaticPool\n\n# Create in-memory SQLite database\nengine = create_engine('sqlite:///:memory:', \n                       connect_args={'check_same_thread': False},\n                       poolclass=StaticPool)\nBase = declarative_base()\n\nclass Account(Base):\n    __tablename__ = 'accounts'\n    id = Column(Integer, primary_key=True)\n    name = Column(String(50))\n    balance = Column(Integer)\n\n# Create tables and initial data\nBase.metadata.create_all(engine)\nSession = sessionmaker(bind=engine)\nsession = Session()\n\n# Create an account with 1000 balance\nsession.add(Account(id=1, name='Alice', balance=1000))\nsession.commit()\n\n# First transaction - check balance\nfirst_session = Session()\nfirst_session.execute(text(\"BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED\"))\naccount = first_session.query(Account).filter_by(id=1).first()\ninitial_balance = account.balance\n\n# Second transaction - update balance\nsecond_session = Session()\nsecond_session.execute(text(\"BEGIN TRANSACTION\"))\naccount2 = second_session.query(Account).filter_by(id=1).first()\naccount2.balance -= 100\nsecond_session.commit()\n\n# First transaction - check balance again after second transaction has committed\naccount = first_session.query(Account).filter_by(id=1).first()\nnew_balance = account.balance\n\nprint(f\"Initial balance: {initial_balance}, New balance: {new_balance}\")"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "When working with Redis as a distributed cache, which of the following statements is true?",
      "options": {
        "A": "Redis data is automatically replicated to all nodes in a cluster configuration",
        "B": "Redis only supports string data types for efficient caching",
        "C": "Redis uses LRU (Least Recently Used) eviction by default when reaching memory limits",
        "D": "Redis can be configured with different eviction policies when memory limits are reached"
      },
      "correct_answer": "D"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "Consider the following Python test using pytest. What will happen when you run this test?",
      "options": {
        "A": "The test will pass",
        "B": "The test will fail with an assertion error",
        "C": "The test will be skipped due to the ImportError",
        "D": "The test will fail with a ValueError"
      },
      "correct_answer": "C",
      "code_example": "import pytest\n\n@pytest.fixture\ndef data_fixture():\n    return {'key': 'value'}\n\n@pytest.mark.skip(reason=\"Not ready yet\")\ndef test_simple_assert():\n    assert 1 == 2, \"This should fail\"\n\ndef test_with_fixture(data_fixture):\n    assert data_fixture['key'] == 'value'\n\n@pytest.mark.skipif(ImportError, reason=\"Optional dependency missing\")\ndef test_with_optional_dependency():\n    import non_existent_package\n    assert non_existent_package.some_function() == True"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "In a GraphQL API built with Python, which of the following best describes the main purpose of resolver functions?",
      "options": {
        "A": "To validate incoming requests before they reach the GraphQL engine",
        "B": "To optimize database queries by analyzing the GraphQL query structure",
        "C": "To define how specific fields in the GraphQL schema are fetched and computed",
        "D": "To convert GraphQL responses into the format requested by the client"
      },
      "correct_answer": "C",
      "code_example": "import graphene\nfrom graphene import relay\n\nclass User(graphene.ObjectType):\n    id = graphene.ID(required=True)\n    name = graphene.String(required=True)\n    email = graphene.String()\n    posts = graphene.List(lambda: Post)\n    \n    def resolve_posts(self, info):\n        # This is a resolver function that determines how to fetch posts\n        return [post for post in get_posts_from_db() if post.user_id == self.id]\n\nclass Post(graphene.ObjectType):\n    id = graphene.ID(required=True)\n    title = graphene.String(required=True)\n    content = graphene.String()\n    author = graphene.Field(User)\n    \n    def resolve_author(self, info):\n        # This resolver fetches the author of this post\n        return get_user_from_db(self.user_id)\n\nclass Query(graphene.ObjectType):\n    user = graphene.Field(User, id=graphene.ID(required=True))\n    posts = graphene.List(Post)\n    \n    def resolve_user(self, info, id):\n        # Root resolver for the user field\n        return get_user_from_db(id)\n    \n    def resolve_posts(self, info):\n        # Root resolver for posts field\n        return get_posts_from_db()\n\nschema = graphene.Schema(query=Query)"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What will be the output of the following code which integrates with AWS S3 using boto3?",
      "options": {
        "A": "{'ResponseMetadata': {'HTTPStatusCode': 200}, 'Location': 'https://example-bucket.s3.amazonaws.com/example.txt'}",
        "B": "True",
        "C": "Object uploaded successfully to example-bucket",
        "D": "ClientError: Access Denied"
      },
      "correct_answer": "B",
      "code_example": "import boto3\nfrom botocore.exceptions import ClientError\nimport io\n\n# Create a mock for testing instead of using actual AWS services\nclass MockS3Client:\n    def put_object(self, Bucket, Key, Body):\n        # Simulate successful upload\n        return {'ResponseMetadata': {'HTTPStatusCode': 200}}\n\n# Use the mock instead of actual boto3 client\ns3_client = MockS3Client()\n\ndef upload_file_to_s3(bucket_name, file_content, object_name):\n    try:\n        response = s3_client.put_object(\n            Bucket=bucket_name,\n            Key=object_name,\n            Body=file_content\n        )\n        return response['ResponseMetadata']['HTTPStatusCode'] == 200\n    except ClientError as e:\n        print(f\"Error: {e}\")\n        return False\n\n# Test the function\nresult = upload_file_to_s3(\n    'example-bucket',\n    io.BytesIO(b'Hello, World!'),\n    'example.txt'\n)\nprint(result)"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "Consider the following Kafka consumer code in Python. Which of these statements is true about the behavior of this consumer?",
      "options": {
        "A": "It will process messages one at a time, waiting for each to complete before fetching the next",
        "B": "It will automatically commit offsets after each message is processed",
        "C": "It will continue from the last committed offset if the consumer crashes and restarts",
        "D": "It will rebalance partitions whenever a new message is received"
      },
      "correct_answer": "C",
      "code_example": "from kafka import KafkaConsumer\nimport json\nimport time\n\nconsumer = KafkaConsumer(\n    'example-topic',\n    bootstrap_servers=['localhost:9092'],\n    auto_offset_reset='earliest',\n    enable_auto_commit=False,\n    group_id='my-consumer-group',\n    value_deserializer=lambda x: json.loads(x.decode('utf-8'))\n)\n\ndef process_message(message):\n    # Simulate processing time\n    time.sleep(1)\n    print(f\"Processed: {message.value}\")\n\ntry:\n    for message in consumer:\n        process_message(message)\n        # Manual commit after processing\n        consumer.commit()\nexcept Exception as e:\n    print(f\"Error: {e}\")\nfinally:\n    consumer.close()"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "Which approximation algorithm would be most appropriate for solving the Traveling Salesman Problem (TSP) with a performance guarantee?",
      "options": {
        "A": "Nearest Neighbor heuristic",
        "B": "Christofides algorithm",
        "C": "Random tour construction",
        "D": "Greedy vertex cover approximation"
      },
      "correct_answer": "B"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "Examine the following implementation of an AVL tree insert operation. What will be the state of the tree after executing the code?",
      "options": {
        "A": "A balanced tree with root value 15 and height 3",
        "B": "An unbalanced tree with root value 10 and height 4",
        "C": "A balanced tree with root value 20 and height 3",
        "D": "A balanced tree with root value 10 and height 3"
      },
      "correct_answer": "D",
      "code_example": "class AVLNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 1\n\nclass AVLTree:\n    def get_height(self, node):\n        if not node:\n            return 0\n        return node.height\n    \n    def get_balance(self, node):\n        if not node:\n            return 0\n        return self.get_height(node.left) - self.get_height(node.right)\n    \n    def right_rotate(self, y):\n        x = y.left\n        T2 = x.right\n        \n        # Perform rotation\n        x.right = y\n        y.left = T2\n        \n        # Update heights\n        y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1\n        x.height = max(self.get_height(x.left), self.get_height(x.right)) + 1\n        \n        return x\n    \n    def left_rotate(self, x):\n        y = x.right\n        T2 = y.left\n        \n        # Perform rotation\n        y.left = x\n        x.right = T2\n        \n        # Update heights\n        x.height = max(self.get_height(x.left), self.get_height(x.right)) + 1\n        y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1\n        \n        return y\n    \n    def insert(self, root, key):\n        # Standard BST insert\n        if not root:\n            return AVLNode(key)\n        \n        if key < root.key:\n            root.left = self.insert(root.left, key)\n        else:\n            root.right = self.insert(root.right, key)\n        \n        # Update height of ancestor\n        root.height = max(self.get_height(root.left), self.get_height(root.right)) + 1\n        \n        # Get balance factor\n        balance = self.get_balance(root)\n        \n        # Left Left Case\n        if balance > 1 and key < root.left.key:\n            return self.right_rotate(root)\n        \n        # Right Right Case\n        if balance < -1 and key > root.right.key:\n            return self.left_rotate(root)\n        \n        # Left Right Case\n        if balance > 1 and key > root.left.key:\n            root.left = self.left_rotate(root.left)\n            return self.right_rotate(root)\n        \n        # Right Left Case\n        if balance < -1 and key < root.right.key:\n            root.right = self.right_rotate(root.right)\n            return self.left_rotate(root)\n        \n        return root\n\n# Create an AVL tree and insert values\navl_tree = AVLTree()\nroot = None\n\n# Insert nodes\nvalues = [10, 20, 30, 40, 50, 25]\nfor value in values:\n    root = avl_tree.insert(root, value)\n\n# The question is asking about the state of the tree after these insertions"
    }
  ]
}
