{
  "questions": [
    {
      "id": 1,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "[0, 2, 4, 6, 8]",
        "B": "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]",
        "C": "[0, 1, 2, 3, 4]",
        "D": "[1, 3, 5, 7, 9]"
      },
      "correct_answer": "A",
      "code_example": "numbers = list(range(0, 10, 2))\nprint(numbers)"
    },
    {
      "id": 2,
      "difficulty": "easy",
      "question": "What is the purpose of the 'b' mode when opening a file in Python?",
      "options": {
        "A": "It opens the file in blocking mode, preventing other processes from accessing it",
        "B": "It opens the file in binary mode for reading or writing binary data",
        "C": "It opens the file in buffered mode, which improves I/O performance",
        "D": "It opens the file in backup mode, creating a copy before making changes"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 3,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "Name: Alice, Age: 30",
        "B": "{'name': 'Alice', 'age': 30}",
        "C": "name=Alice age=30",
        "D": "Alice is 30 years old"
      },
      "correct_answer": "D",
      "code_example": "name = \"Alice\"\nage = 30\nprint(f\"{name} is {age} years old\")"
    },
    {
      "id": 4,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "world",
        "B": "worl",
        "C": "orld",
        "D": "wor"
      },
      "correct_answer": "B",
      "code_example": "text = \"Hello world\"\nprint(text[6:10])"
    },
    {
      "id": 5,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "6",
        "B": "12",
        "C": "4",
        "D": "24"
      },
      "correct_answer": "A",
      "code_example": "import math\n\ndef gcd(a, b):\n    return math.gcd(a, b)\n\nprint(gcd(24, 18))"
    },
    {
      "id": 6,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "False",
        "B": "True",
        "C": "TypeError",
        "D": "None"
      },
      "correct_answer": "B",
      "code_example": "value = \"123\"\nprint(isinstance(value, str))"
    },
    {
      "id": 7,
      "difficulty": "easy",
      "question": "Which of the following correctly creates a custom exception in Python?",
      "options": {
        "A": "class CustomError(Error): pass",
        "B": "class CustomError extends Exception: pass",
        "C": "class CustomError(Exception): pass",
        "D": "def CustomError(Exception): pass"
      },
      "correct_answer": "C",
      "code_example": null
    },
    {
      "id": 8,
      "difficulty": "easy",
      "question": "What's the difference between parameters and arguments in Python functions?",
      "options": {
        "A": "They are different terms for the same concept",
        "B": "Parameters are used in function definitions, while arguments are values passed to functions when called",
        "C": "Arguments are defined in function signatures, while parameters are passed during function invocation",
        "D": "Parameters are optional values, while arguments are required values"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 9,
      "difficulty": "easy",
      "question": "What will be the output of the following binary search implementation when searching for the value 42?",
      "options": {
        "A": "3",
        "B": "4",
        "C": "-1",
        "D": "None"
      },
      "correct_answer": "C",
      "code_example": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\nnumbers = [10, 15, 22, 35, 40, 45, 50]\nprint(binary_search(numbers, 42))"
    },
    {
      "id": 10,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "[1, 2, 3, 4, 5]",
        "B": "[1, 2, 3]",
        "C": "[1, 2]",
        "D": "[]"
      },
      "correct_answer": "C",
      "code_example": "result = []\ni = 1\n\nwhile i <= 5:\n    if i == 3:\n        break\n    result.append(i)\n    i += 1\n\nprint(result)"
    },
    {
      "id": 11,
      "difficulty": "easy",
      "question": "Which of the following correctly checks if a string is a palindrome?",
      "options": {
        "A": "def is_palindrome(s): return s == ''.join(reversed(s))",
        "B": "def is_palindrome(s): return s == s.reverse()",
        "C": "def is_palindrome(s): return s == s[::-1]",
        "D": "Both A and C are correct"
      },
      "correct_answer": "D",
      "code_example": null
    },
    {
      "id": 12,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "Alice,30\\nBob,25\\nCharlie,35",
        "B": "['Alice', '30']\\n['Bob', '25']\\n['Charlie', '35']",
        "C": "[['Alice', '30'], ['Bob', '25'], ['Charlie', '35']]",
        "D": "Alice 30\\nBob 25\\nCharlie 35"
      },
      "correct_answer": "C",
      "code_example": "import csv\n\ncsv_data = \"\"\"Alice,30\nBob,25\nCharlie,35\"\"\"\n\nresult = []\nfor row in csv.reader(csv_data.splitlines()):\n    result.append(row)\n\nprint(result)"
    },
    {
      "id": 13,
      "difficulty": "easy",
      "question": "What is the output of the following code?",
      "options": {
        "A": "1 2.5 False Hello",
        "B": "<class 'int'> <class 'float'> <class 'bool'> <class 'str'>",
        "C": "int float bool str",
        "D": "TypeError: 'type' object is not iterable"
      },
      "correct_answer": "B",
      "code_example": "values = [1, 2.5, False, \"Hello\"]\n\nfor val in values:\n    print(type(val), end=\" \")"
    },
    {
      "id": 14,
      "difficulty": "easy",
      "question": "What is the main purpose of a context manager in Python (using the 'with' statement)?",
      "options": {
        "A": "To manage memory allocation for objects",
        "B": "To handle exceptions automatically",
        "C": "To ensure proper acquisition and release of resources",
        "D": "To create thread-safe code blocks"
      },
      "correct_answer": "C",
      "code_example": null
    },
    {
      "id": 15,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "Loop completed",
        "B": "No break occurred",
        "C": "Loop completed\\nNo break occurred",
        "D": "No output"
      },
      "correct_answer": "C",
      "code_example": "for i in range(3):\n    pass\nelse:\n    print(\"No break occurred\")\n\nprint(\"Loop completed\")"
    },
    {
      "id": 16,
      "difficulty": "easy",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "Hello Bob",
        "B": "Hello world",
        "C": "Hello",
        "D": "TypeError: greet() missing 1 required positional argument: 'name'"
      },
      "correct_answer": "A",
      "code_example": "def greet(name=\"world\"):\n    return f\"Hello {name}\"\n\nresult = greet(\"Bob\")\nprint(result)"
    },
    {
      "id": 17,
      "difficulty": "medium",
      "question": "What is the difference between the following two expressions?",
      "options": {
        "A": "The first one returns a generator object, while the second returns a list",
        "B": "The first one returns a list, while the second returns a generator object",
        "C": "They are identical and both return lists",
        "D": "They are identical and both return generator objects"
      },
      "correct_answer": "A",
      "code_example": "# Expression 1\n(x**2 for x in range(5))\n\n# Expression 2\n[x**2 for x in range(5)]"
    },
    {
      "id": 18,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "(1, 2, 3, 4, 5)",
        "B": "[1, 2, 3, 4, 5]",
        "C": "{'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}",
        "D": "TypeError: function() got multiple values for keyword argument"
      },
      "correct_answer": "C",
      "code_example": "def function(*args, **kwargs):\n    return kwargs\n\nresult = function(1, 2, 3, 4, 5, a=1, b=2, c=3, d=4, e=5)\nprint(result)"
    },
    {
      "id": 19,
      "difficulty": "medium",
      "question": "What will be the output of the following code that identifies connected components in an undirected graph?",
      "options": {
        "A": "[[0, 1, 2], [3, 4], [5]]",
        "B": "[[0, 1, 2], [3, 4, 5]]",
        "C": "[[0, 1, 2, 3, 4, 5]]",
        "D": "[[0], [1], [2], [3], [4], [5]]"
      },
      "correct_answer": "A",
      "code_example": "def find_connected_components(graph):\n    visited = set()\n    components = []\n    \n    def dfs(node, component):\n        visited.add(node)\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, component)\n    \n    for node in range(len(graph)):\n        if node not in visited:\n            component = []\n            dfs(node, component)\n            components.append(component)\n    \n    return components\n\ngraph = [\n    [1, 2],  # Node 0 connected to 1, 2\n    [0, 2],  # Node 1 connected to 0, 2\n    [0, 1],  # Node 2 connected to 0, 1\n    [4],     # Node 3 connected to 4\n    [3],     # Node 4 connected to 3\n    []       # Node 5 has no connections\n]\n\nprint(find_connected_components(graph))"
    },
    {
      "id": 20,
      "difficulty": "medium",
      "question": "Which regular expression pattern correctly matches a valid email address in the form username@domain.tld?",
      "options": {
        "A": "^[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z]{2,}$",
        "B": "^[\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,}$",
        "C": "^\\w+@\\w+\\.\\w+$",
        "D": "^.+@.+\\..+$"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 21,
      "difficulty": "medium",
      "question": "What will be the output of the following code?",
      "options": {
        "A": "[1, 2, 3]",
        "B": "[1, 2, 3, 4]",
        "C": "[1, 2, 3, 4, 5]",
        "D": "TypeError: 'tuple' object does not support item assignment"
      },
      "correct_answer": "D",
      "code_example": "def modify_collection(collection):\n    collection += (4, 5)\n    return collection\n\ntuple_data = (1, 2, 3)\nmodify_collection(tuple_data)\nprint(tuple_data)"
    },
    {
      "id": 22,
      "difficulty": "medium",
      "question": "What will be the output of the following code using the functools module?",
      "options": {
        "A": "Computing fibonacci(5)...\nComputing fibonacci(4)...\nComputing fibonacci(3)...\nComputing fibonacci(2)...\nComputing fibonacci(1)...\nComputing fibonacci(0)...\n8",
        "B": "Computing fibonacci(5)...\nComputing fibonacci(4)...\nComputing fibonacci(3)...\nComputing fibonacci(2)...\nComputing fibonacci(1)...\n5",
        "C": "Computing fibonacci(5)...\n5",
        "D": "Computing fibonacci(5)...\n8"
      },
      "correct_answer": "C",
      "code_example": "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fibonacci(n):\n    print(f\"Computing fibonacci({n})...\")\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n# Calculate fibonacci once for n=5\nfibonacci(5)\n# Call again with the same value\nprint(fibonacci(5))"
    },
    {
      "id": 23,
      "difficulty": "medium",
      "question": "Which of the following is a secure way to handle API authentication using a token?",
      "options": {
        "A": "Storing the token in a global variable accessible throughout the application",
        "B": "Hardcoding the token directly in the source code",
        "C": "Sending the token as a URL parameter in API requests",
        "D": "Sending the token in an Authorization header with each request"
      },
      "correct_answer": "D",
      "code_example": null
    },
    {
      "id": 24,
      "difficulty": "medium",
      "question": "What will be the output of the following code implementing the two-pointer technique?",
      "options": {
        "A": "[1, 3, 5, 7, 9]",
        "B": "[-7, -3, 1, 5, 9]",
        "C": "[1, 9, 25, 49, 81]",
        "D": "[]"
      },
      "correct_answer": "B",
      "code_example": "def sort_by_absolute_value(arr):\n    left = 0\n    right = len(arr) - 1\n    result = [0] * len(arr)\n    \n    for i in range(len(arr) - 1, -1, -1):\n        if abs(arr[left]) > abs(arr[right]):\n            result[i] = arr[left]\n            left += 1\n        else:\n            result[i] = arr[right]\n            right -= 1\n    \n    return result\n\nnumbers = [-3, 1, -7, 5, 9]\nprint(sort_by_absolute_value(numbers))"
    },
    {
      "id": 25,
      "difficulty": "medium",
      "question": "What is the correct order of directories that Python searches when importing a module?",
      "options": {
        "A": "Current directory, PYTHONPATH directories, Standard library directories, Site-packages directories",
        "B": "Standard library directories, Current directory, PYTHONPATH directories, Site-packages directories",
        "C": "Site-packages directories, Standard library directories, Current directory, PYTHONPATH directories",
        "D": "PYTHONPATH directories, Current directory, Standard library directories, Site-packages directories"
      },
      "correct_answer": "A",
      "code_example": null
    },
    {
      "id": 26,
      "difficulty": "medium",
      "question": "What will be the output of the following stack and queue implementation?",
      "options": {
        "A": "Popped: 3\nDequeued: 1",
        "B": "Popped: 3\nDequeued: 3",
        "C": "Popped: 1\nDequeued: 1",
        "D": "Popped: 1\nDequeued: 3"
      },
      "correct_answer": "A",
      "code_example": "class Stack:\n    def __init__(self):\n        self.items = []\n        \n    def push(self, item):\n        self.items.append(item)\n        \n    def pop(self):\n        if not self.is_empty():\n            return self.items.pop()\n        return None\n    \n    def is_empty(self):\n        return len(self.items) == 0\n\nclass Queue:\n    def __init__(self):\n        self.items = []\n        \n    def enqueue(self, item):\n        self.items.append(item)\n        \n    def dequeue(self):\n        if not self.is_empty():\n            return self.items.pop(0)\n        return None\n    \n    def is_empty(self):\n        return len(self.items) == 0\n\n# Test stack\nstack = Stack()\nstack.push(1)\nstack.push(2)\nstack.push(3)\nprint(f\"Popped: {stack.pop()}\")\n\n# Test queue\nqueue = Queue()\nqueue.enqueue(1)\nqueue.enqueue(2)\nqueue.enqueue(3)\nprint(f\"Dequeued: {queue.dequeue()}\")"
    },
    {
      "id": 27,
      "difficulty": "medium",
      "question": "What characteristic of Python makes functions 'first-class citizens'?",
      "options": {
        "A": "Functions can be defined inside other functions",
        "B": "Functions can be passed as arguments to other functions, returned from functions, and assigned to variables",
        "C": "Functions can access variables from their containing scope",
        "D": "Functions can be decorated to modify their behavior"
      },
      "correct_answer": "B",
      "code_example": null
    },
    {
      "id": 28,
      "difficulty": "medium",
      "question": "What will be the output of the following code implementing the sliding window approach?",
      "options": {
        "A": "[3, 3, 4, 5, 5]",
        "B": "[1, 3, 5, -1, 3]",
        "C": "[3, 3, 5, 5, 5]",
        "D": "[3, 5, 5, 5, 5]"
      },
      "correct_answer": "C",
      "code_example": "def max_sliding_window(nums, k):\n    result = []\n    for i in range(len(nums) - k + 1):\n        window = nums[i:i+k]\n        result.append(max(window))\n    return result\n\nnumbers = [1, 3, -1, -3, 5, 3, 6, 7]\nwindow_size = 3\nprint(max_sliding_window(numbers, window_size))"
    },
    {
      "id": 29,
      "difficulty": "medium",
      "question": "What will be the output of the following code using recursion with memoization?",
      "options": {
        "A": "55",
        "B": "89",
        "C": "610",
        "D": "987"
      },
      "correct_answer": "C",
      "code_example": "def fibonacci(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    \n    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n    return memo[n]\n\nprint(fibonacci(15))"
    },
    {
      "id": 30,
      "difficulty": "medium",
      "question": "What will be the output of the following JSON parsing and serialization code?",
      "options": {
        "A": "{'name': 'Alice', 'age': 30, 'skills': ['Python', 'JavaScript']}",
        "B": "{'name': 'Alice', 'age': 30, 'skills': ['Python', 'JavaScript'], 'active': True}",
        "C": "{'name': 'Alice', 'age': 30, 'skills': ['Python', 'JavaScript'], 'active': true}",
        "D": "{'name': 'Alice', 'age': 30, 'skills': ['Python', 'JavaScript'], 'active': 'true'}"
      },
      "correct_answer": "C",
      "code_example": "import json\n\nuser_data = {'name': 'Alice', 'age': 30, 'skills': ['Python', 'JavaScript']}\n\n# Add a new field\nuser_data['active'] = True\n\n# Convert to JSON string\njson_str = json.dumps(user_data)\n\n# Parse back to Python object\nparsed_data = json.loads(json_str)\n\nprint(parsed_data)"
    },
    {
      "id": 31,
      "difficulty": "medium",
      "question": "Which HTTP method is most appropriate for updating an existing resource in a RESTful API?",
      "options": {
        "A": "GET",
        "B": "POST",
        "C": "PUT",
        "D": "DELETE"
      },
      "correct_answer": "C",
      "code_example": null
    },
    {
      "id": 32,
      "difficulty": "medium",
      "question": "What will be the output of the following binary tree implementation?",
      "options": {
        "A": "3 1 2",
        "B": "1 3 2",
        "C": "1 2 3",
        "D": "2 1 3"
      },
      "correct_answer": "B",
      "code_example": "class TreeNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef inorder_traversal(root):\n    result = []\n    if root:\n        # Traverse left subtree\n        result.extend(inorder_traversal(root.left))\n        # Visit root\n        result.append(root.value)\n        # Traverse right subtree\n        result.extend(inorder_traversal(root.right))\n    return result\n\n# Create a simple binary tree\nroot = TreeNode(3)\nroot.left = TreeNode(1)\nroot.right = TreeNode(2)\n\nprint(*inorder_traversal(root))"
    },
{
      "id": 33,
      "difficulty": "hard",
      "question": "What will be the output of the following Scikit-learn code that uses StandardScaler?",
      "options": {
        "A": "[[0.0, 0.0], [1.0, 1.0], [2.0, 2.0]]",
        "B": "[[0.0, 0.0], [0.5, 0.5], [1.0, 1.0]]",
        "C": "[[-1.22, -1.22], [0.0, 0.0], [1.22, 1.22]]",
        "D": "[[-1.0, -1.0], [0.0, 0.0], [1.0, 1.0]]"
      },
      "correct_answer": "C",
      "code_example": "import numpy as np\nfrom sklearn.preprocessing import StandardScaler\n\nX = np.array([[1, 1], [2, 2], [3, 3]])\nscaler = StandardScaler()\nscaler.fit(X)\ntransformed = scaler.transform(X)\n\n# Round to 2 decimal places for clarity\nrounded = np.round(transformed, 2)\nprint(rounded.tolist())"
    },
    {
      "id": 34,
      "difficulty": "hard",
      "question": "Which Python profiling tool provides the most detailed information about function call times and memory usage with minimal overhead?",
      "options": {
        "A": "cProfile",
        "B": "line_profiler",
        "C": "memory_profiler",
        "D": "Py-Spy"
      },
      "correct_answer": "B"
    },
    {
      "id": 35,
      "difficulty": "hard",
      "question": "Which of the following code snippets demonstrates the most secure way to handle user-provided file paths in Python?",
      "options": {
        "A": "filename = user_input\nwith open(filename, 'r') as f:\n    data = f.read()",
        "B": "import os\nfilename = os.path.basename(user_input)\nwith open(filename, 'r') as f:\n    data = f.read()",
        "C": "import os\nfrom pathlib import Path\n\nbase_dir = Path('/safe/data/directory')\ntry:\n    file_path = base_dir / os.path.basename(user_input)\n    if not file_path.is_file() or not str(file_path).startswith(str(base_dir)):\n        raise ValueError(\"Invalid file path\")\n    with open(file_path, 'r') as f:\n        data = f.read()\nexcept (ValueError, IOError) as e:\n    print(f\"Error: {e}\")",
        "D": "import os\nif os.path.exists(user_input):\n    with open(user_input, 'r') as f:\n        data = f.read()"
      },
      "correct_answer": "C"
    },
    {
      "id": 36,
      "difficulty": "hard",
      "question": "What will be the output of the following code demonstrating threading vs multiprocessing in Python?",
      "options": {
        "A": "Thread time: faster time\nProcess time: slower time",
        "B": "Thread time: slower time\nProcess time: faster time",
        "C": "Both will take approximately the same time",
        "D": "The code will raise a RuntimeError"
      },
      "correct_answer": "B",
      "code_example": "import time\nimport threading\nimport multiprocessing\nimport math\n\ndef cpu_heavy(n):\n    # CPU-bound task\n    result = 0\n    for i in range(n):\n        result += math.sqrt(i ** 2)\n    return result\n\ndef run_threads(n_jobs, n_numbers):\n    start = time.time()\n    threads = []\n    for _ in range(n_jobs):\n        t = threading.Thread(target=cpu_heavy, args=(n_numbers,))\n        threads.append(t)\n        t.start()\n    for t in threads:\n        t.join()\n    return time.time() - start\n\ndef run_processes(n_jobs, n_numbers):\n    start = time.time()\n    processes = []\n    for _ in range(n_jobs):\n        p = multiprocessing.Process(target=cpu_heavy, args=(n_numbers,))\n        processes.append(p)\n        p.start()\n    for p in processes:\n        p.join()\n    return time.time() - start\n\nif __name__ == \"__main__\":\n    n_jobs = 4\n    n_numbers = 10000000  # 10 million\n    \n    thread_time = run_threads(n_jobs, n_numbers)\n    process_time = run_processes(n_jobs, n_numbers)\n    \n    print(f\"Thread time: {thread_time:.2f} seconds\")\n    print(f\"Process time: {process_time:.2f} seconds\")\n    \n    if thread_time < process_time:\n        print(\"Thread time: faster time\\nProcess time: slower time\")\n    else:\n        print(\"Thread time: slower time\\nProcess time: faster time\")"
    },
    {
      "id": 37,
      "difficulty": "hard",
      "question": "Which of the following is the most effective API rate limiting strategy for a Python web application?",
      "options": {
        "A": "Fixed Window - Count requests in fixed time intervals and block when threshold is exceeded",
        "B": "Leaky Bucket - Allow a consistent outflow of requests with a fixed capacity buffer",
        "C": "Token Bucket - Accumulate tokens at a steady rate up to a maximum, with each request consuming a token",
        "D": "Sliding Log - Track timestamp of each request and count those within the sliding window"
      },
      "correct_answer": "C"
    },
    {
      "id": 38,
      "difficulty": "hard",
      "question": "What will be the output of the following code using mixins and composition?",
      "options": {
        "A": "In LoggerMixin.log: Message\nProcessing data\nIn DatabaseMixin.save: Data saved",
        "B": "Processing data\nIn LoggerMixin.log: Message\nIn DatabaseMixin.save: Data saved",
        "C": "Processing data\nIn DatabaseMixin.save: Data saved\nIn LoggerMixin.log: Message",
        "D": "In LoggerMixin.log: Message\nIn DatabaseMixin.save: Data saved\nProcessing data"
      },
      "correct_answer": "B",
      "code_example": "class LoggerMixin:\n    def log(self, message):\n        print(f\"In LoggerMixin.log: {message}\")\n\nclass DatabaseMixin:\n    def save(self, data):\n        print(f\"In DatabaseMixin.save: {data}\")\n\nclass DataProcessor(LoggerMixin, DatabaseMixin):\n    def process(self, data):\n        print(\"Processing data\")\n        self.log(\"Message\")\n        self.save(\"Data saved\")\n\nprocessor = DataProcessor()\nprocessor.process(\"sample data\")"
    },
    {
      "id": 39,
      "difficulty": "hard",
      "question": "Which of the following WebSocket implementation methods in Python maintains the connection open for bidirectional communication after the HTTP handshake?",
      "options": {
        "A": "ws.send_frame(bytes(message, 'utf-8'), fin=0)",
        "B": "ws.send_frame(bytes(message, 'utf-8'), fin=1)",
        "C": "ws.send_frame(bytes(message, 'utf-8'), opcode=0x1)",
        "D": "ws.send_frame(bytes(message, 'utf-8'), opcode=0x8)"
      },
      "correct_answer": "C"
    },
    {
      "id": 40,
      "difficulty": "hard",
      "question": "What will be the output of the following code that uses Scrapy's selector?",
      "options": {
        "A": "['title1', 'title2', 'title3']",
        "B": "['Title 1', 'Title 2', 'Title 3']",
        "C": "[' Title 1 ', ' Title 2 ', ' Title 3 ']",
        "D": "['<h1>Title 1</h1>', '<h1>Title 2</h1>', '<h1>Title 3</h1>']"
      },
      "correct_answer": "B",
      "code_example": "from scrapy import Selector\n\nhtml = '''\n<div>\n  <h1>Title 1</h1>\n  <p>Description 1</p>\n  <h1>Title 2</h1>\n  <p>Description 2</p>\n  <h1>Title 3</h1>\n  <p>Description 3</p>\n</div>\n'''\n\nsel = Selector(text=html)\ntitles = sel.css('h1::text').getall()\nprint(titles)"
    },
    {
      "id": 41,
      "difficulty": "hard",
      "question": "What will be the output of the following backtracking algorithm implementation?",
      "options": {
        "A": "[1, 3, 0, 2]",
        "B": "[0, 2, 1, 3]",
        "C": "[2, 0, 3, 1]",
        "D": "[1, 3]"
      },
      "correct_answer": "C",
      "code_example": "def is_safe(board, row, col, n):\n    # Check row\n    for i in range(col):\n        if board[row][i] == 1:\n            return False\n    \n    # Check upper diagonal\n    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    \n    # Check lower diagonal\n    for i, j in zip(range(row, n), range(col, -1, -1)):\n        if board[i][j] == 1:\n            return False\n    \n    return True\n\ndef solve_nqueens(n):\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    solutions = []\n    \n    def backtrack(col):\n        if col >= n:\n            # Found a solution, extract queen positions\n            queens = []\n            for i in range(n):\n                for j in range(n):\n                    if board[i][j] == 1:\n                        queens.append(j)\n            solutions.append(queens)\n            return\n        \n        for row in range(n):\n            if is_safe(board, row, col, n):\n                board[row][col] = 1\n                backtrack(col + 1)\n                board[row][col] = 0  # Backtrack\n    \n    backtrack(0)\n    return solutions[0] if solutions else []\n\nprint(solve_nqueens(4))"
    },
    {
      "id": 42,
      "difficulty": "hard",
      "question": "When designing a database schema, which indexing strategy would be most efficient for a query that frequently filters on one column and sorts by another?",
      "options": {
        "A": "Create separate single-column indexes on both fields",
        "B": "Create a composite index with the filter column first, followed by the sort column",
        "C": "Create a composite index with the sort column first, followed by the filter column",
        "D": "Only index the filter column and rely on in-memory sorting"
      },
      "correct_answer": "B"
    },
    {
      "id": 43,
      "difficulty": "hard",
      "question": "What will be the output of the following NumPy vectorization code?",
      "options": {
        "A": "4.0",
        "B": "8.0",
        "C": "11.0",
        "D": "5.5"
      },
      "correct_answer": "A",
      "code_example": "import numpy as np\n\ndef slow_euclidean(a, b):\n    result = 0\n    for i in range(len(a)):\n        result += (a[i] - b[i]) ** 2\n    return np.sqrt(result)\n\ndef fast_euclidean(a, b):\n    return np.sqrt(np.sum((a - b) ** 2))\n\na = np.array([1, 2, 3, 4])\nb = np.array([3, 4, 5, 6])\n\nresult = fast_euclidean(a, b)\nprint(result)"
    },
    {
      "id": 44,
      "difficulty": "hard",
      "question": "What will be the output of the following code that implements the Observer design pattern?",
      "options": {
        "A": "Observer 1 received: Message 1\nObserver 2 received: Message 1\nObserver 1 received: Message 2\nObserver 2 received: Message 2",
        "B": "Observer 1 received: Message 1\nObserver 1 received: Message 2\nObserver 2 received: Message 1\nObserver 2 received: Message 2",
        "C": "Observer 1 received: Message 1\nObserver 1 received: Message 2",
        "D": "Observer 2 received: Message 1\nObserver 2 received: Message 2"
      },
      "correct_answer": "A",
      "code_example": "class Subject:\n    def __init__(self):\n        self._observers = []\n    \n    def register_observer(self, observer):\n        if observer not in self._observers:\n            self._observers.append(observer)\n    \n    def remove_observer(self, observer):\n        if observer in self._observers:\n            self._observers.remove(observer)\n    \n    def notify_observers(self, message):\n        for observer in self._observers:\n            observer.update(message)\n\nclass Observer:\n    def __init__(self, name):\n        self.name = name\n    \n    def update(self, message):\n        print(f\"{self.name} received: {message}\")\n\n# Create subject and observers\nsubject = Subject()\nobserver1 = Observer(\"Observer 1\")\nobserver2 = Observer(\"Observer 2\")\n\n# Register observers\nsubject.register_observer(observer1)\nsubject.register_observer(observer2)\n\n# Notify all observers\nsubject.notify_observers(\"Message 1\")\nsubject.notify_observers(\"Message 2\")"
    },
    {
      "id": 45,
      "difficulty": "hard",
      "question": "What will be the output of the following code that uses descriptors?",
      "options": {
        "A": "Setting age to 25\nGetting age: 25\nSetting age to 15\nValueError: Age must be at least 18",
        "B": "Setting age to 25\nGetting age: 25\nSetting age to 15\nGetting age: 15",
        "C": "Setting age to 25\nGetting age: 25\nValueError: Age must be at least 18",
        "D": "25\nValueError: Age must be at least 18"
      },
      "correct_answer": "C",
      "code_example": "class AgeDescriptor:\n    def __init__(self, min_age=0):\n        self.min_age = min_age\n        self.name = None\n    \n    def __set_name__(self, owner, name):\n        self.name = name\n    \n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        print(f\"Getting {self.name}: {instance.__dict__[self.name]}\")\n        return instance.__dict__[self.name]\n    \n    def __set__(self, instance, value):\n        print(f\"Setting {self.name} to {value}\")\n        if value < self.min_age:\n            raise ValueError(f\"{self.name.capitalize()} must be at least {self.min_age}\")\n        instance.__dict__[self.name] = value\n\nclass Person:\n    age = AgeDescriptor(min_age=18)\n    \n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\ntry:\n    person = Person(\"John\", 25)\n    print(person.age)\n    \n    person.age = 15  # Should raise ValueError\n    print(person.age)  # Won't execute due to ValueError\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")"
    },
    {
      "id": 46,
      "difficulty": "hard",
      "question": "What will be the output of the following basic ML pipeline implementation?",
      "options": {
        "A": "Training accuracy: > 0.9\nTesting accuracy: < 0.7",
        "B": "Training accuracy: > 0.9\nTesting accuracy: > 0.9",
        "C": "Training accuracy: < 0.7\nTesting accuracy: < 0.7",
        "D": "Training accuracy: > 0.7\nTesting accuracy: > 0.7"
      },
      "correct_answer": "A",
      "code_example": "from sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.metrics import accuracy_score\n\n# Load the iris dataset\niris = load_iris()\nX, y = iris.data, iris.target\n\n# Train/test split with a small training set to demonstrate overfitting\nX_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.2, random_state=42)\n\n# Create a pipeline with preprocessing and a model\npipeline = Pipeline([\n    ('scaler', StandardScaler()),\n    ('classifier', LogisticRegression(C=100, max_iter=10000))\n])\n\n# Train the model\npipeline.fit(X_train, y_train)\n\n# Make predictions\ny_train_pred = pipeline.predict(X_train)\ny_test_pred = pipeline.predict(X_test)\n\n# Compute accuracy scores\ntrain_accuracy = accuracy_score(y_train, y_train_pred)\ntest_accuracy = accuracy_score(y_test, y_test_pred)\n\nprint(f\"Training accuracy: {train_accuracy:.2f}\")\nprint(f\"Testing accuracy: {test_accuracy:.2f}\")\n\n# Output the result based on accuracy thresholds\nif train_accuracy > 0.9 and test_accuracy < 0.7:\n    print(\"Training accuracy: > 0.9\\nTesting accuracy: < 0.7\")\nelif train_accuracy > 0.9 and test_accuracy > 0.9:\n    print(\"Training accuracy: > 0.9\\nTesting accuracy: > 0.9\")\nelif train_accuracy < 0.7 and test_accuracy < 0.7:\n    print(\"Training accuracy: < 0.7\\nTesting accuracy: < 0.7\")\nelse:\n    print(\"Training accuracy: > 0.7\\nTesting accuracy: > 0.7\")"
    },
    {
      "id": 47,
      "difficulty": "hard",
      "question": "Which of the following debugging techniques is most effective for identifying memory leaks in a long-running Python application?",
      "options": {
        "A": "Using pdb with breakpoints at suspicious locations",
        "B": "Adding logging statements to track object creation and destruction",
        "C": "Running the code with Python's garbage collector debug flags and using tracemalloc",
        "D": "Periodically calling gc.collect() in the application code"
      },
      "correct_answer": "C"
    },
    {
      "id": 48,
      "difficulty": "hard",
      "question": "What will be the output of the following Pandas data manipulation code?",
      "options": {
        "A": "The resulting DataFrame will have 5 rows with missing values filled as 0",
        "B": "The resulting DataFrame will have 3 rows with data for both products",
        "C": "The resulting DataFrame will have 5 rows and a new 'total_sales' column with the sum of all sales",
        "D": "The resulting DataFrame will have 5 rows and a 'sales_difference' column showing Product A - Product B"
      },
      "correct_answer": "D",
      "code_example": "import pandas as pd\nimport numpy as np\n\n# Create sample data\ndates = pd.date_range('2023-01-01', periods=5, freq='D')\nproduct_a = pd.Series([10, 15, 12, np.nan, 20], index=dates, name='Product A')\nproduct_b = pd.Series([8, np.nan, 11, 13, 15], index=dates, name='Product B')\n\n# Create a DataFrame from the two Series\ndf = pd.DataFrame({'Product A': product_a, 'Product B': product_b})\n\n# Fill NaN values with 0 for calculations\ndf_filled = df.fillna(0)\n\n# Calculate the difference in sales between products\ndf_filled['sales_difference'] = df_filled['Product A'] - df_filled['Product B']\n\n# Check the shape of the final DataFrame\nrows, cols = df_filled.shape\n\nif rows == 5 and 'sales_difference' in df_filled.columns:\n    print(\"The resulting DataFrame will have 5 rows and a 'sales_difference' column showing Product A - Product B\")\nelif rows == 3:\n    print(\"The resulting DataFrame will have 3 rows with data for both products\")\nelif 'total_sales' in df_filled.columns:\n    print(\"The resulting DataFrame will have 5 rows and a new 'total_sales' column with the sum of all sales\")\nelse:\n    print(\"The resulting DataFrame will have 5 rows with missing values filled as 0\")"
    }
  ]
}
